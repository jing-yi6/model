## 杂项

### bitset
```cpp
bitset<1000> b;  // 声明一个大小为 1000 的bitset，默认为全0
bitset<8> b1(42);  // 42 的二进制表示是 00101010
bitset<8> b2("10101010");  // 使用二进制字符串初始化
b.size() // 返回 bitset 中的位数
b.count() // 返回 bitset 中为 1 的位数
b.any() // 如果 bitset 中有任何位为 1，返回 true，否则返回 false
b.none() // 如果 bitset 中没有任何位为 1，返回 true，否则返回 false
b.flip() // 翻转 bitset 中所有位。
b.set()  // 将所有位设置为 1
b.set(0, 0);  // 设置第 0 位为 0
b.reset() // 将所有位重置为 0
b.reset(1)  // 设置第 1 位为 0
b.to_string() // 返回 bitset 对应的二进制字符串表示
// 可以使用下标操作符 [] 访问或修改 bitset 中的单个二进制位。
```
### 蔡勒
```cpp
int get(int year, int month, int day) {
    if (month <= 2) {
        month += 12;
        year--;
    }
    int c = year / 100, y = year % 100, m = month, d = day;
    int w = y + y / 4 + c / 4 - 2 * c + 26 * (m + 1) / 10 + d - 1;
    w = (w % 7 + 7) % 7;
    return w;
}
```

### 对顶堆求动态中位数
```cpp
void solve() {
    int n;
    cin >> n;
    priority_queue<int> down;
    priority_queue<int, vector<int>, greater<int>> up;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        if (down.empty() || x <= down.top()) down.push(x);
        else up.push(x);
        if (down.size() > up.size() + 1) {
            up.push(down.top());
            down.pop();
        }
        if (up.size() > down.size()) {
            down.push(up.top());
            up.pop();
        }
        if (i % 2) cout << down.top() << ' ';
    }
}
```

### 对拍
```py
import subprocess
import difflib
import os

DATA_CPP = "data.cpp"
BF_CPP = "bf.cpp"
MAIN_CPP = "main.cpp"

DATA_EXE = "./data"   
BF_EXE = "./bf"
MAIN_EXE = "./main"

# 判断平台自动添加.exe
if os.name == 'nt':
    DATA_EXE = "data.exe"
    BF_EXE = "bf.exe"
    MAIN_EXE = "main.exe"

# 编译阶段
print("正在编译...")
subprocess.run(["g++", DATA_CPP, "-o", DATA_EXE], check=True)
subprocess.run(["g++", BF_CPP, "-o", BF_EXE], check=True)
subprocess.run(["g++", MAIN_CPP, "-o", MAIN_EXE], check=True)

print("开始对拍...")

for i in range(1, 1001):
    # 生成数据
    with open("input.txt", "w") as f:
        subprocess.run([DATA_EXE], stdout=f)

    # 暴力输出
    with open("input.txt", "r") as fin, open("ans_bf.txt", "w") as fout:
        subprocess.run([BF_EXE], stdin=fin, stdout=fout)

    # 优化输出
    with open("input.txt", "r") as fin, open("ans_main.txt", "w") as fout:
        subprocess.run([MAIN_EXE], stdin=fin, stdout=fout)

    # 读取两个结果
    with open("ans_bf.txt") as f1, open("ans_main.txt") as f2:
        ans1 = f1.readlines()
        ans2 = f2.readlines()

    if ans1 != ans2:
        print(f"第 {i} 组数据输出不一致！")
        print("输入数据：")
        with open("input.txt") as fin:
            print(fin.read())
        print("正确答案：")
        print("".join(ans1))
        print("你的输出：")
        print("".join(ans2))
        print("差异：")
        diff = difflib.unified_diff(ans1, ans2, fromfile='bf', tofile='main')
        print("".join(diff))
        break
    else:
        print(f"第 {i} 组通过")

```

### 根号调整
```cpp
i128 sqrtup(i128 x) { // 返回大于等于根号的第一个数
    i128 d = sqrtl(x);
    while (d * d > x) d--;
    while (d * d < x) d++;
    return d;
}
i128 sqrtdn(i128 x) { // 返回小于等于根号的第一个数
    i128 d = sqrtl(x);
    while (d * d < x) d++;
    while (d * d > x) d--;
    return d;
}
```

### 环形均分
```cpp
int a[N];
LL c[N], s[N];
LL work(int n, int a[]) {
    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];
    if (s[n] % n) return -1;
    LL avg = s[n] / n;
    c[1] = 0;
    for (int i = 2; i <= n; i++) c[i] = s[i - 1] - (i - 1) * avg; 
    sort(c + 1, c + n + 1);
    LL res = 0;
    for (int i = 1; i <= n; i++) res += abs(c[i] - c[n + 1 >> 1]);
    return res;
}
```

### 康托展开

#### 排列到排名
$\text{ans} = 1 + \sum_{i=1}^{n} A[i] \times (n - i)!,$
$\text{其中} A[i] \text{代表} \sum_{j=i}^{n} [a[j] < a[i]]$
```cpp
const int N = 1e6 + 1, mod = 998244353;
int n;
int tr[N];
i64 fact[N];
void add(int x) {
    for (int i = x; i <= n; i += i & (-i)) {
        tr[i] += 1;
    }
}
int query(int x) {
    int res = 0;
    for (int i = x; i; i -= i & (-i)) res += tr[i];
    return res;
}
int query(int l, int r) {
    return query(r) - query(l - 1);
}
void solve() {
    cin >> n;
    vector<int> a(n + 1);
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        fact[i] = fact[i - 1] * i % mod;
    }
    i64 ans = 1;
    for (int i = n; i >= 1; i--) {
        ans += (i64)query(1, a[i]) * fact[n - i];
        ans %= mod;
        add(a[i]);
    }
    cout << ans << '\n';
}
```

#### 排名到排列
按照康托展开的逆过程，首先将排序从 0 开始编号。<br>
然后将排名转化为阶乘进制：$n = \sum_{i=1}^{n} A[i] \times (n - i)!$ <br>
根据 $A[i]$ 即可通过权值线段树上二分得到排列

### 逆序对
```cpp
int tmp[N];
i64 cnt;
void merge_sort(int q[], int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else {
            tmp[k++] = q[j++];
            cnt += (mid - i + 1);
        }
    }
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];
    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}
```

### 输出txt
```cpp
ofstream outfile("output.txt");
void solve() {
    vector<int> a(4);
    a[0] = 0, a[1] = 1, a[2] = 2, a[3] = 3;
    for (int i = 0; i < 4; i++) outfile << i << ' ' << a[i] << '\n';
}
```

### 跳跃游戏
求 1 步 最远到哪 2 步最远到哪 ..... <br>
end 是当前这一步的结尾 maxPos 是下一步的结尾
```cpp
int jump(vector<int>& nums) {
    int maxPos = 0, n = nums.size(), end = 0, step = 0;
    for (int i = 0; i < n - 1; i++) {
        if (maxPos >= i) {
            maxPos = max(maxPos, i + nums[i]);
            if (i == end) {
                end = maxPos;
                ++step;
            }
        }
    }
    return step;
}
```

### 约瑟夫环加强
```cpp
void solve() {
    /*
    普通约瑟夫环
    int n, k;
    cin >> n >> k;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) a[i] = k;
    */
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i]; // 每轮删第几个数字
    int ans = 1;
    for (int c = 2, i = n - 1; c <= n; c++, i--) ans = (ans + a[i] - 1) % c + 1;
    cout << ans << '\n';
}
```

### INT_128
```cpp
void put(i128 x) {
    vector<int> s;
    do {
        s.push_back(x % 10);
        x /= 10;
    } while (x);
    while (!s.empty()) {
        cout << s.back();
        s.pop_back();
    }
    cout << "\n";
}
```

### 初始化
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
using i64 = long long;
using u64 = unsigned long long;
using i128 = __int128;

void solve() {
    
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

### 数字的根
```cpp
f(x) = (x - 1) % 9 + 1
// 不妨让 f(x) = x % 9, 这样 0 和 9 共用，算 9 的贡献时只需扣掉 0 的贡献
```

### 三分
```cpp
int l = max(z - y, 0), r = min(x, z);
i64 ans = 0;
auto query = [&](int l, int r) -> int {
    i64 ansl = a[l] + b[z - l];
    i64 ansr = a[r] + b[z - r];
    if (ansl < ansr) return -1;
    else if (ansl > ansr) return 1;
    else return 0;
};
while (l <= r) {
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    auto val = query(lmid, rmid);
    if (val == -1) {
        ans = rmid;
        l = lmid + 1;
    } 
    else if (val == 1) {
        ans = lmid;
        r = rmid - 1;
    }   
    else {
        ans = rmid;
        l = lmid + 1;
        r = rmid - 1;
    }
}
```

### 排列左移
在排列的一段连续区间，如果区间长度为奇数，那么循环左移不影响逆序对数量，如果区间长度为偶数，那么循环左移一次逆序对奇偶性发生变化

### 最大子矩阵和
枚举矩阵在行上的底和高，压缩为一个值，在列上做最大字段和 $O(n^2 m)$, 同理也可 $O(m^2 n)$

### 前缀和 & 差分

#### 前缀和
𝑘 维前缀和就等于 𝑘 次求和。所以每次只考虑一个维度，固定所有其它维度，然后求若干个一维前缀和，这样对所有 𝑘 个维度分别求和之后，得到的就是 𝑘 维前缀和。
```cpp
void prefix_sum() {
    // Prefix-sum for 3rd dimension.
    for (int i = 1; i <= N1; i++) {
        for (int j = 1; j <= N2; j++) {
            for (int k = 1; k <= N3; k++) {
                ps[i][j][k] += ps[i][j][k - 1];
            }
        }
    }
    // Prefix-sum for 2nd dimension.
    for (int i = 1; i <= N1; i++) {
        for (int j = 1; j <= N2; j++) {
            for (int k = 1; k <= N3; k++) {
                ps[i][j][k] += ps[i][j - 1][k];
            }
        }
    }
    // Prefix-sum for 1st dimension.
    for (int i = 1; i <= N1; i++) {
        for (int j = 1; j <= N2; j++) {
            for (int k = 1; k <= N3; k++) {
                ps[i][j][k] += ps[i - 1][j][k];
            }
        }
    }
}
```

#### 差分
二维差分：$𝐷(𝑖,𝑗) = 𝑎(𝑖,𝑗) − 𝑎(𝑖−1,𝑗) - 𝑎(𝑖,𝑗−1) + 𝑎(𝑖−1,𝑗−1)$ <br>
同逐维前缀和，也可逐维差分 <br>

三维差分
```cpp
D[x1][y1][z1]             += d;   // 前面：左下顶点，即区间的起始点
D[x2 + 1][y1][z1]         -= d;   // 前面：右下顶点的右边一个点
D[x1][y1][z2 + 1]         -= d;   // 前面：左上顶点的上面一个点
D[x2 + 1][y1][z2 + 1]     += d;   // 前面：右上顶点的斜右上方一个点
D[x1][y2 + 1][z1]         -= d;   // 后面：左下顶点的后面一个点
D[x2 + 1][y2 + 1][z1]     += d;   // 后面：右下顶点的斜右后方一个点
D[x1][y2 + 1][z2 + 1]     += d;   // 后面：左上顶点的斜后上方一个点
D[x2 + 1][y2 + 1][z2 + 1] -= d;   // 后面：右上顶点的斜右上后方一个点，即区间终点的后一个点
```

#### 树上差分
对结点 𝑥 和 𝑦 之间的路径上的所有点权都加 𝑣 <br>
```cpp
val[x] += v, val[y] += v, val[lca] -= v, val[fa[lca]] -= v
```
如果要对结点 𝑥 和 𝑦 之间的路径上的所有边权都加 𝑣
```cpp
val[x] += v, val[y] += v, val[lca] -= 2 * v
```
最后求子树和

### 摩尔投票
给定一个大小为 $n$ 的数组 $nums$ ，返回其中的多数元素。多数元素是指在数组中出现次数大于 $⌊n / 2⌋$ 的元素。如果我们把众数记为 $+1$，把其他数记为 $−1$，将它们全部加起来，显然和大于 $0$，从结果本身我们可以看出众数比其他数多。我们维护一个候选众数 $candidate$ 和它出现的次数 $count$。初始时 $candidate$ 可以为任意值，$count$ 为 $0$；遍历数组 $nums$ 中的所有元素，对于每个元素 $x$，在判断 $x$ 之前，如果 $count$ 的值为 $0$，我们先将 $x$ 的值赋予 $candidate$ 随后我们判断 $x$：如果 $x$ 与 $candidate$ 相等，那么计数器 $count$ 的值增加 $1$；如果 $x$ 与 $candidate$ 不等，那么计数器 $count$ 的值减少 $1$。在遍历完成后，检查一下 $candidate$ 即可。<br>

我们可以不失一般性的将其拓展为统计出现次数超过 $⌊n / k⌋$ 的数。可以证明，出现次数超过 $⌊n / k⌋$ 的数最多只有 $k - 1$ 个。当明确了符合要求的数的数量之后，我们可以使用有限变量来代表这 $k - 1$ 个候选数及其出现次数。然后使用摩尔投票的标准做法，在建立数组时同时 $check$ 这 $k - 1$ 个数，假设当前遍历到的元素为 $x$：如果 $x$ 本身是候选者的话，则对其出现次数加一；如果本身不是候选者，检查是否有候选者的出现次数为 $0$：若有，则让 $x$ 代替其成为候选者，并记录出现次数为 $1$；若无，则让所有候选者的出现次数减一。当处理完整个数组后，这 $k - 1$ 个数可能会被填满，但不一定都是符合出现次数超过要求的。需要进行二次遍历，来确定候选者是否符合要求，将符合要求的数加到答案。上述做法正确性的关键是：若存在出现次数超过 $⌊n / k⌋$ 的数，最后必然会成为这 $k - 1$ 个候选者之一。