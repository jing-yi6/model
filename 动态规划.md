## 动态规划

### 背包

#### 01 背包
$O(nm)$
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> w(n + 1), v(n + 1), f(m + 1, 0);
    for (int i = 1; i <= n; i++) cin >> w[i] >> v[i];
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= w[i]; j--) { 
            f[j] = max(f[j], f[j - w[i]] + v[i]);
        }
    }
    cout << f[m] << '\n';
}
```

#### 完全背包
$O(nm)$
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> w(n + 1), v(n + 1), f(m + 1, 0);
    for (int i = 1; i <= n; i++) cin >> w[i] >> v[i];
    for (int i = 1; i <= n; i++) {
        for (int j = w[i]; j <= m; j++) { 
            f[j] = max(f[j], f[j - w[i]] + v[i]);
        }
    }
    cout << f[m] << '\n';
}
```

#### 二进制优化多重背包
$O(nmlog(s))$
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> f(m + 1, 0);
    vector<array<int, 2>> a;
    for (int i = 1; i <= n; i++) {
        int v, w, num;
        cin >> v >> w >> num;
        int k = 1;
        while (k <= num) {
            a.push_back({v * k, w * k});
            num -= k;
            k *= 2;
        }
        if (num > 0) a.push_back({v * num, w * num});
    }
    for (auto &[v, w] : a) {
        for (int j = m; j >= w; j--) {
            f[j] = max(f[j], f[j - w] + v);
        }
    }
    cout << f[m];
}
```

#### 单调队列优化多重背包
$O(nm)$
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> dp(2, vector<int> (m + 1, 0));
    //deque<pair<int, int>> q;
    vector<pair<int, int>> q(m + 10);
    for (int i = 1; i <= n; i++) {
        int v, w, num;   // v 是价值 w 是花费
        cin >> v >> w >> num;
        for (int j = 0; j < w; j++) {  // 按模 w 余数分组
            //q.clear();
            int l = 0, r = -1;
            for (int k = j; k <= m; k += w) {
                //while (!q.empty() && q.front().second < k - num * w) q.pop_front();
                //while (!q.empty() && q.back().first + (k - q.back().second) / w * v <= dp[(i & 1) ^ 1][k]) q.pop_back();
                while (l <= r && q[l].second < k - num * w) l++;
                while (l <= r && q[r].first + (k - q[r].second) / w * v <= dp[(i & 1) ^ 1][k]) r--;
                //q.push_back({dp[(i & 1) ^ 1][k], k});
                //dp[i & 1][k] = q.front().first + (k - q.front().second) / w * v;
                q[++r] = {dp[(i & 1) ^ 1][k], k};
                dp[i & 1][k] = q[l].first + (k - q[l].second) / w * v;
            }
        }
    }
    cout << dp[n & 1][m];
}
```

#### 混合背包
$O(nm)$
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> dp(2, vector<int> (m + 1, 0));
    vector<pair<int, int>> q(m + 10);
    for (int i = 1; i <= n; i++) {
        int v, w, num;   // v 是价值 w 是花费
        cin >> w >> v >> num;
        if (num == -1) num = 1;
        else if (num == 0) num = m / w;
        for (int j = 0; j < w; j++) {  // 按模 w 余数分组
            int l = 0, r = -1;
            for (int k = j; k <= m; k += w) {
                while (l <= r && q[l].second < k - num * w) l++;
                while (l <= r && q[r].first + (k - q[r].second) / w * v <= dp[(i & 1) ^ 1][k]) r--;
                q[++r] = {dp[(i & 1) ^ 1][k], k};
                dp[i & 1][k] = q[l].first + (k - q[l].second) / w * v;
            }
        }
    }
    cout << dp[n & 1][m];
}
```

#### 背包求具体方案(字典序最小)
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> w(n + 1), v(n + 1);
    vector<vector<int>> f(n + 2, vector<int> (m + 1, 0));
    for (int i = 1; i <= n; i++) cin >> w[i] >> v[i];
    for (int i = n; i >= 1; i--) {                                   // 倒着处理方便正着输出
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i + 1][j];
            if (j >= w[i]) f[i][j] = max(f[i][j], f[i + 1][j - w[i]] + v[i]);
        }
    }
    int k = m;
    for (int i = 1; i <= n; i++) {
        if (k >= w[i] && f[i][k] == f[i + 1][k - w[i]] + v[i]) {    // 可以选就必选
            cout << i << ' ';
            k -= w[i];
        }
    }
}
```

#### 可撤销背包
只有背包中物品的顺序对答案没有影响时，才可撤销。 <br> 
先对所有元素求出 dp 数组。所以当我们准备删除第 i 个元素时, 此时的 dp 数组可以看作将 i 最后一个转移，且刚刚转移完, 显然刚转移完 i，则可以撤销转移。原来是倒序转移，现在反过来，正序撤销。两者顺序正好相反。 
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> w(n + 1), f(m + 1, 0);
    vector<vector<int>> ans(n + 1, vector<int> (m + 1));
    for (int i = 1; i <= n; i++) cin >> w[i];
    f[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= w[i]; j--) {
            f[j] = (f[j] + f[j - w[i]]) % 10;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = w[i]; j <= m; j++) f[j] = (f[j] - f[j - w[i]]) % 10; // 撤销当前物品
        for (int j = 1; j <= m; j++) ans[i][j] = (f[j] % 10 + 10) % 10;
        for (int j = m; j >= w[i]; j--) f[j] = (f[j] + f[j - w[i]]) % 10; // 添加当前物品
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) cout << ans[i][j];
        cout << '\n';
    }
}
```

### 数位DP

#### 区间数位和
```cpp
const int mod = 1e9 + 7;
i64 dp[20][200]; // 在前 pos 个位置，数位和为 sum 的情况下的总和
int a[20];
i64 dfs(int pos, bool limit, int sum) {
    if (!pos) return sum;
    if (!limit && ~dp[pos][sum]) return dp[pos][sum];
    int up = limit ? a[pos] : 9;
    i64 res = 0;
    for (int i = 0; i <= up; i++) res = (res + dfs(pos - 1, limit && i == up, sum + i)) % mod;
    if (!limit) dp[pos][sum] = res;
    return res;
}
i64 get(i64 x) {
    int len = 0;
    while (x) {
        a[++len] = x % 10;
        x /= 10;
    }
    return dfs(len, 1, 0);
}
void solve() {
    i64 l, r;
    cin >> l >> r;
    i64 ans = 0;
    ans = (ans + get(r)) % mod;
    ans = (ans - get(l - 1)) % mod;
    ans = (ans % mod + mod) % mod;
    cout << ans << '\n';
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    memset(dp, -1, sizeof(dp));
    int T = 1;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

#### 区间数位个数
```cpp
// dp[pos][cnt]：当最高位在 [pos + 1, len] 中 digit 填了 cnt 个，[1, pos] 任意填，digit 出现的次数
// 当 limit = false 时，容易知道填 1-9 的数量是相同的
i64 dp[20][20], ans[10]; 
int a[20];
int digit; // 当前要统计的数字
i64 dfs(int pos, bool limit, bool lead0, int cnt) {
    if (!pos) return cnt;
    if (!limit && ~dp[pos][cnt] && !lead0) return dp[pos][cnt];
    int up = limit ? a[pos] : 9;
    i64 res = 0;
    for (int i = 0; i <= up; i++) {
        int tmp = cnt + (i == digit);
        if (lead0 && digit == 0 && i == 0) tmp = 0;
        res += dfs(pos - 1, limit && i == up, lead0 && i == 0, tmp);
    }
    if (!limit && !lead0) dp[pos][cnt] = res;
    return res;
}
void get(i64 x, int type) {
    int len = 0;
    while (x) {
        a[++len] = x % 10;
        x /= 10;
    }
    for (int i = 0; i <= 9; i++) {
        digit = i;
        ans[i] += type * dfs(len, 1, 1, 0);
    }
}
void solve() {
    memset(dp, -1, sizeof(dp));
    i64 l, r;
    cin >> l >> r;
    get(r, 1);
    get(l - 1, -1);
    for (int i = 0; i <= 9; i++) cout << ans[i] << ' ';
}
```

#### 相邻数字有限制
不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数<br>
统计区间 windy 数个数
```cpp
// dp[pos][last]：还剩 pos 个位置没填，并以 last 开头的 windy 数的数量
i64 dp[20][10]; 
int a[20];
i64 dfs(int pos, bool limit, bool lead0, int last) {
    if (!pos) return 1;
    if (!limit && last >= 0 && last <= 9 && ~dp[pos][last]) return dp[pos][last];
    int up = limit ? a[pos] : 9;
    i64 res = 0;
    for (int i = 0; i <= up; i++) {
        if (lead0) res += dfs(pos - 1, limit && i == up, lead0 && i == 0, i == 0 ? last : i);
        else if (abs(last - i) >= 2) res += dfs(pos - 1, limit && i == up, lead0 && i == 0, i);
    }
    if (!limit && last >= 0 && last <= 9) dp[pos][last] = res;
    return res;
}
i64 get(i64 x) {
    int len = 0;
    while (x) {
        a[++len] = x % 10;
        x /= 10;
    }
    return dfs(len, 1, 1, -5);
}
void solve() {
    memset(dp, -1, sizeof(dp));
    i64 l, r;
    cin >> l >> r;
    i64 ans = 0;
    ans += get(r);
    ans -= get(l - 1);
    cout << ans << '\n';
}
```

### 子序列DP

#### 最长上升子序列
```cpp
// 贪心 + 二分 存路径相同下的最小值
void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1), q(n + 1);
    q[1] = -2e9;
    int len = 0;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        int l = 0, r = len;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
    }
    cout << len;
}
```

#### 最长公共上升子序列
```cpp
void solve() {
    int n;
    cin >> n;
    // f[i][j] 所有由第一个序列的前 i 个字母，和第二个序列的前 j 个字母构成的，
    // 且以 b[j] 结尾的公共上升子序列中长度的最大值
    vector<vector<int>> f(n + 1, vector<int> (n + 1, 0));
    vector<int> a(n + 1, 0), b(n + 1, 0);
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n; i++) {
        // maxv：当外层固定了 i 并从左到右扫 j 时
        // 维护所有 j' < j 且 b[j'] < a[i] 的 f[i - 1][j'] 的最大值
        int maxv = 0;
        for (int j = 1; j <= n; j++) {
            f[i][j] = f[i - 1][j]; // 不包含 a[i]
            if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv + 1); 
            if (a[i] > b[j]) maxv = max(maxv, f[i - 1][j]);
        }
    }
    int res = 0;
    for (int i = 1; i <= n; i++) res = max(f[n][i], res);
    cout << res;
}
```

### SOSDP
```cpp
for (int i = 0; i < n; i++) {
    for (int st = 0; st < (1 << n); st++) {
        if (st >> i & 1) {
            // dp[st] = max(dp[st], dp[st ^ (1 << i)]); 集合值为所有子集的最大值
            // dp[st] += dp[st ^ (1 << i)]; 集合值为所有子集和
        }
    }
}
```

### 换根DP

#### 每个点为根的深度和
```cpp
void solve() {
    int n;
    cin >> n;
    vector<vector<int>> adj(n + 1);
    vector<int> sz(n + 1, 1);
    vector<i64> ans(n + 1, 0);
    i64 mx = 0;
    for (int i = 1; i <= n - 1; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    auto dfs1 = [&](auto &&dfs1, int u, int fa) -> void {
        for (auto &v : adj[u]) {
            if (v == fa) continue;
            dfs1(dfs1, v, u);
            sz[u] += sz[v];
            ans[u] += ans[v] + sz[v];
        }
    };
    auto dfs2 = [&](auto &&dfs2, int u, int fa) -> void {
        for (auto &v : adj[u]) {
            if (v == fa) continue;
            ans[v] = ans[u] - sz[v] + n - sz[v]; 
            dfs2(dfs2, v, u);
        }
        mx = max(mx, ans[u]);
    };
    dfs1(dfs1, 1, 0);
    dfs2(dfs2, 1, 0);
    for (int i = 1; i <= n; i++) {
        if (ans[i] == mx) {
            cout << i;
            break;
        }
    }
}
```

#### 距离每个点不超过 k 的点权和
```cpp
void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> val(n + 1);
    vector<vector<int>> adj(n + 1);
    // dp0 向下 dp1 向上和向下
    vector<vector<i64>> dp0(n + 1, vector<i64> (k + 1, 0)), dp1(n + 1, vector<i64> (k + 1, 0));
    for (int i = 1; i <= n - 1; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].emplace_back(b);
        adj[b].emplace_back(a);
    } 
    for (int i = 1; i <= n; i++) cin >> val[i];
    auto dfs1 = [&](auto &&dfs1, int u, int fa) -> void {
        for (int i = 0; i <= k; i++) dp0[u][i] = val[u];
        for (auto &v : adj[u]) {
            if (v == fa) continue;
            dfs1(dfs1, v, u);
            for (int i = 1; i <= k; i++) dp0[u][i] += dp0[v][i - 1];
        }
    };
    auto dfs2 = [&](auto &&dfs2, int u, int fa) -> void {
        for (auto &v : adj[u]) {
            if (v == fa) continue;
            for (int i = 1; i <= k; i++) {
                dp1[v][i] += dp1[u][i - 1];
                if (i >= 2) dp1[v][i] -= dp0[v][i - 2];
            }
            dfs2(dfs2, v, u);
        }
    };
    dfs1(dfs1, 1, 0);
    dp1 = dp0;
    dfs2(dfs2, 1, 0);
    for (int i = 1; i <= n; i++) cout << dp1[i][k] << '\n';
}
```

### 轮廓线DP
种地，四联通相邻的地方只能种一个，且存在不能种的土壤
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> mp(n, vector<int> (m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> mp[i][j];
        }
    } 
    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (m + 1, vector<int> (1 << m, -1)));
    auto set = [&](int s, int pos, int type) -> int {
        if (!type && s >> pos & 1) s -= 1 << pos;
        else if (type && !(s >> pos & 1)) s += 1 << pos;
        return s;
    };
    auto get = [&](auto &&get, int i, int j, int s) -> int {
        if (i == n) return 1;
        if (j == m) return dp[i][j][s] = get(get, i + 1, 0, s);
        if (dp[i][j][s] != -1) return dp[i][j][s];
        int ans = get(get, i, j + 1, set(s, j, 0));
        if (mp[i][j] && (j == 0 || !(s >> (j - 1) & 1)) && !(s >> j & 1)) 
            ans = (ans + get(get, i, j + 1, set(s, j, 1))) % mod;
        return dp[i][j][s] = ans;
    };
    cout << get(get, 0, 0, 0) << '\n';
}
```