## 计算几何

### 基础知识
能用整数就不要使用浮点 <br>
求交点要尽量先判断（可行性），再求交 <br>
算极角 atan2l(y, x) <br>
皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式该公式可以表示为: <br>
S = a + b / 2 - 1 <br>
其中 a 表示多边形内部的格点数，b 表示多边形边界上的点数，S 表示多边形的面积。 <br>
海伦公式 p = (a + b + c) / 2; <br>
S = sqrtl(p(p - a) * (p - b) * (p - c)); <br>
三角形四心 <br>
(1) 外心，外接圆圆心 <br>
三边中垂线交点。到三角形三个顶点的距离相等 <br>
(2) 内心，内切圆圆心 <br>
角平分线交点，到三边距离相等 <br>
(3) 垂心 <br>
三条垂线交点 <br>
(4) 重心 <br>
三条中线交点（到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点）<br>

#### 浮点比较
```cpp
const long double eps = 1e-8, PI = acosl(-1);
int sign(long double x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
int cmp(long double x, long double y) { // 比较函数
    if (abs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}
```

#### 常见结构封装
```cpp
struct Point {
    long double x, y;
    int id = -1;
    Point(long double x = 0, long double y = 0) : x(x), y(y) {}
    bool operator ==(const Point &b) const {
        return abs(x - b.x) <= eps && abs(y - b.y) <= eps;
    }
    bool operator <(const Point &b) const {
        if (abs(x - b.x) <= eps) return y < b.y - eps; 
        return x < b.x - eps;
    }
    bool operator >(const Point &b) const {
        return !(*this < b || *this == b);
    }
    Point operator +(const Point &b) const {
        return Point(x + b.x, y + b.y);
    }
    Point operator -(const Point &b) const {
        return Point(x - b.x, y - b.y);
    }
    Point operator -() const { return {-x, -y}; }
    Point operator *(const long double &t) const {
        return {x * t, y * t};
    }
    Point operator /(const long double &t) const {
        return {x / t, y / t};
    } 
    long double operator *(const Point &b) const {
        return x * b.x + y * b.y;
    }
    // 叉积 向量 A 与 B 张成的平行四边形的有向面积
    // P ^ Q > 0, P 在 Q 的顺时针方向；< 0，P 在 Q 的逆时针方向；= 0，P，Q 共线，可能同向或反向
    long double operator ^(const Point &b) const {
        return x * b.y - b.x * y;
    }
    int toleft(const Point &b) const {
        const auto t = (*this) ^ b; 
        return (t > eps) - (t < -eps);
    }  
    // 浮点数
    long double len() const { // 向量长度
        return sqrtl(x * x + y * y);
    }  
    long double dis(const Point &a) const { // 两点距离
        return sqrtl((a.x - x) * (a.x - x) + (a.y - y) * (a.y - y));
    }  
    long double ang(const Point &a) const { // 向量夹角
        return abs(atan2l((*this) ^ a, (*this) * a));
        // return acosl(max(-1.0l, min(1.0l, ((*this) * a) / (len() * a.len()))));
    }  
    Point rot(const long double rad) const {  // 逆时针旋转（给定角度）
        return {x * cosl(rad) - y * sinl(rad), x * sinl(rad) + y * cosl(rad)};
    } 
    Point rot(const long double cosr, const long double sinr) const { // 逆时针旋转（给定角度的正弦与余弦）
        return {x * cosr - y * sinr, x * sinr + y * cosr};
    }  
};
// 极角排序
struct argcmp {
    bool operator()(const Point &a, const Point &b) const {
        const auto quad = [](const Point &a) {
            if (a.y < -eps) return 1;
            if (a.y > eps) return 4;
            if (a.x < -eps) return 5;
            if (a.x > eps) return 3;
            return 2;
        };
        const int qa = quad(a), qb = quad(b);
        if (qa != qb) return qa < qb;
        const auto t = a ^ b;
        if (abs(t) <= eps) return a * a < b * b - eps;  // 不同长度的向量需要分开
        return t > eps;
    }
};
struct Line {
    Point p, v;
    bool operator ==(const Line &b) const {
        return v.toleft(b.v) == 0 && v.toleft(p - b.p) == 0;
    }
    int toleft(const Point &b) const {
        return v.toleft(b - p);
    }  
    bool operator <(const Line &b) const { // 半平面交算法定义的排序
        if (abs(v ^ b.v) <= eps && v * b.v >= -eps) return toleft(b.p) == -1;
        return argcmp()(v, b.v);
    }
    // 浮点数
    Point inter(const Line &a) const { // 直线交点
        return p + v * ((a.v ^ (p - a.p)) / (v ^ a.v));
    }  
    long double dis(const Point &a) const { // 点到直线距离
        return abs(v ^ (a - p)) / v.len();
    }  
    Point proj(const Point &a) const { // 点在直线上的投影
        return p + v * ((v * (a - p)) / (v * v));
    }  
};
struct Segment {
    Point a, b;
    bool operator<(const Segment &s) const {return make_pair(a, b) < make_pair(s.a, s.b);}
    // 判定性函数建议在整数域使用
    // 判断点是否在线段上
    // -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
    int is_on(const Point &p) const {
        if (p == a || p == b) return -1;
        return (p - a).toleft(p - b) == 0 && (p - a) * (p - b) < -eps;
    }
    // 判断线段直线是否相交
    // -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int is_inter(const Line &l) const {
        if (l.toleft(a) == 0 || l.toleft(b) == 0) return -1;
        return l.toleft(a) != l.toleft(b);
    }
    // 判断两线段是否相交
    // -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int is_inter(const Segment &s) const {
        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;
        const Line l{a, b - a}, ls{s.a, s.b - s.a};
        return l.toleft(s.a) * l.toleft(s.b) == -1 && ls.toleft(a) * ls.toleft(b) == -1;
    }
    // 点到线段距离
    long double dis(const Point &p) const {
        if ((p - a) * (b - a) < -eps || (p - b) * (a - b) < -eps) return min(p.dis(a), p.dis(b));
        const Line l{a, b - a};
        return l.dis(p);
    }
    // 两线段间距离
    long double dis(const Segment &s) const {
        if (is_inter(s)) return 0;
        return min({dis(s.a), dis(s.b), s.dis(a), s.dis(b)});
    }
};
struct Circle {
    Point c;
    long double r;
    bool operator ==(const Circle &a) const {
        return c == a.c && abs(r - a.r) <= eps;
    }
    long double circ() const {return 2 * PI * r;}  // 周长
    long double area() const {return PI * r * r;}  // 面积
    // 点与圆的关系
    // -1 圆上 | 0 圆外 | 1 圆内
    int is_in(const Point &p) const {
        const long double d = p.dis(c); 
        return abs(d - r) <= eps ? -1 : d < r - eps;
    }
    // 直线与圆关系
    // 0 相离 | 1 相切 | 2 相交
    int relation(const Line &l) const {
        const long double d = l.dis(c);
        if (d > r + eps) return 0;
        if (abs(d - r) <= eps) return 1;
        return 2;
    }
    // 圆与圆关系
    // -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
    int relation(const Circle &a) const {
        if (*this == a) return -1;
        const long double d = c.dis(a.c);
        if (d > r + a.r + eps) return 0;
        if (abs(d - r - a.r) <= eps) return 1;
        if (abs(d - abs(r - a.r)) <= eps) return 3;
        if (d < abs(r - a.r) - eps) return 4;
        return 2;
    }
    // 直线与圆的交点
    vector<Point> inter(const Line &l) const {
        const long double d = l.dis(c);
        const Point p = l.proj(c);
        const int t = relation(l);
        if (t == 0) return vector<Point>();
        if (t == 1) return vector<Point>{p};
        const long double k = sqrtl(r * r - d * d);
        return vector<Point>{p - (l.v / l.v.len()) * k, p + (l.v / l.v.len()) * k};
    }
    // 圆与圆交点
    vector<Point> inter(const Circle &a) const {
        const long double d = c.dis(a.c);
        const int t = relation(a);
        if (t == -1 || t == 0 || t == 4) return vector<Point>();
        Point e = a.c - c; e = e / e.len() * r;
        if (t == 1 || t == 3) {
            if (r * r + d * d - a.r * a.r >= -eps) return vector<Point>{c + e};
            return vector<Point>{c - e};
        }
        const long double costh = (r * r + d * d - a.r * a.r) / (2 * r * d), sinth = sqrtl(1 - costh * costh);
        return vector<Point>{c + e.rot(costh, -sinth), c + e.rot(costh, sinth)};
    }
    // 圆与圆交面积
    long double inter_area(const Circle &a) const {
        const long double d = c.dis(a.c);
        const int t = relation(a);
        if (t == -1) return area();
        if (t < 2) return 0;
        if (t > 2) return min(area(), a.area());
        const long double costh1 = (r * r + d * d - a.r * a.r) / (2 * r * d), costh2 = (a.r * a.r + d * d - r * r) / (2 * a.r * d);
        const long double sinth1 = sqrtl(1 - costh1 * costh1), sinth2 = sqrtl(1 - costh2 * costh2);
        const long double th1 = acosl(costh1), th2 = acosl(costh2);
        return r * r * (th1 - costh1 * sinth1) + a.r * a.r * (th2 - costh2 * sinth2);
    }
    // 过圆外一点圆的切线
    vector<Line> tangent(const Point &a) const {
        const int t = is_in(a);
        if (t == 1) return vector<Line>();
        if (t == -1) {
            const Point v = {-(a - c).y, (a - c).x};
            return vector<Line>{{a, v}};
        }
        Point e = a - c; e = e / e.len() * r;
        const long double costh = r / c.dis(a), sinth = sqrtl(1 - costh * costh);
        const Point t1 = c + e.rot(costh, -sinth), t2 = c + e.rot(costh, sinth);
        return vector<Line>{{a, t1 - a}, {a, t2 - a}};
    }
    // 两圆的公切线
    vector<Line> tangent(const Circle &a) const {
        const int t = relation(a);
        vector<Line> lines;
        if (t == -1 || t == 4) return lines;
        if (t == 1 || t == 3) {
            const Point p = inter(a)[0], v = {-(a.c - c).y, (a.c - c).x};
            lines.push_back({p, v});
        }
        const long double d = c.dis(a.c);
        const Point e = (a.c - c) / (a.c - c).len();
        if (t <= 2) {
            const long double costh = (r - a.r) / d, sinth = sqrtl(1 - costh * costh);
            const Point d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);
            const Point u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c + d1 * a.r, v2 = a.c + d2 * a.r;
            lines.push_back({u1, v1 - u1}); lines.push_back({u2, v2 - u2});
        }
        if (t == 0) {
            const long double costh = (r + a.r) / d, sinth = sqrtl(1 - costh * costh);
            const Point d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);
            const Point u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c - d1 * a.r, v2 = a.c - d2 * a.r;
            lines.push_back({u1, v1 - u1}); lines.push_back({u2, v2 - u2});
        }
        return lines;
    }
    // 圆外的点的反演点在圆内，反之亦然；圆上的点的反演点为其自身。
    // 不过圆心 O 的圆其反演图形也是不过圆心 O 的圆
    // 过点 O 的圆，其反演图形是不过点 O 的直线
    // 两个图形相切且存在不为点 O 的切点，则他们的反演图形也相切。
    // 圆的反演
    tuple<int, Circle, Line> inverse(const Line &l) const {
        const Circle null_c = {{0.0, 0.0}, 0.0};
        const Line null_l = {{0.0, 0.0}, {0.0, 0.0}};
        if (l.toleft(c) == 0) return {2, null_c, l};
        const Point v = l.toleft(c) == 1 ? Point{l.v.y, -l.v.x} : Point{-l.v.y, l.v.x};
        const long double d = r * r / l.dis(c);
        const Point p = c + v / v.len() * d;
        return {1, {(c + p) / 2, d / 2}, null_l};
    } 
    tuple<int, Circle, Line> inverse(const Circle &a) const {
        const Circle null_c = {{0.0, 0.0}, 0.0};
        const Line null_l = {{0.0, 0.0}, {0.0, 0.0}};
        const Point v = a.c - c;
        if (a.is_in(c) == -1) {
            const long double d = r * r / (a.r + a.r);
            const Point p = c + v / v.len() * d;
            return {2, null_c, {p, {-v.y, v.x}}};
        }
        if (c == a.c) return {1, {c, r * r / a.r}, null_l};
        const long double d1 = r * r / (c.dis(a.c) - a.r), d2 = r * r / (c.dis(a.c) + a.r);
        const Point p = c + v / v.len() * d1, q = c + v / v.len() * d2;
        return {1, {(p + q) / 2, p.dis(q) / 2}, null_l};
    }
};
```

#### 常见函数
计算向量模长
```cpp
long double get_length(Point a) {
    return sqrtl(a * a);
}
```

计算向量夹角 <br>
atan2l 返回的是一个有符号的角度 [-π, π]。 <br>
acosl 返回的是无符号角度 [0, π] <br>
```cpp
long double get_angle(Point a, Point b) {
    return atan2l(a ^ b, a * b);
}
// 同计算夹角，但是需要将输入限制在 [-1,1]
long double get_angle(Point a, Point b) {
    long double res = a * b / get_length(a) / get_length(b);
    res = min(1.0l, max(-1.0l, res));
    return acosl(res);
}
```

计算两向量 ab, ac 构成的平行四边形有向面积
```cpp
long double area(Point a, Point b, Point c) {
    return (b - a) ^ (c - a);
}
```

向量顺时针选转后的向量 如果能直接知道 cos 和 sin，那么最好不要算 angle
```cpp
Point rotate(Point a, long double angle) {
    return Point(a.x * cosl(angle) + a.y * sinl(angle), -a.x * sinl(angle) + a.y * cosl(angle));
}
```

两直线相交 v w 分别是直线的方向向量
```cpp
using Vector = Point;
Point get_line_intersection(Point p, Vector v, Point q, Vector w) { 
    Vector u = p - q;
    long double t = (w ^ u) / (v ^ w);
    return p + v * t;
}
```

点到直线的距离，a b 是直线两点
```cpp
long double distance_to_line(Point p, Point a, Point b) {
    Vector v1 = b - a, v2 = p - a;
    return abs((v1 ^ v2) / get_length(v1));
}
```

点到线段距离
```cpp
long double distance_to_segment(Point p, Point a, Point b) {
    if (a == b) return get_length(p - a);
    Vector v1 = b - a, v2 = p - a, v3 = p - b;
    if (sign(v1 * v2) < 0) return get_length(v2);
    if (sign(v1 * v3) > 0) return get_length(v3);
    return distance_to_line(p, a, b);
}
```

点在直线上的投影，a b 是直线两点
```cpp
Point get_line_projection(Point p, Point a, Point b) {
    Vector v = b - a;
    return a + v * ((v * (p - a)) / (v * v));
}
```

判断点是否在线段上
```cpp
bool on_segment(Point p, Point a, Point b) {
    return sign((p - a) ^ (p - b)) == 0 && sign((p - a) * (p - b)) <= 0;
}
```

判断两线段是否相交
```cpp
bool segment_intersection(Point a1, Point a2, Point b1, Point b2) {
    if (min(a1.x, a2.x) > max(b1.x, b2.x) ||
        min(b1.x, b2.x) > max(a1.x, a2.x) ||
        min(a1.y, a2.y) > max(b1.y, b2.y) ||
        min(b1.y, b2.y) > max(a1.y, a2.y)) return 0;
    long double c1 = (a2 - a1) ^ (b1 - a1), c2 = (a2 - a1) ^ (b2 - a1);
    long double c3 = (b2 - b1) ^ (a2 - b1), c4 = (b2 - b1) ^ (a1 - b1);
    return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0;
}
```

求任意多边形面积, 点从 0 到 n - 1
```cpp
long double polygon_area(Point p[], int n) {
    long double s = 0;
    for (int i = 1; i + 1 < n; i++) s += (p[i] - p[0]) ^ (p[i + 1] - p[i]);
    return s / 2;
}
```

极角排序 （直接在 sort 里比较时使用 atan2l 较慢，需预处理）
```cpp
vector<pair<Point, long double>> a(n);
for (int i = 0; i < n; i++) {
    cin >> a[i].first.x >> a[i].first.y;
    a[i].second = atan2l(a[i].first.y, a[i].first.x);
}
sort(a.begin(), a.end(), [&](pair<Point, long double> a, pair<Point, long double> b) {
    return a.second < b.second;
});
```

判断点P在多边形内
```cpp
bool InPolygon(Point P, vector<Point> &p) {
    bool flag = false;
    int n = p.size();
    Point P1, P2; // 多边形一条边的两个顶点
    for (int i = 0, j = n - 1; i < n; j = i++) {
        P1 = point[i];
        P2 = point[j];
        if (on_segment(P, P1, P2)) return true; // 点在多边形一条边上
        if ((sign(P1.y - P.y) > 0 != sign(P2.y - P.y) > 0) && sign(P.x - (P.y - P1.y) * (P1.x - P2.x) / (P1.y - P2.y) - P1.x) < 0) flag = !flag;
    }
    return flag;
}
```

已知正方形对角求剩余两点
```cpp
vector<Point> poly(4);
poly[0] = a, poly[2] = b;
poly[1] = {(a.x - a.y + b.x + b.y) / 2, (a.x + a.y - b.x + b.y) / 2};
poly[3] = {(a.x + a.y + b.x - b.y) / 2, (-a.x + a.y + b.x + b.y) / 2};
```

### 凸包
浮点数比较一定要带 sign <br>
凸包 只有一条直线时会退化，可通过 andrew 后的 size 来判断,如果 size 等于 1 说明是一个直线,也可通过上下凸包解决 <br>
认真考虑共线 <br>

#### 凸包
```cpp
int sign(long double x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
int cmp(long double x, long double y) {
    if (abs(x - y) < eps) return 0;
    else if (x < y) return -1;
    else return 1;
}
long double area(Point a, Point b, Point c) {
    return (b - a) ^ (c - a);
}
vector<Point> andrew(vector<Point> &q) { 
    int n = q.size(), top = 0;
    vector<int> stk(n + 1);
    vector<bool> used(n + 1, 0);
    sort(q.begin(), q.end(), [&](Point a, Point b) {
        if (cmp(a.x, b.x) == 0) return a.y < b.y;
        else return a.x < b.x;
    });
    for (int i = 0; i < n; i++) {
        while (top >= 2 && sign(area(q[stk[top - 2]], q[stk[top - 1]], q[i])) <= 0) {  // < 0 可以把共线的都算上
            if (sign(area(q[stk[top - 2]], q[stk[top - 1]], q[i])) < 0) used[stk[--top]] = 0;
            else top--;
        }
        stk[top++] = i;
        used[i] = 1;
    }
    used[0] = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (used[i]) continue;
        while (top >= 2 && sign(area(q[stk[top - 2]], q[stk[top - 1]], q[i])) <= 0) {
            if (sign(area(q[stk[top - 2]], q[stk[top - 1]], q[i])) < 0) used[stk[--top]] = 0;
            else top--;
        }
        stk[top++] = i;
        used[i] = 1;
    }
    top--; // 去掉最后一个点
    vector<Point> point;
    for (int i = 0; i < top; i++) point.push_back(q[stk[i]]);
    return point;
}
```

#### 上下凸包
```cpp
const long double eps = 1e-8;
long double area(Point a, Point b, Point c) {
    return (b - a) ^ (c - a);
}
int sign(long double x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
int cmp(long double x, long double y) {
    if (abs(x - y) < eps) return 0;
    else if (x < y) return -1;
    else return 1;
}
pair<vector<Point>, vector<Point>> andrew(vector<Point> &q) { 
    int n = q.size(), top1 = 0, top2 = 0;
    vector<int> stkup(n + 1), stkdown(n + 1);
    vector<bool> used(n + 1, 0);
    sort(q.begin(), q.end(), [&](Point a, Point b) {
        if (cmp(a.x, b.x) == 0) return a.y < b.y;
        else return a.x < b.x;
    });
    for (int i = 0; i < n; i++) {
        while (top1 >= 2 && sign(area(q[stkup[top1 - 1]], q[stkup[top1]], q[i])) >= 0) {
            if (sign(area(q[stkup[top1 - 1]], q[stkup[top1]], q[i])) > 0) used[stkup[top1--]] = 0;
            else top1--;
        }
        stkup[++top1] = i;
        used[i] = 1;
    }
    used[0] = 0, used[stkup[top1]] = 0;
    for (int i = 0; i < n; i++) {
        if (used[i]) continue;
        while (top2 >= 2 && sign(area(q[stkdown[top2 - 1]], q[stkdown[top2]], q[i])) <= 0) top2--;
        stkdown[++top2] = i;
    }
    vector<Point> res1, res2;
    for (int i = 1; i <= top1; i++) res1.push_back(q[stkup[i]]);
    for (int i = 1; i <= top2; i++) res2.push_back(q[stkdown[i]]);
    return {res1, res2};
}
```

#### 判断点是否在凸包内 
O(logn) 需保证给定点按逆时针给出，可先求凸包，凸包上的点已按逆时针
```cpp
const long double eps = 1e-8;
i64 area(Point a, Point b, Point c) {
    return (b - a) ^ (c - a);
}
int sign(i64 x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
bool on_segment(Point p, Point a, Point b) {
    return sign((p - a) ^ (p - b)) == 0 && sign((p - a) * (p - b)) <= 0;
}
// -1 是在边界，1 是在凸包内，0 是在凸包外 
int check(i64 x, i64 y, vector<Point> &p) {
    Point u = {x, y};
    if (p.size() == 1) {
        if (u.x == p[0].x && u.y == p[0].y) return -1;
        else return 0;
    }
    if (p.size() == 2) {
        if (on_segment(u, p[0], p[1])) return -1;
        else return 0;
    }
    if (u.x == p[0].x && u.y == p[0].y) return -1;
    if (area(p[0], p[1], u) < 0 || area(p[0], p.back(), u) > 0) return 0;
    auto toleft = [&](Point a, Point b) -> int {
        auto t = a ^ b;
        return (t > eps) - (t < -eps);
    };
    const auto cmp = [&](const Point &u, const Point &v) {return toleft(u - p[0], v - p[0]) == 1;};
    const size_t i = lower_bound(p.begin() + 1, p.end(), u, cmp) - p.begin();
    if (i == 1) {
        if (on_segment(u, p[0], p[i])) return -1;
        else return 0;
    } 
    if (i == p.size() - 1 && on_segment(u, p[0], p[i])) return -1;
    if (on_segment(u, p[i - 1], p[i])) return -1;
    return toleft(p[i] - p[i - 1], u - p[i - 1]) > 0;
}
```

#### 求平行于给定直线的凸多边形的切线
返回切点下标 复杂度 O(logn) 
```cpp
pair<size_t, size_t> tangent(const vector<Point>& p, const Line& a) {
    const size_t i = extreme(p, [&](const Point& u) { return a.v; });
    const size_t j = extreme(p, [&](const Point& u) { return -a.v; });
    return {i, j};
}
```

#### 判断直线与凸包是否相交
1代表相交 a b 是切点，st ed 是给定直线上两点
```cpp
bool check(Point a, Point b, Point st, Point ed) {
    return sign(((st - a) ^ (ed - a)) * ((st - b) ^ (ed - b))) <= 0;
}
```

#### 过凸多边形外一点求凸多边形的切线
返回切点下标 复杂度 O(logn) 必须保证点在多边形外
```cpp
pair<size_t, size_t> tangent(const vector<Point>& p, const Point& a) {
    const size_t i = extreme(p, [&](const Point& u) { return u - a; });
    const size_t j = extreme(p, [&](const Point& u) { return a - u; });
    return {i, j};
}
```

#### 闵可夫斯基和 判断凸包和凸包的关系
```cpp
struct Segment {
    Point a, b;
};
struct argcmp {
    bool operator()(const Point &a, const Point &b) const {
        const auto quad = [](const Point &a) {
            if (a.y < -eps) return 1;
            if (a.y > eps) return 4;
            if (a.x < -eps) return 5;
            if (a.x > eps) return 3;
            return 2;
        };
        const int qa = quad(a), qb = quad(b);
        if (qa != qb) return qa < qb;
        const auto t = a ^ b;
        if (abs(t) <= eps) return a * a < b * b - eps;  // 不同长度的向量需要分开
        return t > eps;
    }
};
vector<Point> operator +(const vector<Point> &a, const vector<Point> &b) {
    vector<Segment> e1(a.size()), e2(b.size()), edge(a.size() + b.size());
    vector<Point> res; res.reserve(a.size() + b.size());
    const auto cmp = [](const Segment &u, const Segment &v) {return argcmp()(u.b - u.a, v.b - v.a);};
    for (size_t i = 0; i < a.size(); i++) e1[i] = {a[i], a[(i + 1) % a.size()]};
    for (size_t i = 0; i < b.size(); i++) e2[i] = {b[i], b[(i + 1) % b.size()]};
    rotate(e1.begin(), min_element(e1.begin(), e1.end(), cmp), e1.end());
    rotate(e2.begin(), min_element(e2.begin(), e2.end(), cmp), e2.end());
    merge(e1.begin(), e1.end(), e2.begin(), e2.end(), edge.begin(), cmp);
    auto toleft = [&](Point a, Point b) -> int {
        auto t = a ^ b;
        return (t > eps) - (t < -eps);
    };
    const auto check = [&](const vector<Point> &res, const Point &u) {
        const auto back1 = res.back(), back2 = *prev(res.end(), 2);
        return toleft(back1 - back2, u - back1) == 0 && (back1 - back2) * (u - back1) >= -eps;
    };
    auto u = e1[0].a + e2[0].a;
    for (const auto &v : edge) {
        while (res.size() > 1 && check(res,u)) res.pop_back();
        res.push_back(u);
        u = u + v.b - v.a;
    }
    if (res.size() > 1 && check(res, res[0])) res.pop_back();
    return res;
}
```

#### 凸包新加 k 个点后新凸包的面积
```cpp
const int N = 2e5 + 10;
int n, m;
struct Point {
    i64 x, y;
    int id = -1;
    Point(i64 x = 0, i64 y = 0) : x(x), y(y) {}
    Point operator +(const Point &b) const {
        return Point(x + b.x, y + b.y);
    }
    Point operator -(const Point &b) const {
        return Point(x - b.x, y - b.y);
    }
    Point operator -() const { return {-x, -y}; }
    i64 operator *(const Point &b) const {
        return x * b.x + y * b.y;
    }
    // 叉积 向量 A 与 B 张成的平行四边形的有向面积
    // P ^ Q > 0, P 在 Q 的顺时针方向；< 0，P 在 Q 的逆时针方向；= 0，P，Q 共线，可能同向或反向
    i64 operator ^(const Point &b) const {
        return x * b.y - b.x * y;
    }
};
struct Line {
    Point p, v;
};
const long double eps = 1e-8;
i64 area(Point a, Point b, Point c) {
    return (b - a) ^ (c - a);
}
int sign(i64 x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
bool on_segment(Point p, Point a, Point b) {
    return sign((p - a) ^ (p - b)) == 0 && sign((p - a) * (p - b)) <= 0;
}
int check(i64 x, i64 y, vector<Point> &p) {
    Point u = {x, y};
    if (p.size() == 1) {
        if (u.x == p[0].x && u.y == p[0].y) return -1;
        else return 0;
    }
    if (p.size() == 2) {
        if (on_segment(u, p[0], p[1])) return -1;
        else return 0;
    }
    if (u.x == p[0].x && u.y == p[0].y) return -1;
    if (area(p[0], p[1], u) < 0 || area(p[0], p.back(), u) > 0) return 0;
    auto toleft = [&](Point a, Point b) -> int {
        auto t = a ^ b;
        return (t > eps) - (t < -eps);
    };
    const auto cmp = [&](const Point &u, const Point &v) {return toleft(u - p[0], v - p[0]) == 1;};
    const size_t i = lower_bound(p.begin() + 1, p.end(), u, cmp) - p.begin();
    if (i == 1) {
        if (on_segment(u, p[0], p[i])) return -1;
        else return 0;
    } 
    if (i == p.size() - 1 && on_segment(u, p[0], p[i])) return -1;
    if (on_segment(u, p[i - 1], p[i])) return -1;
    return toleft(p[i] - p[i - 1], u - p[i - 1]) > 0;
}
size_t extreme(const vector<Point>& p, const function<Point(const Point&)>& dir) {
    auto toleft = [&](Point a, Point b) -> int {
        auto t = a ^ b;
        return (t > eps) - (t < -eps);
    };
    int len = p.size();
    const auto check = [&](const size_t i) { return toleft(dir(p[i]), p[(i + 1) % len] - p[i]) >= 0; };
    const auto dir0 = dir(p[0]);
    const auto check0 = check(0);
    if (!check0 && check(len - 1)) return 0;
    const auto cmp = [&](const Point& v) {
        const size_t vi = &v - p.data();
        if (vi == 0) return 1;
        const auto checkv = check(vi);
        const auto t = toleft(dir0, v - p[0]);
        if (vi == 1 && checkv == check0 && t == 0) return 1;
        return checkv ^ (checkv == check0 && t <= 0);
    };
    return partition_point(p.begin(), p.end(), cmp) - p.begin();
}
pair<size_t, size_t> tangent(const vector<Point>& p, const Point& a) {
    const size_t i = extreme(p, [&](const Point& u) { return u - a; });
    const size_t j = extreme(p, [&](const Point& u) { return a - u; });
    return {i, j};
}
void solve() {
    cin >> n;
    vector<Point> q(n);
    for (int i = 0; i < n; i++) cin >> q[i].x >> q[i].y;
    auto point = andrew(q);
    i64 sum = 0;
    vector<i64> pre(point.size(), 0);
    for (int i = 0; i < point.size(); i++) {
        int la = i - 1;
        if (la == -1) la = point.size() - 1;
        sum += point[la] ^ point[i];
        pre[i] = sum;
    }
    // 求凸包内靠外的面积
    auto query_sum = [&](int l, int r) -> i64 {
        if (l <= r) return pre[r] - pre[l] + (point[r] ^ point[l]);
        return pre[point.size() - 1] - pre[l] + pre[r] + (point[r] ^ point[l]);
    };
    auto get_area = [&](vector<Point> &tmp) -> i64 {
        i64 res = 0;
        for (int i = 0; i < tmp.size(); i++) {
            int j = (i + 1) % tmp.size();
            if (tmp[i].id != -1 && tmp[j].id != -1) {
                res += query_sum(tmp[i].id, tmp[j].id);
            }
        }  
        return res;
    };
    cin >> m;
    for (int i = 1; i <= m; i++) {
        int k;
        cin >> k;
        vector<Point> tmp;
        for (int j = 0; j < k; j++) {
            i64 x, y;
            cin >> x >> y;
            if (check(x, y, point)) continue;
            auto res = tangent(point, {x, y}); // 求切线
            Point u = point[res.first], v = point[res.second];
            u.id = res.first, v.id = res.second;
            tmp.push_back({x, y}), tmp.push_back(u), tmp.push_back(v);
        }
        if (tmp.size() == 0) {
            cout << sum << '\n';
            continue;
        }
        auto p = andrew(tmp);
        i64 now = 0;
        for (int i = 0; i < p.size(); i++) {
            int ne = (i + 1) % p.size();
            now += p[i] ^ p[ne];
        }
        cout << now + get_area(p) << '\n';
    }
}
```

#### 动态凸包
动态加点，查询直线是否与凸包相交，查询点是否在凸包内, 若只查询点是否在凸包内，可以去掉 segment和 e 相关的部分
```cpp
struct Point {
    i64 x, y;
    int id = -1;
    Point(i64 x = 0, i64 y = 0) : x(x), y(y) {}
    Point operator +(const Point &b) const {
        return Point(x + b.x, y + b.y);
    }
    Point operator -(const Point &b) const {
        return Point(x - b.x, y - b.y);
    }
    Point operator -() const { return {-x, -y}; }
    i64 operator *(const Point &b) const {
        return x * b.x + y * b.y;
    }
    Point operator *(const i64 &t) const {
        return {x * t, y * t};
    } 
    Point operator /(const i64 &t) const {
        return {x / t, y / t};
    } 
    // 叉积 向量 A 与 B 张成的平行四边形的有向面积
    // P ^ Q > 0, P 在 Q 的顺时针方向；< 0，P 在 Q 的逆时针方向；= 0，P，Q 共线，可能同向或反向
    i64 operator ^(const Point &b) const {
        return x * b.y - b.x * y;
    }
};
const int N = 1e5 + 10;
const long double eps = 1e-8;
int sign(i64 x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
bool argcmp(const Point &a, const Point &b) {
    auto quad = [](const Point &a) {
        if (a.y < -eps) return 1;
        if (a.y > eps) return 4;
        if (a.x < -eps) return 5;
        if (a.x > eps) return 3;
        return 2;
    };
    const int qa = quad(a), qb = quad(b);
    if (qa != qb) return qa < qb;
    const auto t = a ^ b;
    if (abs(t) <= eps) return a * a < b * b - eps; 
    return t > eps;
}
struct Segment {
    Point a, b;
    Segment() = default;
    Segment(Point a, Point b): a(a), b(b) {}
    bool is_on(const Point &c) const {return sign((c - a) ^ (c - b)) == 0 && sign((c - a) * (c - b)) <= 0;}
};
struct Convex {
    set<Point, decltype(&argcmp)> p{&argcmp}; // 坐标扩大三倍，便于整数运算
    map<Point, decltype(p.begin()), decltype(&argcmp)> e{&argcmp};
    Point o = Point(0,0); // 凸包内一点
    inline auto nxt(decltype(p.begin()) it) const {it++; return it == p.end() ? p.begin() : it;}
    inline auto pre(decltype(p.begin()) it) const {if (it == p.begin()) it = p.end(); return --it;}
    bool is_in(const Point &a) const {
        if (p.size() <= 0) return false;
        auto it = p.lower_bound(a * 3 - o);
        if (it == p.end()) it = p.begin();
        return ((*it - *pre(it)) ^ ((a * 3 - o) - *pre(it))) >= -eps;
    }
    bool check(i64 a, i64 b, i64 c) {
        Point lv(b, -a);
        auto cal = [=](Point u) {u = (u + o) / 3; return a * u.x + b * u.y - c;};
        auto sgn = [](i64 x) {return (x > 0) - (x < 0);};
        if (p.size() == 1) {
            Point u = *p.begin();
            if (cal(u) == 0) return false;
            return true;
        }
        if (p.size() == 2) {
            Point u = *p.begin(), v = *p.rbegin();
            if (cal(u) == 0 || cal(v) == 0) return false;
            return sgn(cal(u)) == sgn(cal(v));
        }
        auto eit1 = e.lower_bound(lv), eit2 = e.lower_bound(-lv);
        if (eit1 == e.end()) eit1 = e.begin();
        if (eit2 == e.end()) eit2 = e.begin();
        auto it1 = eit1->second, it2 = eit2->second;
        if (cal(*it1) == 0 || cal(*it2) == 0) return false;
        return sgn(cal(*it1)) == sgn(cal(*it2));
    }
    void insert(Point a) {
        if (p.size() <= 1) {
            p.insert(a * 3);
            return;
        }
        if (p.size() == 2) {
            Point u = *p.begin(), v = *p.rbegin();
            if (Segment(u, v).is_on(a * 3)) return;
            if (Segment(u, a * 3).is_on(v)) {
                p.erase(v); p.insert(a * 3);
                return;
            }
            if (Segment(v, a * 3).is_on(u)) {
                p.erase(u); p.insert(a * 3);
                return;
            }
            o = (u + v + a * 3) / 3;
            p.clear();
            p.insert(u - o); p.insert(v - o); p.insert(a * 3 - o);
            for (auto it = p.begin(); it != p.end(); it++) {e[*nxt(it) - *it] = it;}
            return;
        }
        if (is_in(a)) return;
        a = a * 3 - o;
        auto _it = p.insert(a).first;
        e.erase(*nxt(_it) - *pre(_it));
        auto it = nxt(_it);
        while (p.size() > 3 && ((*it - a) ^ (*nxt(it) - *it)) <= eps) {
            e.erase(*nxt(it) - *it);
            p.erase(it); it = nxt(_it);
        }
        it = pre(_it);
        while (p.size() > 3 && ((*it - *pre(it)) ^ (a - *it)) <= eps) {
            e.erase(*it - *pre(it));
            p.erase(it); it = pre(_it);
        }
        e[*nxt(_it) - *_it] = _it; e[*_it - *pre(_it)] = pre(_it);
    }
};
void solve() {
    int n, q;
    cin >> n >> q;
    Convex c;
    for (int i = 1; i <= n; i++) {
        i64 x, y;
        cin >> x >> y;
        c.insert({x, y});
    }
    while (q--) {
        int op;
        cin >> op;
        if (op == 1) {
            i64 x, y;
            cin >> x >> y;
            c.insert({x, y});
        }
        else {
            i64 x, y, z;
            cin >> x >> y >> z;
            // ax + by == c
            if (c.check(x, y, z)) cout << "YES\n";
            else cout << "NO\n";
        } 
    }
}
```

### 旋转卡壳

#### 平面最远点对
凸包直径 特判直线
```cpp
const int N = 1e5 + 10;
const long double eps = 1e-8;
int sign(i64 x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
i64 area(Point a, Point b, Point c) {
    return (b - a) ^ (c - a);
}
i64 get_dist(Point a, Point b) {
    i64 dx = a.x - b.x;
    i64 dy = a.y - b.y;
    return dx * dx + dy * dy;
}
i64 rotating_calipers(vector<Point> &p) {
    int n = p.size();
    i64 res = 0;
    for (int i = 0, j = 2; i < n; i++) {
        auto d = p[i], e = p[(i + 1) % n];
        while (area(d, e, p[j]) < area(d, e, p[j + 1])) j = (j + 1) % n;
        res = max(res, max(get_dist(p[j], d), get_dist(p[j], e)));
    }
    return res;
}
void solve() {
    int n;
    cin >> n;
    vector<Point> q(n);
    for (int i = 0; i < n; i++) cin >> q[i].x >> q[i].y;
    auto p = andrew(q);
    if (p.size() == 1) {
        cout << get_dist(q[0], q[n - 1]) << '\n';
        return;
    }
    cout << rotating_calipers(p) << '\n';
}
```

#### 最小矩形覆盖
如果存在面积为 0 特判
```cpp
const int N = 5e4 + 10;
const long double eps = 1e-8, PI = acos(-1);
Point ans[4];
long double min_area = 1e18;
int sign(long double x) { // 符号函数
    if (abs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}
int dcmp(long double x, long double y) {
    if (abs(x - y) < eps) return 0;
    else if (x > y) return 1;
    else return -1;
}
long double area(Point a, Point b, Point c) {
    return (b - a) ^ (c - a);
}
long double get_length(Point a) {
    return sqrtl(a * a);
}
long double get_dist(Point a, Point b) {
    long double dx = a.x - b.x;
    long double dy = a.y - b.y;
    return sqrtl(dx * dx + dy * dy);
}
long double project(Point a, Point b, Point c) { //投影
    return (b - a) * (c - a) / get_length(b - a);
}
Point norm(Point a) { //单位向量
    return a / get_length(a);
}
Point rotate(Point a, long double angle) {
    return Point(a.x * cos(angle) + a.y * sin(angle), -a.x * sin(angle) + a.y * cos(angle));
}
void rotating_calipers(vector<Point> &p) {
    int n = p.size();
    for (int i = 0, a = 2, b = 1, c = 2; i < n; i++) {
        auto d = p[i], e = p[(i + 1) % n];
        while (dcmp(area(d, e, p[a]), area(d, e, p[(a + 1) % n])) <= 0) a = (a + 1) % n;
        while (dcmp(project(d, e, p[b]), project(d, e, p[(b + 1) % n])) <= 0) b = (b + 1) % n;
        if (!i) c = a;
        while (dcmp(project(d, e, p[c]), project(d, e, p[(c + 1) % n])) >= 0) c = (c + 1) % n;
        auto x = p[a], y = p[b], z = p[c];
        auto h = area(d, e, x) / get_length(e - d);
        auto w = (y - z) * (e - d) / get_length(e - d);
        if (h * w < min_area) {
            min_area = h * w;
            ans[0] = d + norm(e - d) * project(d, e, y);
            ans[3] = d + norm(e - d) * project(d, e, z);
            auto u = rotate(norm(e - d), -PI / 2);
            ans[1] = ans[0] + u * h;
            ans[2] = ans[3] + u * h;
        }
    }
}
void solve() {
    int n;
    cin >> n;
    vector<Point> q(n);
    for (int i = 0; i < n; i++) cin >> q[i].x >> q[i].y;
    auto p = andrew(q);
    rotating_calipers(p);
    int k = 0;
    for (int i = 1; i < 4; i++) {
        if (dcmp(ans[i].y, ans[k].y) < 0 || !dcmp(ans[i].y, ans[k].y) && dcmp(ans[i].x, ans[k].x) < 0) {
            k = i;
        }
    }
    cout << fixed << setprecision(5) << min_area << '\n';
    for (int i = 0; i < 4; i++, k++) {
        auto t1 = ans[k % 4].x, t2 = ans[k % 4].y;
        if (!sign(t1)) t1 = 0;
        if (!sign(t2)) t2 = 0;
        cout << fixed << setprecision(5) << t1 << ' ' << t2 << '\n';
    }
}
```

### 半平面交

#### 排序增量法，复杂度 O(nlogn)
输入与返回值都是用直线表示的半平面集合
```cpp
vector<Line> halfinter(vector<Line> l, const long double lim = 1e9) {
    const auto check = [](const Line &a, const Line &b, const Line &c) {
        return a.toleft(b.inter(c)) < 0;
    };
    // 无精度误差的方法，但注意取值范围会扩大到三次方
    /*const auto check = [](const Line &a, const Line &b, const Line &c) {
        const Point p = a.v * (b.v ^ c.v), q = b.p * (b.v ^ c.v) + b.v * (c.v ^ (b.p - c.p)) - a.p * (b.v ^ c.v);
        return p.toleft(q) < 0;
    };*/
    l.push_back({{-lim, 0}, {0, -1}}); l.push_back({{0, -lim}, {1, 0}});
    l.push_back({{lim, 0}, {0, 1}}); l.push_back({{0, lim}, {-1, 0}});
    sort(l.begin(), l.end());
    deque<Line> q;
    for (size_t i = 0; i < l.size(); i++) {
        if (i > 0 && l[i - 1].v.toleft(l[i].v) == 0 && l[i - 1].v * l[i].v > eps) continue;
        while (q.size() > 1 && check(l[i], q.back(), q[q.size() - 2])) q.pop_back();
        while (q.size() > 1 && check(l[i], q[0], q[1])) q.pop_front();
        if (!q.empty() && q.back().v.toleft(l[i].v) <= 0) return vector<Line>();
        q.push_back(l[i]);
    }
    while (q.size() > 1 && check(q[0], q.back(), q[q.size() - 2])) q.pop_back();
    while (q.size() > 1 && check(q.back(), q[0], q[1])) q.pop_front();
    return vector<Line>(q.begin(), q.end());
}
```

#### 凸多边形内的最大内切圆半径
二分半径，然后将凸多边形向内缩即可
```cpp
void solve() {
    int n;
    cin >> n;
    vector<Point> q(n);
    for (int i = 0; i < n; i++) cin >> q[i].x >> q[i].y;
    auto check = [&](long double r) -> bool {
        vector<Line> lines;
        for (size_t i = 0; i < n; i++) {
            Line l = {q[i], q[(i + 1) % n] - q[i]};
            const Point v{-l.v.y, l.v.x}; // 垂直方向
            const Point t = l.p + v / v.len() * r; // 平移后的点
            lines.push_back({t, l.v});
        }
        const auto halfs = halfinter(lines);
        return !halfs.empty();
    };
    long double l = 0, r = 20000;
    while (r - l > eps) {
        long double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }
    cout << fixed << setprecision(10) << l << '\n';
}
```

### 面积并

#### 多边形面积并
需保证每个多边形的点是逆时针的 <br>
轮廓积分，复杂度 O(n^2logn)，n 为边数 <br>
ans[i] 表示被至少覆盖了 i + 1 次的区域的面积
```cpp
vector<long double> area_union(const vector<vector<Point>> &polys) {
    const size_t siz = polys.size();
    vector<vector<pair<Point, Point>>> segs(siz);
    const auto check = [](const Point &u, const Segment &e) {
        return !((u < e.a && u < e.b) || (u > e.a && u > e.b));
    };
    auto cut_edge = [&](const Segment &e, const size_t i) {
        const Line le{e.a, e.b - e.a};
        vector<pair<Point, int>> evt;
        evt.push_back({e.a, 0}); evt.push_back({e.b, 0});
        for (size_t j = 0; j < polys.size(); j++) {
            if (i == j) continue;
            const auto &pj = polys[j];
            for (size_t k = 0; k < pj.size(); k++) {
                const Segment s = {pj[k], pj[(k + 1) % pj.size()]};
                if (le.toleft(s.a) == 0 && le.toleft(s.b) == 0) {
                    evt.push_back({s.a, 0});
                    evt.push_back({s.b, 0});
                }
                else if (s.is_inter(le)) {
                    const Line ls{s.a, s.b - s.a};
                    const Point u = le.inter(ls);
                    if (le.toleft(s.a) < 0 && le.toleft(s.b) >= 0) evt.push_back({u, -1});
                    else if (le.toleft(s.a) >= 0 && le.toleft(s.b) < 0) evt.push_back({u, 1});
                }
            }
        }
        sort(evt.begin(), evt.end());
        if (e.a > e.b) reverse(evt.begin(), evt.end());
        int sum = 0;
        for (size_t i = 0; i < evt.size(); i++) {
            sum += evt[i].second;
            const Point u = evt[i].first, v = evt[i + 1].first;
            if (!(u == v) && check(u, e) && check(v, e)) segs[sum].push_back({u, v});
            if (v == e.b) break;
        }
    };
    for (size_t i = 0; i < polys.size(); i++) {
        const auto &pi = polys[i];
        for (size_t k = 0; k < pi.size(); k++) {
            const Segment ei = {pi[k], pi[(k + 1) % pi.size()]};
            cut_edge(ei, i);
        }
    }
    vector<long double> ans(siz);
    for (size_t i = 0; i < siz; i++) {
        long double sum = 0;
        sort(segs[i].begin(), segs[i].end());
        int cnt = 0;
        for (size_t j = 0; j < segs[i].size(); j++) {
            if (j > 0 && segs[i][j] == segs[i][j - 1]) segs[i + (++cnt)].push_back(segs[i][j]);
            else cnt = 0, sum += segs[i][j].first ^ segs[i][j].second;
        }
        ans[i] = sum / 2;
    }
    return ans;
}
```

#### 矩形面积并 O(nlogn)
输入为 n 个矩形的左上角坐标和右下角坐标, 坐标为矩阵的系，非笛卡尔坐标系 <br>
如果是笛卡尔坐标系可以直接交换输入的 x 和 y
```cpp
int n;
struct Segment {
    long double x, y, yy;
    int k;
    bool operator< (const Segment &t) const {
        return x < t.x;
    }
} seg[N * 2];
struct Node {
    int l, r, cnt;
    long double len;
} tr[N * 8];
vector<long double> ys;
int find(long double x) {
    return lower_bound(ys.begin(), ys.end(), x) - ys.begin();
}
void puhsup(int u) {
    if (tr[u].cnt) tr[u].len = ys[tr[u].r + 1] - ys[tr[u].l];
    else if (tr[u].l != tr[u].r) tr[u].len = tr[u << 1].len + tr[u << 1 | 1].len;
    else if (tr[u].l == tr[u].r) tr[u].len = 0;
}
void build(int u, int l, int r) {
    tr[u] = {l, r, 0, 0};
    if (l != r) {
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    }
}
void modify(int u, int l, int r, int k) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].cnt += k;
        puhsup(u);
    }
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, k);
        if (r > mid) modify(u << 1 | 1, l, r, k);
        puhsup(u);
    }
}
void solve() {
    cin >> n;
    for (int i = 0, j = 0; i < n; i++) {
        long double x, y, xx, yy;
        cin >> x >> y >> xx >> yy;
        seg[j++] = {x, y, yy, 1};
        seg[j++] = {xx, y, yy, -1};
        ys.push_back(y), ys.push_back(yy);
    }
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    build(1, 0, ys.size() - 2);
    sort(seg, seg + n * 2);
    long double res = 0;
    for (int i = 0; i < n * 2; i++) {
        if (i > 0) res += tr[1].len * (seg[i].x - seg[i - 1].x);
        modify(1, find(seg[i].y), find(seg[i].yy) - 1, seg[i].k);
    }
    cout << fixed << setprecision(2);
    cout << res << '\n';
}
```

### 面积最大、最小三角形

#### 面积最大三角形
面积最大可以通过旋转卡壳做到 O(n^2)
```cpp
i64 get_mx(vector<Point> &p) { // p是凸包
    if (p.size() <= 2) return 0;
    int n = p.size();
    i64 ans = 0;
	for (int i = 0; i < n; i++) {
	    int j = (i + 1) % n;
	    int k = (j + 1) % n;
	    while (j != i && k != i) {
            ans = max(ans, abs((p[j] - p[i]) ^ (p[k] - p[i])));
            while (((p[i] - p[j]) ^ (p[(k + 1) % n] - p[k])) < 0) k = (k + 1) % n;
            j = (j + 1) % n;
        }
	}
	return ans;
}
```

#### 极角序扫描线，复杂度 O(n^2logn) 
记得重载等于号和小于号
```cpp
struct argcmp {
    bool operator()(const Point &a, const Point &b) const {
        const auto quad = [](const Point &a) {
            if (a.y < -eps) return 1;
            if (a.y > eps) return 4;
            if (a.x < -eps) return 5;
            if (a.x > eps) return 3;
            return 2;
        };
        const int qa = quad(a), qb = quad(b);
        if (qa != qb) return qa < qb;
        const auto t = a ^ b;
        if (abs(t) <= eps) return a * a < b * b - eps;  // 不同长度的向量需要分开
        return t > eps;
    }
};
pair<i64, i64> minmax_triangle(const vector<Point> &vec) {
    if (vec.size() <= 2) return {0, 0};
    vector<pair<int, int>> evt;
    evt.reserve(vec.size() * vec.size());
    i64 maxans = 0, minans = numeric_limits<i64>::max();
    for (size_t i = 0; i < vec.size(); i++) {
        for (size_t j = 0; j < vec.size(); j++) {
            if (i == j) continue;
            if (vec[i] == vec[j]) minans = 0;
            else evt.push_back({i, j});
        }
    }
    sort(evt.begin(), evt.end(), [&](const pair<int, int> &u, const pair<int, int> &v) {
        const Point du = vec[u.second] - vec[u.first], dv = vec[v.second] - vec[v.first];
        return argcmp()({du.y, -du.x}, {dv.y, -dv.x});
    });
    vector<size_t> vx(vec.size()), pos(vec.size());
    for (size_t i = 0; i < vec.size(); i++) vx[i] = i;
    sort(vx.begin(), vx.end(), [&](int x, int y) {return vec[x] < vec[y];});
    for (size_t i = 0; i < vx.size(); i++) pos[vx[i]] = i;
    for (auto [u, v] : evt) {
        const size_t i = pos[u], j = pos[v];
        const size_t l = min(i, j), r = max(i, j);
        const Point vecu = vec[u], vecv = vec[v];
        if (l > 0) minans = min(minans, abs((vec[vx[l - 1]] - vecu) ^ (vec[vx[l - 1]] - vecv)));
        if (r < vx.size() - 1) minans = min(minans, abs((vec[vx[r + 1]] - vecu) ^ (vec[vx[r + 1]] - vecv)));
        maxans = max({maxans, abs((vec[vx[0]] - vecu) ^ (vec[vx[0]] - vecv)), abs((vec[vx.back()] - vecu) ^ (vec[vx.back()] - vecv))});
        if (i < j) swap(vx[i], vx[j]), pos[u] = j, pos[v] = i;
    }
    return {minans, maxans};
}
```

### 判断多个线段是否存在交点
扫描线，复杂度 O(nlogn)
```cpp
bool segs_inter(const vector<Segment> &segs) {
    if (segs.empty()) return false;
    using seq_t = tuple<long double, int, Segment>;
    const auto seqcmp = [](const seq_t &u, const seq_t &v) {
        const auto [u0, u1, u2] = u;
        const auto [v0, v1, v2] = v;
        if (abs(u0 - v0) <= eps) return make_pair(u1, u2) < make_pair(v1, v2);
        return u0 < v0 - eps;
    };
    vector<seq_t> seq;
    for (auto seg : segs) {
        if (seg.a.x > seg.b.x + eps) swap(seg.a, seg.b);
        seq.push_back({seg.a.x, 0, seg});
        seq.push_back({seg.b.x, 1, seg});
    }
    sort(seq.begin(), seq.end(), seqcmp);
    long double x_now;
    auto cmp = [&](const Segment &u, const Segment &v) {
        if (abs(u.a.x - u.b.x) <= eps || abs(v.a.x - v.b.x) <= eps) return u.a.y < v.a.y - eps;
        return ((x_now - u.a.x) * (u.b.y - u.a.y) + u.a.y * (u.b.x - u.a.x)) * (v.b.x - v.a.x) < ((x_now - v.a.x) * (v.b.y - v.a.y) + v.a.y * (v.b.x - v.a.x)) * (u.b.x - u.a.x) - eps;
    };
    multiset<Segment, decltype(cmp)> s{cmp};
    for (const auto [x, o, seg] : seq) {
        x_now = x;
        const auto it = s.lower_bound(seg);
        if (o == 0) {
            if (it != s.end() && seg.is_inter(*it)) return true;
            if (it != s.begin() && seg.is_inter(*prev(it))) return true;
            s.insert(seg);
        }
        else {
            if (next(it) != s.end() && it != s.begin() && (*prev(it)).is_inter(*next(it))) return true;
            s.erase(it);
        }
    }
    return false;
}
```

### 平面最近点对
```cpp
i64 power2(i64 a) {
    return a * a;
}
i64 dist(pair<i64, i64> a, pair<i64, i64> b) {
    i64 dx = a.first - b.first;
    i64 dy = a.second - b.second;
    return power2(dx) + power2(dy);
}
pair<i64, i64> rev(pair<i64, i64> a) {
    return {a.second, a.first};
}
void solve() {
    int n;
    cin >> n;
    vector<pair<i64, i64>> p(n + 1);
    set<pair<i64, i64>> S;
    i64 D;
    for (int i = 0; i < n; i++) cin >> p[i].first >> p[i].second;
    D = dist(p[0], p[1]);
    sort(p.begin(), p.begin() + n);
    for (int tt = 0, hh = 0; tt < n; tt++) {
        pair<i64, i64> ver = rev(p[tt]);
        while (D && D <= power2((i64)(p[tt].first - p[hh].first))) S.erase(rev(p[hh++]));
        auto it = S.lower_bound(ver);
        for (auto i = it; i != S.end() && power2(i->first - ver.first) < D; i++) D = min(D, dist(ver, *i));
        if (it != S.begin()) {
            for (auto i = --it; power2(i->first - ver.first) < D; i--) {
                D = min(D, dist(ver, *i));
                if (i == S.begin()) break;
            }
        }
        S.insert(ver);
    }
    cout << D << '\n';
}
```

### 三维凸包
```cpp
const int N = 2200, M = 220, mod = 998244353, P = 110;
int n, m; // 点数，面数
bool g[N][N]; // 表示两点逆时针构成的面是否被照射到
const long double eps = 1e-13; 
long double rand_eps() {
    return ((long double)rand() / RAND_MAX - 0.5) * eps; 
}
struct Point {
    long double x, y, z;   
    void shake() { // 给每个点随机扰动，防止出现四点共面
        x += rand_eps(), y += rand_eps(), z += rand_eps();
    }
    Point operator- (Point t) {
        return {x - t.x, y - t.y, z - t.z};
    }
    long double operator& (Point t) { // 点积
        return x * t.x + y * t.y + z * t.z;
    }
    Point operator* (Point t) {
        return {y * t.z - t.y * z, z * t.x - x * t.z, x * t.y - y * t.x};
    }
    long double len() {
        return sqrtl(x * x + y * y + z * z);
    }
} q[N];
struct Plane {
    int v[3];
    Point norm() { // 法向量
        return (q[v[1]] - q[v[0]]) * (q[v[2]] - q[v[0]]);
    }
    long double area() {
        return norm().len() / 2;
    }
    bool above(Point a) {
        return ((a - q[v[0]]) & norm()) >= 0;
    }
} plane[N * 2], np[N * 2]; // np用来备份
void get_convex_3d() {
    plane[m++] = {0, 1, 2};
    plane[m++] = {2, 1, 0};
    for (int i = 3; i < n; i++) {
        int cnt = 0;
        for (int j = 0; j < m; j++) {
            bool t = plane[j].above(q[i]);
            if (!t) np[cnt++] = plane[j];
            for (int k = 0; k < 3; k++) g[plane[j].v[k]][plane[j].v[(k + 1) % 3]] = t;
        }
        for (int j = 0; j < m; j++) {
            for (int k = 0; k < 3; k++) {
                int a = plane[j].v[k], b = plane[j].v[(k + 1) % 3];
                if (g[a][b] && !g[b][a]) np[cnt++] = {a, b, i};
            }
        }
        m = cnt;
        for (int j = 0; j < m; j++) plane[j] = np[j];
    }
}
void solve() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> q[i].x >> q[i].y >> q[i].z;
        q[i].shake();
    }
    get_convex_3d();
    double res = 0;
    for (int i = 0; i < m; i++) res += plane[i].area();
    cout << fixed << setprecision(6) << res;
}
```

### 线段与多边形公共部分的长度
```cpp
bool inside(Point a, Point b, Point c) {
    long double A = (a - b) * (a - c);
    long double B = (a - b) ^ (a - c);
    if (abs(B) > eps) return 0;
    return A <= 0;
}
int intersect(Point a, Point b, Point c, Point d, Point &res) {
    if (abs((b - a) ^ (d - c)) < eps) {
		if (abs((b - c) ^ (a - c)) < eps) return -1;
		return 0;
    }
    long double chk1 = (b - a) ^ (c - a);
    long double chk2 = (b - a) ^ (d - a);
    if (chk1 > eps && chk2 > eps) return 0;
    if (chk1 < eps && chk2 < eps) return 0;
    long double s1 = (b - a) ^ (d - c), s2 = (b - c) ^ (a - c);
	long double s = s2 / s1;
	res = c + ((d - c) * s);
    return 1;
}
long double sto[N];
pair<long double, long double> V[N];
void solve() {
    int n, m;
    cin >> n >> m;
    vector<Point> p(n); 
    for (int i = 0; i < n; i++) cin >> p[i].x >> p[i].y;
    while (m--) {
        long double x, y, xx, yy;
        cin >> x >> y >> xx >> yy;
        Point a = {x, y}, b = {xx, yy};
        int cnt = 0, cv = 0;
		long double len = (b - a) * (b - a);
		for (int i = 0; i < n; i++) {
			Point tp;
			int chk = intersect(a, b, p[i], p[(i + 1) % n], tp);
			if (chk > 0) sto[cnt++] = ((tp - a) * (b - a)) / len; 
            else if (chk < 0) {
				long double x = ((p[i] - a) * (b - a)) / len;
				long double y = ((p[(i + 1) % n] - a) * (b - a)) / len;
				if (x > y) swap(x, y);
				V[cv++] = {x, y};
			}
		}
		sort(sto, sto + cnt);
		for (int i = 0; i + 1 < cnt; i += 2) V[cv++] = {sto[i], sto[i + 1]};
		sort(V, V + cv);
		long double rlt = 0, cur = -(1e18);
		len = sqrtl(len);
		for (int i = 0; i < cv; i++) {
			if (cur < V[i].first) cur = V[i].first;
			if (cur < V[i].second) rlt += V[i].second - cur, cur = V[i].second;
		}
        cout << fixed << setprecision(15) << rlt * len << '\n';
    }
}
```

### 圆

#### 三角形外接圆
```cpp
Circle CircumscribedCircle(int x1, int y1, int x2, int y2, int x3, int y3) { 
    const Point a = {1.0 * x1, 1.0 * y1}, b = {1.0 * x2, 1.0 * y2}, c = {1.0 * x3, 1.0 * y3};
    const Line l1 = {(a + b) / 2, {-(b - a).y, (b - a).x}}, l2 = {(b + c) / 2, {-(c - b).y, (c - b).x}};
    const Point o = l1.inter(l2);
    return Circle{o, o.dis(a)};
} 
```

#### 三角形内接圆
```cpp
Circle InscribedCircle(int x1, int y1, int x2, int y2, int x3, int y3) { 
    const Point a = {1.0 * x1, 1.0 * y1}, b = {1.0 * x2, 1.0 * y2}, c = {1.0 * x3, 1.0 * y3};
    const Point ab = (b - a) / (b - a).len(), ac = (c - a) / (c - a).len();
    const Line l1 = {a, (ab + ac) / 2};
    const Point ba = (a - b) / (a - b).len(), bc = (c - b) / (c - b).len();
    const Line l2 = {b, (ba + bc) / 2};
    const Point o = l1.inter(l2);
    return Circle{o, Line{a, b - a}.dis(o)};
} 
```

#### 通过一点作圆的切线 返回角度
```cpp
vector<long double> TangentLineThroughPoint(int xc, int yc, int r, int xp, int yp) { 
    const Circle c = {{1.0 * xc, 1.0 * yc}, 1.0 * r};
    const Point p = {1.0 * xp, 1.0 * yp};
    const auto tans = c.tangent(p);
    vector<long double> ans;
    for (const Line &line : tans) {
        long double th = atan2(line.v.y, line.v.x);
        if (th < -eps) th = PI - abs(th);
        ans.push_back(th / PI * 180);
    }
    sort(ans.begin(), ans.end());
    return ans;
}
```

#### 通过一点并切于一条直线的圆
x1, y1, x2, y2为直线两点 返回圆心
```cpp
vector<Point> CircleThroughAPointAndTangentToALineWithRadius(int xp, int yp, int x1, int y1, int x2, int y2, int r) {
    const Point p = {1.0 * xp, 1.0 * yp}, a = {1.0 * x1, 1.0 * y1}, b = {1.0 * x2, 1.0 * y2};
    const Circle c = {p, 1.0 * r};
    Point d = {-(b - a).y, (b - a).x}; d = d / d.len() * r;
    const Line l1 = {a + d, b - a}, l2 = {a - d, b - a};
    const auto t1 = c.inter(l1), t2 = c.inter(l2);
    auto ans = t1;
    ans.insert(ans.end(), t2.begin(), t2.end());
    sort(ans.begin(), ans.end());
    return ans;
}
```

#### 与两条直线相切的圆 返回圆心
```cpp
vector<Point> CircleTangentToTwoLinesWithRadius(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int r) {
    const Point a = {1.0 * x1, 1.0 * y1}, b = {1.0 * x2, 1.0 * y2}, c = {1.0 * x3, 1.0 * y3}, d = {1.0 * x4, 1.0 * y4};
    Point d1 = {-(b - a).y, (b - a).x}; d1 = d1 / d1.len() * r;
    Point d2 = {-(d - c).y, (d - c).x}; d2 = d2 / d2.len() * r;
    const Line l11 = {a + d1, b - a}, l12 = {a - d1, b - a}, l21 = {c + d2, d - c}, l22 = {c - d2, d - c};
    vector<Point> ans = {l11.inter(l21), l11.inter(l22), l12.inter(l21), l12.inter(l22)};
    sort(ans.begin(), ans.end());
    return ans;
}
```

#### 与两个不相交的圆外切的圆 返回圆心
```cpp
vector<Point> CircleTangentToTwoDisjointCirclesWithRadius(int x1, int y1, int r1, int x2, int y2, int r2, int r) {
    const Point a = {1.0 * x1, 1.0 * y1}, b = {1.0 * x2, 1.0 * y2};
    const Circle c = {a, 1.0 * (r1 + r)}, d = {b, 1.0 * (r2 + r)};
    auto ans = c.inter(d);
    sort(ans.begin(), ans.end());
    return ans;
}
```

#### 圆与多边形面积交 记得输出绝对值
```cpp
long double area_inter(const Circle &circ, const vector<Point> &poly) {
    const auto cal = [](const Circle &circ, const Point &a, const Point &b) {
        if ((a - circ.c).toleft(b - circ.c) == 0) return 0.0l;
        const auto ina = circ.is_in(a), inb = circ.is_in(b);
        const Line ab = {a, b - a};
        if (ina && inb) return ((a - circ.c) ^ (b - circ.c)) / 2;
        if (ina && !inb) {
            const auto t = circ.inter(ab);
            const Point p = t.size() == 1 ? t[0] : t[1];
            const long double ans = ((a - circ.c) ^ (p - circ.c)) / 2;
            const long double th = (p - circ.c).ang(b - circ.c);
            const long double d = circ.r * circ.r * th / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d;
            return ans - d;
        }
        if (!ina && inb) {
            const Point p = circ.inter(ab)[0];
            const long double ans = ((p - circ.c) ^ (b - circ.c)) / 2;
            const long double th = (a - circ.c).ang(p - circ.c);
            const long double d = circ.r * circ.r * th / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d;
            return ans - d;
        }
        const auto p = circ.inter(ab);
        if (p.size() == 2 && Segment{a, b}.dis(circ.c) <= circ.r + eps) {
            const long double ans = ((p[0] - circ.c) ^ (p[1] - circ.c)) / 2;
            const long double th1 = (a - circ.c).ang(p[0] - circ.c), th2 = (b - circ.c).ang(p[1] - circ.c);
            const long double d1 = circ.r * circ.r * th1 / 2, d2 = circ.r * circ.r * th2 / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d1 + d2;
            return ans - d1 - d2;
        }
        const long double th = (a - circ.c).ang(b - circ.c);
        if ((a - circ.c).toleft(b - circ.c) == 1) return circ.r * circ.r * th / 2;
        return -circ.r * circ.r * th / 2;
    };
    long double ans = 0;
    for (size_t i = 0; i < poly.size(); i++) {
        const Point a = poly[i], b = poly[(i + 1) % poly.size()];
        ans += cal(circ, a, b);
    }
    return ans;
}
```

#### 圆面积并 记得输出绝对值
轮廓积分，复杂度 O(n^2logn) <br>
ans[i] 表示被至少覆盖了 i + 1 次的区域的面积
```cpp
vector<long double> area_union(const vector<Circle> &circs) {
    const size_t siz = circs.size();
    using arc_t = tuple<Point, long double, long double, long double>;
    vector<vector<arc_t>> arcs(siz);
    const auto eq = [](const arc_t &u, const arc_t &v) {
        const auto [u1, u2, u3, u4] = u;
        const auto [v1, v2, v3, v4] = v;
        return u1 == v1 && abs(u2 - v2) <= eps && abs(u3 - v3) <= eps && abs(u4 - v4) <= eps;
    };
    auto cut_circ = [&](const Circle &ci, const size_t i) {
        vector<pair<long double, int>> evt;
        evt.push_back({-PI, 0}); evt.push_back({PI, 0});
        int init = 0;
        for (size_t j = 0; j < circs.size(); j++) {
            if (i == j) continue;
            const Circle &cj = circs[j];
            if (ci.r < cj.r - eps && ci.relation(cj) >= 3) init++;
            const auto inters = ci.inter(cj);
            if (inters.size() == 1) evt.push_back({atan2l((inters[0] - ci.c).y, (inters[0] - ci.c).x), 0});
            if (inters.size() == 2) {
                const Point dl = inters[0] - ci.c, dr = inters[1] - ci.c;
                long double argl = atan2l(dl.y, dl.x), argr = atan2l(dr.y, dr.x);
                if (abs(argl + PI) <= eps) argl = PI;
                if (abs(argr + PI) <= eps) argr = PI;
                if (argl > argr + eps) {
                    evt.push_back({argl, 1}); evt.push_back({PI, -1});
                    evt.push_back({-PI, 1}); evt.push_back({argr, -1});
                }
                else {
                    evt.push_back({argl, 1});
                    evt.push_back({argr, -1});
                }
            }
        }
        sort(evt.begin(), evt.end());
        int sum = init;
        for (size_t i = 0; i < evt.size(); i++) {
            sum += evt[i].second;
            if (abs(evt[i].first - evt[i + 1].first) > eps) arcs[sum].push_back({ci.c, ci.r, evt[i].first, evt[i + 1].first});
            if (abs(evt[i + 1].first - PI) <= eps) break;
        }
    };
    const auto oint = [](const arc_t &arc) {
        const auto [cc, cr, l, r] = arc;
        if (abs(r - l - PI - PI) <= eps) return 2.0l * PI * cr * cr;
        return cr * cr * (r - l) + cc.x * cr * (sinl(r) - sinl(l)) - cc.y * cr * (cosl(r) - cosl(l));
    };
    for (size_t i = 0; i < circs.size(); i++) {
        const auto &ci = circs[i];
        cut_circ(ci, i);
    }
    vector<long double> ans(siz);
    for (size_t i = 0; i < siz; i++) {
        long double sum = 0;
        sort(arcs[i].begin(), arcs[i].end());
        int cnt = 0;
        for (size_t j = 0; j < arcs[i].size(); j++) {
            if (j > 0 && eq(arcs[i][j], arcs[i][j - 1])) arcs[i + (++cnt)].push_back(arcs[i][j]);
            else cnt = 0, sum += oint(arcs[i][j]);
        }
        ans[i] = sum / 2;
    }
    return ans;
}
```

#### 最小圆覆盖
```cpp
Circle get_circle(Point a, Point b, Point c) { 
    const Line l1 = {(a + b) / 2, {-(b - a).y, (b - a).x}}, l2 = {(b + c) / 2, {-(c - b).y, (c - b).x}};
    const Point o = l1.inter(l2);
    return Circle{o, o.dis(a)};
} 
void solve() {
    int n;
    cin >> n;
    vector<Point> p(n);
    for (int i = 0; i < n; i++) cin >> p[i].x >> p[i].y;
    random_shuffle(p.begin(), p.end());
    Circle c;
    c.c = p[0], c.r = 0;
    for (int i = 1; i < n; i++) {
         if (cmp(c.r, c.c.dis(p[i])) < 0) {
            c.c = p[i], c.r = 0;
            for (int j = 0; j < i; j++) {
                if (cmp(c.r, c.c.dis(p[j])) < 0) {
                    c.c = (p[i] + p[j]) / 2, c.r = p[i].dis(p[j]) / 2;
                    for (int k = 0; k < j; k++) {
                        if (cmp(c.r, c.c.dis(p[k])) < 0) {
                            c = get_circle(p[i], p[j], p[k]);
                        }
                    }
                }
            }
         }
    }
    cout << fixed << setprecision(12) << c.r << '\n';
    cout << fixed << setprecision(12) << c.c.x << ' ' << c.c.y << '\n';
}
```

### 自适应辛普森积分
```cpp
const long double eps = 1e-12;
long double f(long double x) {
    
}
long double simpson(long double l, long double r) {
    long double mid = (l + r) / 2;
    return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
}
long double asr(long double l, long double r, long double s) {
    long double mid = (l + r) / 2;
    long double left = simpson(l, mid), right = simpson(mid, r);
    if (fabs(left + right - s) < eps) return left + right;
    else return asr(l, mid, left) + asr(mid, r, right);
}
// asr(l, r, simpson(l, r))
```