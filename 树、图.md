## 树、图

### 2-SAT
```cpp
int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, sz[N];
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void tarjan(int u) {
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u, in_stk[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }
    if (dfn[u] == low[u]) {
        ++scc_cnt;
        int y;
        do {
            y = stk[top--];
            in_stk[y] = 0;
            id[y] = scc_cnt;
            sz[scc_cnt]++;
        } while (y != u);
    }
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--) { // 2i + 0假命题，2i + 1真命题
        int i, a, j, b;
        cin >> i >> a >> j >> b;
        i--, j--;
        add(2 * i + !a, 2 * j + b);
        add(2 * j + !b, 2 * i + a);
    }
    for (int i = 0; i < 2 * n; i++) {
        if (!dfn[i]) {
            tarjan(i);
        }
    }
    for (int i = 0; i < n; i++) {
        if (id[2 * i] == id[2 * i + 1]) {
            cout << "IMPOSSIBLE" << '\n';
            return;
        }
    }
    cout << "POSSIBLE" << '\n';
    for (int i = 0; i < n; i++) {
        if (id[2 * i] < id[2 * i + 1]) cout << 0 << ' ';
        else cout << 1 << ' ';
    }
}
```

### 差分约束
求每个变量的最小值用最长路模型，求最大值用最短路模型 <br>
最长路模型出现正环无解，最短路模型出现负环无解 <br>
如果不存在一个点可以遍历所有边，就需要建一个超级源点 <br>
边权有正有负只能差分约束最坏 O(nm), 边权非负则可 tarjan 缩点后拓扑排序 O(n + m), 边权全大于 0 则可直接拓扑排序 

#### 最长路
建边 Xi >= Xj + c 从 j 到 i 连一条权值为 c 的边
```cpp
int n, m;
int dist[N], cnt[N], vis[N];
vector<array<int, 2>> adj[N];
bool spfa() {
    memset(dist, -0x3f, sizeof(dist));
    memset(cnt, 0, sizeof(cnt)); // 看情况
    memset(vis, 0, sizeof(vis)); // 看情况
    dist[0] = 0;
    stack<int> q; // 判断无解时用栈，一定有解的时候用队列
    q.push(0);
    vis[0] = 1;
    while (q.size()) {
        auto u = q.top();
        q.pop();
        vis[u] = 0;
        for (auto [v, w] : adj[u]) {
            if (dist[v] < dist[u] + w) {
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n + 1) return 1;
                dist[v] = dist[u] + w;
                if (!vis[v]) {
                    vis[v] = 1;
                    q.push(v);
                }
            }
        }
    }
    return 0;
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i <= n; i++) adj[i].clear();
    for (int i = 1; i <= m; i++) {
        int op;
        cin >> op;
        if (op == 1) {
            int a, b, c;
            cin >> a >> b >> c;
            adj[b].push_back({a, c});
        }
        else if (op == 2) {
            int a, b, c;
            cin >> a >> b >> c;
            adj[a].push_back({b, -c});
        }
        else {
            int a, b;
            cin >> a >> b;
            adj[a].push_back({b, 0});
            adj[b].push_back({a, 0});
        }
    }
    for (int i = 1; i <= n; i++) adj[0].push_back({i, 0});
    if (spfa()) cout << -1 << '\n';
    else {
        int ans = 0;
        for (int i = 1; i <= n; i++) ans += dist[i];
        cout << ans << '\n';
    }
}
```

#### 最短路
建边 Xi <= Xj + c 从 j 到 i 连一条权值为 c 的边
```cpp
bool spfa() {
    memset(dist, 0x3f, sizeof(dist));
    memset(cnt, 0, sizeof(cnt)); // 看情况
    memset(vis, 0, sizeof(vis)); // 看情况
    dist[0] = 0;
    stack<int> q; // 判断无解时用栈，一定有解的时候用队列
    q.push(0);
    vis[0] = 1;
    while (q.size()) {
        auto u = q.top();
        q.pop();
        vis[u] = 0;
        for (auto &[v, w] : adj[u]) {
            if (dist[v] > dist[u] + w) {
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n + 1) return 1;
                dist[v] = dist[u] + w;
                if (!vis[v]) {
                    vis[v] = 1;
                    q.push(v);
                }
            }
        }
    }
    return 0;
}
```

### 二分图
二分图中 ：最大匹配数 = 最小点覆盖 = 总点数 - 最大独立集 = 总点数 - 最小路径覆盖
最小路径覆盖是选最少的边覆盖所有点
最小点覆盖是选最少的点覆盖所有边
原图的最大独立集就是补图的最大团
针对 DAG：原图的最小路径可重复覆盖 = 传递闭包后新图的最小路径覆盖
动态判断是否是二分图可以用带权并查集
树的最大匹配数和最大独立集一样，从叶子开始贪心

#### 染色法判断二分图
```cpp
int n, m;
int h[N], e[M], ne[M], w[M], idx;
int color[N]; // 0 表示未染色，1 表示染白色， 2 表示染黑色
void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
bool dfs(int u, int c) {
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!color[j] ) {
            if (!dfs(j, 3-c)) return false;
        }
        else if (color[j] == c) return false;
    }
    return true;
}
bool check() {
    memset(color, 0, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i++) {
        if (!color[i]) {
            if (!dfs(i, 1)) {
                flag = false;
                break;
            }
        }
    }
    return flag;
}
```

#### 匈牙利算法求二分图最大匹配 O(nm)
```cpp
vector<int> adj[N]; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过
bool find(int x) {
    for (auto v : adj[x]) {
        if (!st[v]) {
            st[v] = true;
            if (match[v] == 0 || find(match[v])) {
                match[v] = x;
                return true;
            }
        }
    }
    return false;
}
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i++) {
    memset(st, false, sizeof(st));
    if (find(i)) res++;
}
```

#### Hall 定理
给定二分图 $G=(V,E)$，左右两侧为 $V_L, V_R$。对任意 $S\subseteq V_L$，定义邻居集
$$
N(S)=\bigcup_{v\in S} N(v)\ \subseteq\ V_R .
$$

设 $|V_L|\le |V_R|$。则存在大小为 $|V_L|$ 的匹配当且仅当
$$
\forall\, S\subseteq V_L,\quad |N(S)|\ge |S| .
$$

推论 1: k 正则二分图的完美匹配 <br>
若 G 为 k-正则 $(k\ge 1)$ 且 $\|V_L|=|V_R|$，G 必存在完美匹配

推论 2：最大匹配大小的表达式 <br>
记 $\nu(G)$ 为 G 的最大匹配大小，则
$$
\nu(G)
= |V_L|-\max_{S\subseteq V_L}\bigl(|S|-|N(S)|\bigr)
= \min_{S\subseteq V_L}\bigl(|V_L|-|S|+|N(S)|\bigr).
$$

广义 Hall 定理（同时覆盖给定子集）<br>
设 $X\subseteq V_L,\ Y\subseteq V_R$。若分别存在匹配 $M_X, M_Y$ 使
$$
X\subseteq V(M_X)\quad\text{且}\quad Y\subseteq V(M_Y),
$$
则存在匹配 $M$ 使
$$
X\cup Y \subseteq V(M).
$$
其中 $V(M)$ 表示被匹配到的顶点集合。

### 连通性问题

#### 有向图的强连通分量
有向图最少加 max（P，Q）条边成为强连通分量，P 和 Q 分别为缩点后入度为 0 的个数和出度为 0 的个数 <br>
缩点后 id 的顺序是拓扑排序的逆序
```cpp
struct SCC {
    int n, cnt, timestamp;
    vector<vector<int>> g;
    vector<int> dfn, low, stk, id, sz;
    vector<bool> in_stk;
    SCC(int _n) {
        n = _n;
        g.resize(n + 1), dfn.resize(n + 1, 0), low.resize(n + 1, 0);
        id.resize(n + 1, 0), sz.resize(n + 1, 0), in_stk.resize(n + 1, 0);
        cnt = timestamp = 0;
    }
    void addEdge(int x, int y) {
        g[x].push_back(y);
    }
    void tarjan(int u) {
        dfn[u] = low[u] = ++timestamp;
        stk.push_back(u), in_stk[u] = 1;
        for (auto &v : g[u]) {
            if (!dfn[v]) {
                tarjan(v);
                low[u] = min(low[u], low[v]);
            }
            else if (in_stk[v]) low[u] = min(low[u], dfn[v]);
        }
        if (dfn[u] == low[u]) {
            ++cnt;
            int y;
            do {
                y = stk.back();
                stk.pop_back();
                in_stk[y] = 0;
                id[y] = cnt;
                sz[cnt]++;
            } while (y != u);
        }
    }
    void work() {
        for (int i = 1; i <= n; i++) {
            if (!dfn[i]) {
                tarjan(i);
            }
        }
    }
};
void solve() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
    }
    vector<vector<int>> adj(scc.cnt + 1);
    unordered_set<i64> S;
    for (int i = 1; i <= n; i++) {
        for (auto &v : scc.g[i]) {
            i64 hashl = (i64)scc.id[i] * 1000000 + scc.id[v];
            if (scc.id[i] != scc.id[v] && !S.count(hashl)) {
                adj[scc.id[i]].push_back(scc.id[v]);
                S.insert(hashl);
            }
        }
    }
    // 注意 scc 可能不连通 最后是个若干 DAG
}
```

#### 最大半连通子图就是缩点后的最长链
```cpp
int n, m, P;
int h[N], e[M], ne[M], idx, hs[N];
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, sz[N];
int dout[N], din[N];
int f[N], g[N]; // f 是最长链长，g 是方案数
void add(int h[], int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void tarjan(int u) {
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u, in_stk[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
    }
    if (dfn[u] == low[u]) {
        ++scc_cnt;
        int y;
        do {
            y = stk[top--];
            in_stk[y] = 0;
            id[y] = scc_cnt;
            sz[scc_cnt]++;
        } while (y != u);
    }
}
void solve() {
    memset(h, -1, sizeof(h));
    memset(hs, -1, sizeof(hs));
    cin >> n >> m >> P;
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(h, a, b);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            tarjan(i);
        }
    }
    unordered_set<LL> S;
    for (int i = 1; i <= n; i++) {
        for (int j = h[i]; j != -1; j = ne[j]) {
            int k = e[j];
            int a = id[i], b = id[k];
            LL hashh = a * 1000000ll + b;
            if (a != b && !S.count(hashh)) {
                add(hs, a, b);
                S.insert(hashh);
            }
        }
    }
    for (int i = scc_cnt; i >= 1; i--) {
        if (!f[i]) {
            f[i] = sz[i];
            g[i] = 1;
        }
        for (int j = hs[i]; j != -1; j = ne[j]) {
            int k = e[j];
            if (f[k] < f[i] + sz[k]) {
                f[k] = f[i] + sz[k];
                g[k] = g[i];
            }
            else if (f[k] == f[i] + sz[k]) g[k] = (g[k] + g[i]) % P;
        }
    }
    int maxf = 0, sum = 0;
    for (int i = 1; i <= n; i++) {
        if (f[i] > maxf) {
            maxf = f[i];
            sum = g[i];
        }
        else if (f[i] == maxf) sum = (sum + g[i]) % P;
    }
    cout << maxf << '\n' << sum << '\n';
}
```

#### 边双连通分量
在一张连通的无向图中，对于两个点 u 和 v，如果无论删去哪条边（只能删去一条）都不能使它们不连通，我们就说 u 和 v 边双连通。<br>
无向图最少加 (cnt + 1) / 2 条边成为边双连通分量 cnt 为缩点后树上度数为 1 的点的个数
```cpp
int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], dcc_cnt;
int d[N]; // 缩点后的度数
bool is_bridge[M];
vector<int> point[N]; // 记录每个连通分量有哪些点
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void tarjan(int u, int from) {
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!dfn[j]) {
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if (dfn[u] < low[j]) is_bridge[i] = is_bridge[i ^ 1] = 1;
        }
        else if (i != (from ^ 1)) low[u] = min(low[u], dfn[j]);
    }
    if (dfn[u] == low[u]) {
        ++dcc_cnt;
        int y;
        do {
            y = stk[top--];
            id[y] = dcc_cnt;
        } while (y != u);
    }
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            tarjan(i, -1);
        }
    }
    for (int i = 1; i <= n; i++) {
        int p = id[i];
        point[p].push_back(i);
    }
    for (int i = 0; i < idx; i++) {
        if (is_bridge[i]) {
            d[id[e[i]]]++;
        }
    }
}
```

#### 点双连通分量
在一张连通的无向图中，对于两个点 u 和 v，如果无论删去哪个点（只能删去一个，且不能删 u 和 v 自己）都不能使它们不连通，我们就说 u 和 v 点双连通。<br>
一个点可能属于多个点双，但是一条边属于恰好一个点双

```cpp
int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int dcc_cnt;
vector<int> point[N];
bool is_cut_point[N];
int root;
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void tarjan(int u) {
    dfn[u] = low[u] = ++timestamp;
    stk[++top] = u;
    if (u == root && h[u] == -1) {
        dcc_cnt++;
        point[dcc_cnt].push_back(u);
        return;
    }
    int cnt = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j]) {
                cnt++;
                if (u != root || cnt > 1) is_cut_point[u] = 1;
                ++dcc_cnt;
                int y;
                do {
                    y = stk[top--];
                    point[dcc_cnt].push_back(y);
                } while (y != j);
                point[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--) {
        int a, b;
        cin >> a >> b;
        if (a == b) continue;
        add(a, b), add(b, a);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            root = i;
            tarjan(i);
        }
    }
}
```

#### 圆方树
记得点开两倍 <br>
原来的每个点对应一个圆点，每一个点双对应一个方点。所以共有 n + c 个点，其中 n 是原图点数，c 是原图点双连通分量的个数。对于每一个点双连通分量，它对应的方点向这个点双连通分量中的每个点连边。每个点双形成一个「菊花图」，多个「菊花图」通过原图中的割点连接在一起（因为点双的分隔点是割点）。
```cpp
int n, m, cnt;
vector<int> G[N], t[N * 2];
int dfn[N], low[N], dfc;
int stk[N], tp;
int sz[N * 2], w[N * 2]; // 树上子树大小和树上点权值
void Tarjan(int u) {
    low[u] = dfn[u] = ++dfc;                // low 初始化为当前节点 dfn
    stk[++tp] = u;                          // 加入栈中
    for (int v : G[u]) {                    // 遍历 u 的相邻节点
        if (!dfn[v]) {                        // 如果未访问过
            Tarjan(v);                          // 递归
            low[u] = min(low[u], low[v]);  // 未访问的和 low 取 min
            if (low[v] == dfn[u]) {    // 标志着找到一个以 u 为根的点双连通分量
                ++cnt;                 // 增加方点个数
                // 将点双中除了 u 的点退栈，并在圆方树中连边
                for (int x = 0; x != v; --tp) {
                    x = stk[tp];
                    T[cnt].push_back(x);
                    T[x].push_back(cnt);
                }
                // 注意 u 自身也要连边（但不退栈）
                T[cnt].push_back(u);
                T[u].push_back(cnt);
            }
        }
        else low[u] = min(low[u], dfn[v]);  // 已访问的和 dfn 取 min
    }
}
void solve() {
    cin >> n >> m;
    cnt = n;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            Tarjan(i);
            --tp;
        }
    }
}
```

### 欧拉回路和路径
全连通无向图欧拉路径（不回路）要求只有两个点是奇数度 <br>
全连通无向图欧拉回路没有奇数度的点 <br>
全连通有向图欧拉路径：起点出度比入度多一，终点入度比出度多一，其余点入度等于出度 <br>
全连通有向图欧拉回路：所有点入度等于出度 <br>

#### 欧拉回路
```cpp
int type; // 1为无向，2为有向 
int n, m;
int h[N], e[M], ne[M], idx;
bool used[M]; // 判断边是否被用过
int ans[M], cnt;  // ans记录的是第几个边，值为正是正向边，负是反向边
int din[N], dout[N];
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void dfs(int u) {
    for (int &i = h[u]; i != -1;) {
        if (used[i]) {
            i = ne[i];
            continue;
        }
        used[i] = 1;
        if (type == 1) used[i ^ 1] = 1;
        int t;
        if (type == 1) { // 无向边加了两边，有向边只有一遍
            t = i / 2 + 1;
            if (i & 1) t *= -1;
        }
        else t = i + 1;
        int j = e[i];
        i = ne[i];
        dfs(j);
        ans[++cnt] = t;
    }
}
void solve() {
    cin >> type;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) h[i] = -1;
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        add(a, b);
        if (type == 1) add(b, a);
        din[b]++, dout[a]++;
    }
    if (type == 1) {
        for (int i = 1; i <= n; i++) {
            if ((din[i] + dout[i]) & 1) {
                cout << "NO" << '\n';
                return;
            }
        }
    }
    else {
        for (int i = 1; i <= n; i++) {
            if (din[i] != dout[i]) {
                cout << "NO" << '\n';
                return;
            }
        }
    }
    for (int i = 1; i <= n; i++) { // 从任意一个有边的起点开始搜
        if (h[i] != -1) {
            dfs(i);
            break;
        }
    }
    if (cnt < m) {
        cout << "NO" << '\n';
        return;
    }
    cout << "YES" << '\n';
    for (int i = cnt; i >= 1; i--) cout << ans[i] << ' ';
}
```

#### 欧拉路径
```cpp
int n = 500, m;
int g[N][N];
int ans[1100], cnt;
int d[N];
void dfs(int u) {
    for (int i = 1; i <= n; i++) { // 字典序最小
        if (g[u][i]) {
            g[u][i]--, g[i][u]--;
            dfs(i);
        }
    }
    ans[++cnt] = u;
}
void solve() {
    cin >> m;
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a][b]++, g[b][a]++;
        d[a]++, d[b]++;
    }    
    int start = 1;
    while (!d[start]) start++;
    for (int i = 1; i <= n; i++) {
        if (d[i] & 1) {
            start = i;
            break;
        }
    } 
    dfs(start);
    for (int i = cnt; i >= 1; i--) cout << ans[i] << '\n';
}
```

### 全局最小割
有无向图 G = (V, E)，设 C 为图 G 中一些弧的集合，若从 G 中删去 C 中的所有弧能使图 G 不是连通图，称 C 图 G 的一个割。<br>
全局最小割：包含的弧的权和最小的割，称为全局最小割。 O(VE + V^2logV)
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 610, INF = 1e9;
int n, m, x, y, z, s, t, dis[MAXN][MAXN], w[MAXN], dap[MAXN], vis[MAXN], ord[MAXN];
int proc (int x) {
	memset(vis, 0, sizeof(vis));
	memset(w, 0, sizeof(w));
	w[0] = -1;
	for (int i = 1; i <= n - x + 1; i++) {
		int mx = 0;
		for (int j = 1; j <= n; j++) {
			if (!dap[j] && !vis[j] && w[j] > w[mx]) {
				mx = j;
			}
		}
		vis[mx] = 1, ord[i] = mx;
		for (int j = 1; j <= n; j++) {
			if (!dap[j] && !vis[j]) {
				w[j] += dis[mx][j];
			}
		}
	}
	s = ord[n - x], t = ord[n - x + 1];
	return w[t];
}
int sw () {
	int res = INF;
	for (int i = 1; i < n; i++) {
		res = min(res, proc(i));
		dap[t] = 1;
		for (int j = 1; j <= n; j++) {
			dis[s][j] += dis[t][j];
			dis[j][s] += dis[j][t];
		}
	}
	return res;
}
int main () {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> x >> y >> z;
		dis[x][y] += z, dis[y][x] += z;
	}
	cout << sw();
	return 0;
}
```

### 树上K级祖先
每次询问一个点的 k 级祖先是谁, 长链剖分 复杂度O(nlogn + q)
```cpp
#include<bits/stdc++.h>
#define REG register
#define LL long long
#define UI unsigned int
#define MAXN 500005
using namespace std;
inline int read() {
    REG int x(0);
    REG char c = getchar();
    while (!isdigit(c)) c = getchar();
    while (isdigit(c)) x = (x * 10) + (c ^ 48), c = getchar();
    return x;
}
int n, q, rt;
vector<int> NodeUp[MAXN], NodeDown[MAXN], Edge[MAXN];
int Dep[MAXN], MDep[MAXN], Son[MAXN], Top[MAXN], HighBit[MAXN];
int Fat[MAXN][21];
LL ans;
int lastans;
UI s;
UI Get(UI x) {
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    return s = x;
}
void dfs1(int now) {
    MDep[now] = Dep[now] = Dep[Fat[now][0]] + 1;
    for (auto v : Edge[now]) {
        Fat[v][0] = now;
        for (REG int i = 0; Fat[v][i]; i++) Fat[v][i + 1] = Fat[Fat[v][i]][i];
        dfs1(v);
        if (MDep[v] > MDep[now]) MDep[now] = MDep[v], Son[now] = v;
    }
}
void dfs2(int now, int top) {
    Top[now] = top;
    if (now == top) {
        for (REG int i = 0, f = now; i <= MDep[now] - Dep[now]; i++)
            NodeUp[now].push_back(f), f = Fat[f][0];
        for (REG int i = 0, f = now; i <= MDep[now] - Dep[now]; i++)
            NodeDown[now].push_back(f), f = Son[f];
    }
    if (Son[now]) dfs2(Son[now], top);
    for (auto v : Edge[now])
        if (v ^ Son[now]) dfs2(v, v);
}
inline int Ask(int x, int k) {
    if (!k) return x;
    x = Fat[x][HighBit[k]], k -= (1 << HighBit[k]), k -= Dep[x] - Dep[Top[x]], x = Top[x];
    return k >= 0 ? NodeUp[x][k] : NodeDown[x][-k];
}
void Solve() {
    n = read(), q = read(), s = read(), HighBit[1] = 0;
    for (REG int i = 2; i <= n; i++)
        HighBit[i] = HighBit[i >> 1] + 1;
    for (REG int i = 1; i <= n; i++)
        Edge[read()].push_back(i);
    rt = Edge[0][0];
    dfs1(rt);
    dfs2(rt, rt);
    for (REG int i = 1; i <= q; i++) {
        int x = ((Get(s) ^ lastans) % n) + 1;
        int k = ((Get(s) ^ lastans) % Dep[x]);
        lastans = Ask(x, k);
        ans ^= 1ll * i * lastans;
    }
    printf("%lld\n", ans);
}
int main() {
    Solve();
    return 0;
}
```

### 斯坦纳树
最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。
```cpp
const int INF = 0x3f3f3f3f;
void solve() {
    int n, m, k;
    cin >> n >> m >> k;
    vector<vector<pair<int, int>>> g(n + 1);
    vector<bool> vis(n + 1, 0);
    vector<vector<int>> dp((1 << k) + 1, vector<int> (n + 1, INF));
    auto djs = [&](int S) -> void {
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
        for (int i = 1; i <= n; i++) vis[i] = 0;
        for (int i = 1; i <= n; i++) {
            if (dp[S][i] != INF) {
                q.push({dp[S][i], i});
            }
        }
        while (!q.empty()) {
            auto u = q.top();
            q.pop();
            if (vis[u.second]) continue;
            vis[u.second] = 1;
            for (auto [v, w] : g[u.second]) {
                if (dp[S][v] > u.first + w) {
                  dp[S][v] = u.first + w;
                  q.push({dp[S][v], v});
                }
            }
        }
    };
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].emplace_back(v, w), g[v].emplace_back(u, w);
    }    
    for (int i = 0; i < k; i++) {
        int x;
        cin >> x;
        dp[1 << i][x] = 0;
    }
    for (int S = 1; S < (1 << k); S++) {
        for (int T = S & (S - 1); T; T = S & (T - 1)) {
            if (T < (S ^ T)) break;
            for (int i = 1; i <= n; i++) dp[S][i] = min(dp[S][i], dp[T][i] + dp[T ^ S][i]); 
        }
        djs(S);
    }
    int ans = INF;
    for (auto u : dp[(1 << k) - 1]) ans = min(ans, u);
    cout << ans << '\n';
}
```

### 稳定婚姻系统
为两个元素数量相等的集合寻找稳定匹配，确保不存在彼此更偏好的未配对组合
```cpp
#include <bits/stdc++.h>
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
using LL = long long;
const int MAXN = 1e3 + 10;
// pref[i][j]表示女性 i 对男性 j 的偏好程度。
// order[i][j]表示男性 i 对女性 j 的偏好排序。
// nex 表示当前每个男性的提议顺序，记录下一个要向哪个女性求婚。
int pref[MAXN][MAXN], order[MAXN][MAXN], nex[MAXN]; 
int future_husband[MAXN], future_wife[MAXN];
// 队列用于存储尚未配对的男性。
queue<int> q;
void engage(int man, int woman) {
    int m = future_husband[woman];
    if (m) {
        future_wife[m] = 0;
        q.push(m);
    }
    future_wife[man] = woman;
    future_husband[woman] = man;
}
void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int which;
        cin >> which;
        for (int j = 1; j <= n; j++) {
            int x;
            cin >> x;
            order[which][x] = j;
        }
        future_husband[which] = 0;
    }
    for (int i = 1; i <= n; i++) {
        int which;
        cin >> which;
        for (int j = 1; j <= n; j++) cin >> pref[which][j];
        nex[which] = 1;
        future_wife[which] = 0;
        q.push(which);
    }
    while (!q.empty()) {
        int man = q.front();
        q.pop();
        int woman = pref[man][nex[man]++];
        if (!future_husband[woman]) engage(man, woman);
        else if (order[woman][man] < order[woman][future_husband[woman]]) engage(man, woman);
        else q.push(man);
    }
    while (!q.empty()) q.pop();
    for (int i = 1; i <= n; i++) cout << i << " " << future_wife[i] << '\n';
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

### 无向图三元环计数
O(m * sqrt(m))
```cpp
int n, m;
int h[N], e[M], ne[M], idx;
int deg[N], vis[N], ans;
struct Edge {
    int u, v;
} edge[M];
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        edge[i] = {a, b};
        deg[a]++, deg[b]++;
    }
    for (int i = 1; i <= m; i++) {
        int &u = edge[i].u, &v = edge[i].v;
        if (deg[u] < deg[v] || (deg[u] == deg[v] && u > v)) swap(u, v);
        add(u, v);
    }
    for (int x = 1; x <= n; x++) {
        for (int i = h[x]; i != -1; i = ne[i]) vis[e[i]] = x;
        for (int i = h[x]; i != -1; i = ne[i]) {
            int y = e[i];
            for (int j = h[y]; j != -1; j = ne[j]) {
                int z = e[j];
                if (vis[z] == x) ans++;
            }
        }
    }
    cout << ans << '\n';
}
```

### 虚树
```cpp
const int N = 2e5 + 10, LOG = 20;
vector<int> g[N];
int up[N][LOG];
int depthv[N], tin[N], tout[N], timer;
void dfs_root(int u, int fa) {
    tin[u] = ++timer;
    up[u][0] = fa;
    for (int i = 1; i < LOG; i++) up[u][i] = up[up[u][i - 1]][i - 1];
    for (auto v : g[u]) {
        if (v == fa) continue;
        depthv[v] = depthv[u] + 1;
        dfs_root(v, u);
    }
    tout[u] = timer;
}
bool is_ancestor(int u, int v) {
    return tin[u] <= tin[v] && tout[v] <= tout[u];
}
int lca(int u, int v) {
    if (is_ancestor(u, v)) return u;
    if (is_ancestor(v, u)) return v;
    for (int i = LOG - 1; i >= 0; i--) {
        if (!is_ancestor(up[u][i], v)) {
            u = up[u][i];
        }
    }
    return up[u][0];
}
pair<vector<bool>, int> build(const vector<int>& nodes, vector<int>& vt_nodes, vector<vector<int>>& vt_adj) {
    if (nodes.empty()) {
        vt_nodes.clear();
        vt_adj.clear();
        return {{}, -1};
    }
    // 1) 去重 + 按 tin 排序
    vector<int> a = nodes;
    sort(a.begin(), a.end(), [&](int x, int y) { 
        return tin[x] < tin[y]; 
    });
    a.erase(unique(a.begin(), a.end()), a.end());
    // 2) 加相邻 LCA
    vt_nodes = a;
    vt_nodes.reserve(a.size() * 2);
    for (int i = 0; i + 1 < (int)a.size(); i++) vt_nodes.push_back(lca(a[i], a[i + 1]));
    // 3) 最终集合（按 tin 排序 + 去重）
    sort(vt_nodes.begin(), vt_nodes.end(), [&](int x, int y) { 
        return tin[x] < tin[y]; 
    });
    vt_nodes.erase(unique(vt_nodes.begin(), vt_nodes.end()), vt_nodes.end());
    // 4) 用标准“栈法”连边（父→子），边先用原节点编号存
    vector<pair<int, int>> edges; // (parent_node, child_node)
    vector<int> st;
    auto link = [&](int p, int ch) -> void { 
        edges.emplace_back(p, ch); 
    };
    st.push_back(vt_nodes[0]);
    for (int i = 1; i < (int)vt_nodes.size(); i++) {
        int u = vt_nodes[i];
        int L = lca(u, st.back());
        if (L == st.back()) {                // 直接挂在当前链上
            st.push_back(u);
            continue;
        }
        // 把栈弹到 L 之下
        while ((int)st.size() >= 2 && tin[st[st.size() - 2]] >= tin[L]) {
            link(st[st.size() - 2], st.back());
            st.pop_back();
        }
        if (st.back() != L) {                // 把 L 接到当前链上
            link(L, st.back());
            st.pop_back();
            st.push_back(L);
        }
        st.push_back(u);
    }
    while ((int)st.size() > 1) {             // 清栈，连剩余边
        link(st[st.size() - 2], st.back());
        st.pop_back();
    }
    int root_node = st.back();               // 栈最后剩下的就是虚树根(原树编号)
    // 5) 把“原节点编号的边”映射到 vt_nodes 的下标，形成 vt_adj
    map<int, int> idx;
    for (int i = 0; i < (int)vt_nodes.size(); i++) idx[vt_nodes[i]] = i;
    vt_adj.assign(vt_nodes.size(), {});
    for (auto [p, ch] : edges) {
        int ip = idx[p], ic = idx[ch];
        vt_adj[ip].push_back(ic);
    }
    // 6) vis 标记哪些是原始 nodes
    vector<bool> vis(vt_nodes.size(), false);
    for (auto x : a) vis[idx[x]] = true;
    int root_idx = idx[root_node];
    return {vis, root_idx};
}
void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) g[i].clear();
    for (int i = 1; i <= n - 1; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    timer = 0;
    depthv[1] = 0;
    for (int i = 0; i < LOG; i++) up[1][i] = 1;
    dfs_root(1, 1);
    int q;
    cin >> q;
    while (q--) {
        int k;
        cin >> k;
        vector<int> nodes, vt_nodes;
        vector<vector<int>> vt_adj;
        for (int i = 1; i <= k; i++) {
            int x;
            cin >> x;
            nodes.push_back(x);
        }
        // 判断无解最好先判，不用建虚树
        auto [vis, root] = build(nodes, vt_nodes, vt_adj);
        // 后面可在虚树上dp
    }
}
```

### 严格次小生成树
树上倍增
```cpp
int n, m;
int h[N], e[M], w[M], ne[M], idx;
struct Edge {
    int a, b, w;
    bool used;
    bool operator< (const Edge &W) const {
        return w < W.w;
    }
} edge[M];
int p[N], ra[N];
int depth[N], fa[N][17], d1[N][17], d2[N][17];
void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
LL kru() {
    for (int i = 1; i <= n; i++) p[i] = i;
    sort(edge, edge + m);
    LL res = 0;
    for (int i = 0; i < m; i++) {
        int a = edge[i].a, b = edge[i].b, w = edge[i].w;
        a = find(a), b = find(b);
        if (a != b) {
            if (ra[a] <= ra[b]) {
                p[a] = b;
                if (ra[a] == ra[b]) ra[b]++;
            }
            else p[b] = a;
            res += w;
            edge[i].used = 1;
        }
    }
    return res;
}
void build() {
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++) {
        if (edge[i].used) {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            add(a, b, w), add(b, a, w);
        }
    }
}
void bfs() {
    memset(depth, 0x3f, sizeof(depth));
    depth[0] = 0, depth[1] = 1;
    queue<int> q;
    q.push(1);
    while (q.size()) {
        auto k = q.front();
        q.pop();
        for (int i = h[k]; i != -1; i = ne[i]) {
            int j = e[i];
            if (depth[j] > depth[k] + 1) {
                depth[j] = depth[k] + 1;
                q.push(j);
                fa[j][0] = k;
                d1[j][0] = w[i], d2[j][0] = -INF;
                for (int t = 1; t <= 16; t++) {
                    int anc = fa[j][t - 1];
                    fa[j][t] = fa[anc][t - 1];
                    int distance[4] = {d1[j][t - 1], d2[j][t - 1], d1[anc][t - 1], d2[anc][t - 1]};
                    for (int u = 0; u < 4; u++) {
                        int d = distance[u];
                        if (d > d1[j][t]) d2[j][t] = d1[j][t], d1[j][t] = d;
                        else if (d != d1[j][t] && d > d2[j][t]) d2[j][t] = d;
                    }
                }
            }
        }
    }
}
int lca(int a, int b, int w) {
    static int distance[N * 2];
    int cnt = 0;
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 16; k >= 0; k--) {
        if (depth[fa[a][k]] >= depth[b]) {
            distance[cnt++] = d1[a][k];
            distance[cnt++] = d2[a][k];
            a = fa[a][k];
        }
    }
    if (a != b) {
        for (int k = 16; k >= 0; k--) {
            if (fa[a][k] != fa[b][k]) {
                distance[cnt++] = d1[a][k];
                distance[cnt++] = d2[a][k];
                distance[cnt++] = d1[b][k];
                distance[cnt++] = d2[b][k];
                a = fa[a][k], b = fa[b][k];
            }
        }
        distance[cnt++] = d1[a][0];
        distance[cnt++] = d1[b][0];
    }
    int dist1 = -INF, dist2 = -INF;
    for (int i = 0; i < cnt; i++) {
        int d = distance[i];
        if (d > dist1) dist2 = dist1, dist1 = d;
        else if (d != dist1 && d > dist2) dist2 = d;
    }
    if (w > dist1) return w - dist1;
    if (w > dist2) return w - dist2;
    return INF;
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        edge[i] = {a, b, c};
    }
    LL sum = kru();
    build();
    bfs();
    LL res = 1e18;
    for (int i = 0; i < m; i++) {
        if (!edge[i].used) {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w;
            res = min(res, sum + lca(a, b, w));
        }
    }
    cout << res << '\n';
}
```

### 一般图匹配

#### 一般图最大匹配 O(n^3)
```cpp
const int N = 1010;  
int n, m;         
vector<int> g[N];   
int match[N], p[N], baseArr[N];        
bool used[N], blossom[N];           
int lca(int a, int b) {
    vector<bool> usedVertex(n + 1, false);
    while (true) {
        a = baseArr[a];
        usedVertex[a] = true;
        if (match[a] == -1) break;
        a = p[match[a]];
    }
    while (true) {
        b = baseArr[b];
        if (usedVertex[b]) return b;
        b = p[match[b]];
    }
    return -1; 
}
void markPath(int v, int b, int x) {
    while (baseArr[v] != b) {
        blossom[baseArr[v]] = blossom[baseArr[match[v]]] = true;
        p[v] = x;
        x = match[v];
        v = p[match[v]];
    }
}
bool findPath(int start) {
    for (int i = 1; i <= n; i++) {
        used[i] = false;
        p[i] = -1;
        baseArr[i] = i;
    }
    queue<int> q;
    q.push(start);
    used[start] = true;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int u : g[v]) {
            if (baseArr[v] == baseArr[u] || match[v] == u) continue;
            if (u == start || (match[u] != -1 && p[match[u]] != -1)) {
                int cur = lca(v, u); 
                for (int i = 1; i <= n; i++) blossom[i] = false;
                markPath(v, cur, u);
                markPath(u, cur, v);
                for (int i = 1; i <= n; i++) {
                    if (blossom[baseArr[i]]) {
                        baseArr[i] = cur;
                        if (!used[i]) {
                            used[i] = true;
                            q.push(i);
                        }
                    }
                }
            }
            else if (p[u] == -1) {
                p[u] = v;
                if (match[u] == -1) {
                    int cur = u;
                    while (cur != -1) {
                        int pv = p[cur];
                        int nxt = match[pv];
                        match[cur] = pv;
                        match[pv] = cur;
                        cur = nxt;
                    }
                    return true;
                }
                else {
                    int nxt = match[u];
                    used[nxt] = true;
                    q.push(nxt);
                }
            }
        }
    }
    return false;
}
int edmonds() {
    for (int i = 1; i <= n; i++) match[i] = -1;
    int matchingSize = 0;
    for (int i = 1; i <= n; i++) {
        if (match[i] == -1)
            if (findPath(i))
                matchingSize++;
    }
    return matchingSize;
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    int ans = edmonds();
    cout << ans << "\n";
    for (int i = 1; i <= n; i++) {
        if (match[i] != -1) cout << match[i] << ' ';
        else cout << 0 << ' ';
    }
}
```

#### 一般图最大权匹配 O(n^3)
```cpp
const int N = 620, INF = 0x3f3f3f3f; // 点数设置为 1.5 倍的点数  
struct Edge {
    int x, y, z;  
    Edge() : x(0), y(0), z(0) {}
    Edge(int a, int b, int c) : x(a), y(b), z(c) {}
};
Edge g[N][N]; 
int n, m, nx, t;
int lab[N], match[N], slack[N];
int st[N], pa[N], flower_from[N][N], S[N], vis[N];
vector<int> flower[N];
deque<int> q;
int dist(const Edge &e) {
    return lab[e.x] + lab[e.y] - e.z * 2;
}
void update_slack(int x, int y) {
    if (!slack[y] || dist(g[x][y]) < dist(g[slack[y]][y])) slack[y] = x;
}
void set_slack(int y) {
    slack[y] = 0;
    for (int x = 1; x <= n; x++) {
        if (g[x][y].z > 0 && st[x] != y && S[st[x]] == 0) {
            update_slack(x, y);
        }
    }
}
void q_push(int x) {
    if (x <= n) q.push_back(x);
    else {
        for (int i = 0; i < flower[x].size(); i++) {
            q_push(flower[x][i]);
        }
    }
}
void set_st(int x, int b) {
    st[x] = b;
    if (x <= n) return;
    for (int i = 0; i < flower[x].size(); i++) set_st(flower[x][i], b);
}
int get_pr(int b, int xr) {
    int pr = find(flower[b].begin(), flower[b].end(), xr) - flower[b].begin();
    if (pr % 2 == 1) {
        reverse(flower[b].begin() + 1, flower[b].end());
        return flower[b].size() - pr;
    }
    return pr;
}
void set_match(int x, int y) {
    match[x] = g[x][y].y;
    if (x <= n) return;
    Edge e = g[x][y];
    int xr = flower_from[x][e.x], pr = get_pr(x, xr);
    for (int i = 0; i < pr; ++i) set_match(flower[x][i], flower[x][i ^ 1]);
    set_match(xr, y);
    rotate(flower[x].begin(), flower[x].begin() + pr, flower[x].end());
}
void augment(int x, int y) {
    int xnv = st[match[x]];
    set_match(x, y);
    if (!xnv) return;
    set_match(xnv, st[pa[xnv]]);
    augment(st[pa[xnv]], xnv);
}
int get_lca(int x, int y) {
    for (++t; x || y; swap(x, y)) {
        if (x == 0) continue;
        if (vis[x] == t) return x;
        vis[x] = t;
        x = st[match[x]];
        if (x) x = st[pa[x]];
    }
    return 0;
}
void add_blossom(int x, int lca, int y) {
    int b = n + 1;
    while (b <= nx && st[b]) b++;
    if (b > nx) nx++;
    lab[b] = 0;
    S[b] = 0;
    match[b] = match[lca];
    flower[b].clear();
    flower[b].push_back(lca);
    for (int xx = x, yy; xx != lca; xx = st[pa[yy]]) {
        flower[b].push_back(xx);
        flower[b].push_back(yy = st[match[xx]]);
        q_push(yy);
    }
    reverse(flower[b].begin() + 1, flower[b].end());
    for (int xx = y, yy; xx != lca; xx = st[pa[yy]]) {
        flower[b].push_back(xx);
        flower[b].push_back(yy = st[match[xx]]);
        q_push(yy);
    }
    set_st(b, b);
    for (int xx = 1; xx <= nx; ++xx) g[b][xx].z = g[xx][b].z = 0;
    for (int xx = 1; xx <= n; ++xx) flower_from[b][xx] = 0;
    for (int i = 0; i < flower[b].size(); i++) {
        int xs = flower[b][i];
        for (int xx = 1; xx <= nx; xx++) {
            if (g[b][xx].z == 0 || dist(g[xs][xx]) < dist(g[b][xx])) {
                g[b][xx] = g[xs][xx];
                g[xx][b] = g[xx][xs];
            }
        }
        for (int xx = 1; xx <= n; xx++) {
            if (flower_from[xs][xx]) {
                flower_from[b][xx] = xs;
            }
        }
    }
    set_slack(b);
}
void expand_blossom(int b) {
    for (int i = 0; i < flower[b].size(); i++) set_st(flower[b][i], flower[b][i]);
    int xr = flower_from[b][g[b][pa[b]].x], pr = get_pr(b, xr);
    for (int i = 0; i < pr; i += 2) {
        int xs = flower[b][i], xns = flower[b][i + 1];
        pa[xs] = g[xns][xs].x;
        S[xs] = 1;
        S[xns] = 0;
        slack[xs] = 0;
        set_slack(xns);
        q_push(xns);
    }
    S[xr] = 1;
    pa[xr] = pa[b];
    for (int i = pr + 1; i < flower[b].size(); i++) {
        int xs = flower[b][i];
        S[xs] = -1;
        set_slack(xs);
    }
    st[b] = 0;
}
bool on_found_edge(const Edge &e) {
    int x = st[e.x], y = st[e.y];
    if (S[y] == -1) {
        pa[y] = e.x;
        S[y] = 1;
        int nu = st[match[y]];
        slack[y] = slack[nu] = 0;
        S[nu] = 0;
        q_push(nu);
    } 
    else if (S[y] == 0) {
        int lca = get_lca(x, y);
        if (!lca) {
            augment(x, y);
            augment(y, x);
            return true;
        } 
        else add_blossom(x, lca, y);
    }
    return false;
}
bool matching() {
    memset(S, -1, sizeof(S));
    memset(slack, 0, sizeof(slack));
    q.clear();
    for (int x = 1; x <= nx; x++) {
        if (st[x] == x && !match[x]) {
            pa[x] = 0;
            S[x] = 0;
            q_push(x);
        }
    }
    if (q.empty()) return false;
    while (true) {
        while (q.size()) {
            int x = q.front();
            q.pop_front();
            if (S[st[x]] == 1) continue;
            for (int y = 1; y <= n; y++) {
                if (g[x][y].z > 0 && st[x] != st[y]) {
                    if (dist(g[x][y]) == 0) {
                        if (on_found_edge(g[x][y])) return true;
                    } 
                    else update_slack(x, st[y]);
                }
            }
        }
        int d = INF;
        for (int b = n + 1; b <= nx; b++) {
            if (st[b] == b && S[b] == 1) {
                d = min(d, lab[b] / 2);
            }
        }
        for (int x = 1; x <= nx; x++) {
            if (st[x] == x && slack[x]) {
                if (S[x] == -1) d = min(d, dist(g[slack[x]][x]));
                else if (S[x] == 0) d = min(d, dist(g[slack[x]][x]) / 2);
            }
        }
        for (int x = 1; x <= n; x++) {
            if (S[st[x]] == 0) {
                if (lab[x] <= d) return false;
                lab[x] -= d;
            } 
            else if (S[st[x]] == 1) lab[x] += d;
        }
        for (int b = n + 1; b <= nx; b++) {
            if (st[b] == b) {
                if (S[st[b]] == 0) lab[b] += d * 2;
                else if (S[st[b]] == 1) lab[b] -= d * 2;
            }
        }
        q.clear();
        for (int x = 1; x <= nx; x++) {
            if (st[x] == x && slack[x] && st[slack[x]] != x && dist(g[slack[x]][x]) == 0) {
                if (on_found_edge(g[slack[x]][x])) return true;
            }
        }
        for (int b = n + 1; b <= nx; b++) {
            if (st[b] == b && S[b] == 1 && lab[b] == 0) {
                expand_blossom(b);
            }
        }
    }
    return false;
}
pair<LL, int> weight_blossom() {
    memset(match, 0, sizeof(match));
    nx = n;
    int n_matches = 0;
    LL tot_weight = 0;
    for (int x = 0; x <= n; x++) {
        st[x] = x;
        flower[x].clear();
    }
    int w_max = 0;
    for (int x = 1; x <= n; x++) {
        for (int y = 1; y <= n; y++) {
            flower_from[x][y] = (x == y ? x : 0);
            w_max = max(w_max, g[x][y].z);
        }
    }
    for (int x = 1; x <= n; x++) lab[x] = w_max;

    while (matching()) ++n_matches;

    for (int x = 1; x <= n; x++) {
        if (match[x] && match[x] < x) {
            tot_weight += (LL)g[x][match[x]].z;
        }
    }
    return make_pair(tot_weight, n_matches);
}
void solve() {
    cin >> n >> m;
    for (int x = 1; x <= n; x++) {
        for (int y = 1; y <= n; y++) {
            g[x][y] = Edge(x, y, 0);
        }
    }
    int x, y, z;
    for (int i = 1; i <= m; i++) {
        cin >> x >> y >> z;
        g[x][y].z = g[y][x].z = z;
    }
    cout << weight_blossom().first << "\n";
    for (int i = 1; i <= n; i++) cout << match[i] << ' ';
    cout << '\n';
}
```

### 最短哈密顿路径
状态压缩dp 从 0 号点到 n - 1 号点的最短哈密顿路径
```cpp
const int N = 20, M = 1 << 20, mod = 1e9 + 7;
int g[N][N];
int f[M][N];
void solve() {
    memset(f, 0x3f, sizeof(f));
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> g[i][j];
        }
    }
    f[1][0] = 0;
    for (int i = 0; i < 1 << n; i++) {
        for (int j = 0; j < n; j++) {
            if (i >> j & 1) {
                for (int k = 0; k < n; k++) {
                    if (i >> k & 1) {
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + g[k][j]);
                    }
                }
            }
        }
    }
    cout << f[(1 << n) - 1][n - 1];
}
```

### 最短路和次短路及方案数

#### 正权图
```cpp
struct Ver {
    int id, type, dist; // type0 为最短路， type1 为次短路
    bool operator> (const Ver &w) const {
        return dist > w.dist;
    }
};
int n, m, S, T;
int h[N], e[M], w[M], ne[M], idx;
int dist[N][2], cnt[N][2];
bool vis[N][2];
void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
void djs() {
    for (int i = 1; i <= n; i++) dist[i][0] = INF, dist[i][1] = INF;
    for (int i = 1; i <= n; i++) vis[i][0] = 0, vis[i][1] = 0;
    for (int i = 1; i <= n; i++) cnt[i][0] = 0, cnt[i][1] = 0;
    dist[S][0] = 0, cnt[S][0] = 1;
    priority_queue<Ver, vector<Ver>, greater<Ver>> q;
    q.push({S, 0, 0});
    while (q.size()) {
        auto k = q.top();
        q.pop();
        int ver = k.id, type = k.type, count = cnt[ver][type], distance = k.dist;
        if (vis[ver][type]) continue;
        vis[ver][type] = 1;
        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j][0] > distance + w[i]) {
                dist[j][1] = dist[j][0], cnt[j][1] = cnt[j][0]; // 原最小值变次小值
                q.push({j, 1, dist[j][1]});
                dist[j][0] = distance + w[i];
                cnt[j][0] = count;
                q.push({j, 0, dist[j][0]});
            }
            else if (dist[j][0] == distance + w[i]) cnt[j][0] += count;
            else if (dist[j][1] > distance + w[i]) {
                dist[j][1] = distance + w[i];
                cnt[j][1] = count;
                q.push({j, 1, dist[j][1]});
            }
            else if (dist[j][1] == distance + w[i]) cnt[j][1] += count;
        }
    }
}
```

#### 无向无权图
```cpp
int n, m;
int h[N], e[M], ne[M], idx;
int d[N], cnt[N];
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void bfs() {
    memset(d, 0x3f, sizeof(d));
    queue<int> q;
    d[1] = 0;
    cnt[1] = 1;
    q.push(1);
    while (q.size()) {
        auto k = q.front();
        q.pop();
        for (int i = h[k]; i != -1; i = ne[i]) {
            int j = e[i];
            if (d[j] > d[k] + 1) {
                d[j] = d[k] + 1;
                cnt[j] = cnt[k];
                q.push(j);
            }
            else if (d[j] == d[k] + 1) cnt[j] = (cnt[j] + cnt[k]) % mod;
        }
    }
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    bfs();
    for (int i = 1; i <= n; i++) cout << cnt[i] << '\n';
}
```

### 最小树形图
O(nm) 朱刘算法 <br>
不限定根结点的树形图，我们可以虚拟一个 0 号根节点，并向各个点连一条权值为 sum(w) + 1 的边，因为权值很大，所以最终结果一定只包含一条这样的边；但是如果答案大于 sum + sum + 1，其实是无解的，这样相当于两个点不联通，只好多选一条大边；否则答案是 ans − sum − 1
```cpp
int n, m, rt, t, cnt, id[N], pre[N], ine[N], vis[N];
struct line {
    int x, y, c;
} q[M];
int zl() {
    int ans = 0;
    while (true) {
         cnt = 0;
         for (int i = 1; i <= n; ++i) ine[i] = INF, vis[i] = 0, id[i] = 0; // 预处理
         for (int i = 1; i <= m; ++i) if (q[i].x != q[i].y && ine[q[i].y] > q[i].c) ine[q[i].y] = q[i].c, pre[q[i].y] = q[i].x; //每个点的最短边
         for (int i = 1; i <= n; ++i) if (i != rt && ine[i] == INF) return -1; // 有点无最短边
         for (int i = 1; i <= n; ++i) {
             if (i == rt) continue;
             ans += ine[i], t = i;
             while (vis[t] != i && !id[t] && t != rt) vis[t] = i, t = pre[t];
             // 能走到环的点或者换上的点停下
             if (!id[t] && t != rt) {
                id[t] = ++cnt; // 将环上的点标记为新的环
                for (int o = pre[t]; o != t; o = pre[o]) id[o] = cnt;
             }
         } // 找环
         if (!cnt) break; // 无环结束
         for (int i = 1; i <= n; ++i) if(!id[i]) id[i] = ++cnt;
         for (int i = 1; i <= m;++i) { 
             t = q[i].y, q[i].x = id[q[i].x], q[i].y = id[q[i].y];
             if (q[i].x != q[i].y) q[i].c -= ine[t];
         }
         n = cnt, rt = id[rt];
         // 去旧图,换新图
    }
    return ans;
}
void solve() {
    cin >> n >> m >> rt;
    for (int i = 1; i <= m; i++) cin >> q[i].x >> q[i].y >> q[i].c;
    cout << zl() << '\n'; 
}
```
```cpp
int n, m, r; // 点数，边数，根
LL d[N][N], bd[N][N]; 
int pre[N];
int dfn[N], low[N], ts, stk[N], top;
int id[N], cnt;
bool st[N], ins[N];
void dfs(int u) {
    st[u] = 1;
    for (int i = 1; i <= n; i++) {
        if (d[u][i] < INF && !st[i]) dfs(i);
    }
}
bool check_con() {
    dfs(r);
    for (int i = 1; i <= n; i++) {
        if (!st[i]) return 0;
    }
    return 1;
}
void tarjan(int u) {
    dfn[u] = low[u] = ++ts;
    stk[++top] = u, ins[u] = 1;
    int j = pre[u];
    if (!dfn[j]) {
        tarjan(j);
        low[u] = min(low[u], low[j]);
    }
    else if (ins[j]) low[u] = min(low[u], dfn[j]);
    if (low[u] == dfn[u]) {
        int y;
        ++cnt;
        do {
            y = stk[top--];
            ins[y] = 0;
            id[y] = cnt;
        } while (y != u);
    }
}
LL work() {
    LL res = 0;
    while (1) {
        for (int i = 1; i <= n; i++) {
            pre[i] = i;
            for (int j = 1; j <= n; j++) {
                if (d[pre[i]][i] > d[j][i]) {
                    pre[i] = j;
                } 
            }
        }
        memset(dfn, 0, sizeof(dfn));
        ts = cnt = 0;
        for (int i = 1; i <= n; i++) {
            if (!dfn[i]) {
                tarjan(i);
            } 
        }
        if (cnt == n) {
            for (int i = 1; i <= n; i++) {
                if (i != r) res += d[pre[i]][i];
            }
            break;
        }
        for (int i = 1; i <= n; i++) {
            if (i != r) {
                if (id[pre[i]] == id[i]) {
                    res += d[pre[i]][i];
                }
            }
        }
        for (int i = 1; i <= cnt; i++) {
            for (int j = 1; j <= cnt; j++) {
                bd[i][j] = INF;
            } 
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (d[i][j] < INF && id[i] != id[j]) {
                    int a = id[i], b = id[j];
                    if (id[pre[j]] == id[j]) bd[a][b] = min(bd[a][b], d[i][j] - d[pre[j]][j]);
                    else bd[a][b] = min(bd[a][b], d[i][j]);
                } 
            }
        }
        n = cnt;
        r = id[r];
        memcpy(d, bd, sizeof(d));
    }
    return res;
}
void solve() {
    cin >> n >> m >> r;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            d[i][j] = INF;
        }
    }
    while (m--) {
        int a, b;
        LL c;
        cin >> a >> b >> c;
        if (a != b && b != r) d[a][b] = min(d[a][b], c);
    }
    if (!check_con()) cout << "-1" << '\n';
    else cout << work() << '\n';
}
```

### Bellman_ford
```cpp
int n, m;     
int dist[N], backup[N] // 备份
bool flag; // 用来确定是否存在最短路
struct Edge {  
    int a, b, w;
} edges[M];
int bellman_ford() {
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    // 如果第 n 次迭代仍然会松弛，就说明存在一条长度是 n + 1 的最短路径, 图中存在负权回路。
    for (int i = 0; i < n; i++) {
        memcpy(backup,dist,sizeof(dist));
        for (int j = 0; j < m; j++) {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > backup[a] + w) dist[b] = backup[a] + w;
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) flag = 1;
    return dist[n];
}
```

### Boruvka
边具有较多特殊性质的问题中，Boruvka 算法具有优势 <br>
(1)计算每个点分别属于哪个连通块。将每个连通块都设为「没有最小边」。 <br>
(2)遍历每条边(u, v)，如果 u 和 v 不在同一个连通块，就用这条边的边权分别更新 u 和 v 所在连通块的最小边。 <br>
(3)如果所有连通块都没有最小边，退出程序，此时的 E' 就是原图最小生成森林的边集。否则，将每个有最小边的连通块的最小边加入 E'，返回第一步。
```cpp
struct edge {
    int u, v, w;
} e[M];
int p[N], min_edge[N];
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
bool merge(int u, int v) {
    int fu = find(u), fv = find(v);
    if (fu == fv) return 0;
    p[fu] = fv;
    return 1; 
} 
void solve() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) p[i] = i;
    for (int i = 1; i <= m; i++) cin >> e[i].u >> e[i].v >> e[i].w;
    int cnt_cmp = n;
    LL ans = 0;
    while (cnt_cmp > 1) {
        for (int i = 1; i <= n; i++) min_edge[i] = -1;
        for (int i = 1; i <= m; i++) {
            if (find(e[i].u) == find(e[i].v)) continue;
            int r_u = find(e[i].u);
            if (min_edge[r_u] == -1 || e[i].w < e[min_edge[r_u]].w) min_edge[r_u] = i;
            int r_v = find(e[i].v);
            if (min_edge[r_v] == -1 || e[i].w < e[min_edge[r_v]].w) min_edge[r_v] = i; 
        }
        for (int i = 1; i <= n; i++) {
            if (min_edge[i] != -1) {
                if (merge(e[min_edge[i]].u, e[min_edge[i]].v)) {
                    ans += e[min_edge[i]].w;
                    cnt_cmp--;
                }
            }
        }
    }   
    cout << ans << '\n';
}
```

### Dijkstra

#### 朴素 Dijkstra
```cpp
int g[N][N];  
int dist[N];  
bool st[N];  
int dijkstra() {
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    for (int i = 0; i < n - 1; i++) {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j++) {
            if (!st[j] && (t == -1 || dist[t] > dist[j])) {
                t = j;
            }
        }
        st[t] = true;
        // 用 t 更新其他点的距离
        for (int j = 1; j <= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    return dist[n];
}
```

#### 堆优化的 Dijkstra
```cpp
vector<pair<int, int>> g[N];
int d[N];
bool vis[N];
void djs(int u) {
    priority_queue<PII, vector<PII>, greater<PII>> q;
    d[u] = 0;
    q.push({d[u], u});
    while (q.size()) {
        auto [val, u] = q.top();
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto &[v, w] : g[u]) {
            if (d[v] > val + w) {
                d[v] = val + w;
                q.push({d[v], v});
            }
        }
    }
}
```

### Floyd

#### 多源最短路
```cpp
int n, m;
int d[N][N];
void solve() {
    cin >> n >> m;
    memset(d, 0x3f, sizeof(d));
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = min(d[a][b], c), d[b][a] = min(d[b][a], c); 
    }
    for (int i = 1; i <= n; i++) d[i][i] = 0;
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
    // 加了一条边 [u, v, w]
    for (int i = 1; i <= n; i++) {
        for (int j  =1; j <= n; j++) {
            d[i][j] = min(d[i][j], d[i][u] + d[v][j] + w);
            d[i][j] = min(d[i][j], d[i][v] + d[u][j] + w);
        }
    }
}
```

#### 传递闭包
```cpp
void floyd() {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                d[i][j] |= d[i][k] && d[k][j];
            }
        }
    }
}
```

#### 从起点到终点恰好经过 k 条边的最短路（可重复经过边）
Floyd + 矩阵快速幂 $O(n^3logk)$
```cpp
const int N = 201;
int n, m, k, S, E; 
int g[N][N], res[N][N], tmp[N][N];  
void mul(int c[][N], int a[][N], int b[][N]) {
    memset(tmp, 0x3f, sizeof(tmp));
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                tmp[i][j] = min(tmp[i][j], a[i][k] + b[k][j]);
            }
        }
    }
    memcpy(c, tmp, sizeof(tmp));
}
void qmi() {
    memset(res, 0x3f, sizeof(res));
    for (int i = 1; i <= n; i++) res[i][i] = 0;
    while (k) {
        if (k & 1) mul(res, res, g);
        mul(g, g, g);
        k >>= 1;
    }
}
void solve() {
    cin >> k >> m >> S >> E;
    memset(g, 0x3f, sizeof(g));
    map<int, int> idx;
    if (!idx.count(S)) idx[S] = ++n;
    if (!idx.count(E)) idx[E] = ++n;
    S = idx[S], E = idx[E];
    while (m--) {
        int a, b, c;
        cin >> c >> a >> b;
        if (!idx.count(a)) idx[a] = ++n;
        if (!idx.count(b)) idx[b] = ++n;
        a = idx[a], b = idx[b];
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    qmi();
    cout << res[S][E] << '\n';
}   
```

### 最小环

Floyd $O(n^3)$
```cpp
const int N = 101, INF = 0x3f3f3f3f;
int n, m;
int d[N][N], g[N][N]; // d 是最短路 g 是原始边权
int pos[N][N];        // pos 记录 i j 在 floyd 上的转移中间点
int path[N], cnt;     // 最小环路径 最小环点数
int ans = INF;        // 最小环之和
void get_path(int i, int j) { 
    if (pos[i][j] == 0) return;
    int k = pos[i][j];
    get_path(i, k);
    path[cnt++] = k;
    get_path(k, j);
}
void solve() {
    cin >> n >> m;
    memset(g, 0x3f, sizeof(g));
    for (int i = 1; i <= n; i++) g[i][i] = 0;
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    memcpy(d, g, sizeof(g));
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i < k; i++) {
            for (int j = i + 1; j < k; j++) {
                if ((i64)d[i][j] + g[j][k] + g[k][i] < ans) {
                    ans = (i64)d[i][j] + g[j][k] + g[k][i];
                    cnt = 0;
                    path[cnt++] = k;
                    path[cnt++] = i;
                    get_path(i, j);
                    path[cnt++] = j;
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (d[i][j] > d[i][k] + d[k][j]) {
                    d[i][j] = d[i][k] + d[k][j];
                    pos[i][j] = k; // 转移
                }
            }
        }
    }
    if (ans == INF) cout << "No solution." << '\n';
    else {
        cout << ans << '\n';
        for (int i = 0; i < cnt; i++) cout << path[i] << ' ';
    }
}
```

Dijkstra $O(m(n + m)logn)$ <br>
枚举所有边，每一次求删除一条边之后对这条边的起点跑一次 Dijkstra

### Johnson
跑全源最短路，带负权，首先 spfa 判断负环然后建立一个虚拟节点，给每个点加一条 0 权值的边 spfa 求每个点的势能 djs 求最短路 真实最短路为的 d[i][j] - (h[i] - h[j]) 后者为势能
```cpp
int n, m;
int h[N], e[M], ne[M], w[M], idx;
int d[N][N];
bool vis[N][N];
int cnt[N];
LL sum[N];
bool st[N];
int dd[N];
void add(int a,int b,int u) {
    e[idx] = b, w[idx] = u, ne[idx] = h[a], h[a] = idx++;
}
void spfa() {
    memset(dd, 0x3f, sizeof(dd));
    memset(st, 0, sizeof(st));
    queue<int> q;
    dd[0] = 0;
    st[0] = 1;
    q.push(0);
    while (q.size()) {
        auto k = q.front();
        q.pop();
        st[k] = 0;
        for (int i = h[k]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dd[j] > dd[k] + w[i]) {
                dd[j] = dd[k] + w[i];
                if (!st[j]) {
                    q.push(j);
                    st[j] = 1;
                }
            }
        }
    }
}
bool spfa__fuhuan() {
    queue<int> q;
    for (int i = 1; i <= n ;i++) {
        q.push(i);
        st[i] = 1;
    }
    while (q.size()) {
        auto k = q.front();
        q.pop();
        st[k] = 0;
        for (int i = h[k]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dd[j] > dd[k] + w[i]) {
                dd[j] = dd[k] + w[i];
                cnt[j] = cnt[k] + 1;
                if (cnt[j] >= n) return 1;
                if (!st[j]) {
                    q.push(j);
                    st[j] = 1;
                }
            }
        }
    }
    return 0;
}
void djs(int u) {
    priority_queue<PII,vector<PII>,greater<PII>> hh;
    d[u][u] = 0;
    hh.push({d[u][u],u});
    while (hh.size()) {
        auto k = hh.top();
        hh.pop();
        if (vis[u][k.second]) {
            continue;
        }
        vis[u][k.second] = 1;
        for (int i = h[k.second]; i != -1; i = ne[i]) {
            int j = e[i];
            if (d[u][j] > k.first + w[i] + dd[k.second] - dd[j]) {
                d[u][j] = k.first + w[i] + dd[k.second] - dd[j];
                hh.push({d[u][j],j});
            }
        }
    }
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for (int i = 1;i <= m; i++) {
        int x, y, u;
        cin >> x >> y >> u;
        add(x, y, u);
    }
    if (spfa__fuhuan()) {
        cout << -1;
        return;
    }
    memset(d, 0x3f, sizeof(d));
    for (int i = 1; i <= n; i++) add(0, i, 0);
    spfa();
    for (int i = 1; i <= n; i++) djs(i);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (d[i][j] == INF) sum[i] += (LL)j * 1e9;
            else sum[i] += (LL)j * (d[i][j] - (dd[i] - dd[j]));
        }
    }
    for (int i = 1; i <= n; i++) cout << sum[i] << '\n';
}
```

### K短路
A*算法, 不是最优解
```cpp
typedef pair<int, PII> PIII;
int n, m, S, T, K;  // 点，边，起点，终点
int h[N], rh[N], e[M], ne[M], w[M], idx;
int dist[N], cnt[N]; // cnt计数每个点第几次遇到
bool vis[N];
void add(int h[], int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
void djs() {
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, T});
    memset(dist, 0x3f, sizeof(dist));
    dist[T] = 0;
    while (heap.size()) {
        auto k = heap.top();
        heap.pop();
        if (vis[k.second]) continue;
        vis[k.second] = 1;
        for (int i = rh[k.second]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > k.first + w[i]) {
                dist[j] = k.first + w[i];
                heap.push({dist[j], j});
            }
        }
    }
}
int a_star() {
    priority_queue<PIII, vector<PIII>, greater<PIII>> heap;
    heap.push({dist[S], {0, S}});
    while (heap.size()) {
        auto k = heap.top();
        heap.pop();
        int ver = k.second.second, distance = k.second.first;
        cnt[ver]++;
        if (cnt[T] == K) return distance;
        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i];
            if (cnt[j] < K) heap.push({distance + w[i] + dist[j], {distance + w[i], j}});
        }
    }
    return -1;
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    memset(rh, -1, sizeof(rh));
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(h, a, b, c);
        add(rh, b, a, c);
    }
    cin >> S >> T >> K;
    if (S == T) K++; // 起点和终点重合，且必须有边
    djs();
    cout << a_star() << '\n';
}   
```

### Kruskal

#### 最小生成树
$O(mlog(m))$ 适合稀疏图
```cpp
int n, m;   
int p[N], ra[N];
struct Edge {
    int a, b, w;
    bool operator< (const Edge &W) const {
        return w < W.w;
    }
} e[M];
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
int kruskal() {
    sort(e, e + m);
    for (int i = 1; i <= n; i++) p[i] = i; 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i++) {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b) {
            if (ra[a] <= ra[b]) {
                p[a] = b;
                if (ra[a] == ra[b]) ra[b]++;
            }
            else p[b] = a;
            res += w;
            cnt++ ;
        }
    }
    if (cnt < n - 1) return INF;
    return res;
}
``` 

#### Kruskal 重构树
无向图 𝐺 的瓶颈生成树是这样的一个生成树，它的最大的边权值在 𝐺 的所有生成树中最小<br>
最小生成树一定是瓶颈生成树，而瓶颈生成树不一定是最小生成树<br>
原图中两个点之间的所有简单路径上最大边权的最小值 = 最小生成树上两个点之间的简单路径上的最大值 = Kruskal 重构树上两点之间的 LCA 的权值。 <br>
原图中两个点之间的所有简单路径上最小边权的最大值 则从大到小加边 <br>
原图中两个点之间的所有简单路径上最大边权的最小值 则从小到大加边 <br>
```cpp
int n, m, q;
int p[N], a[N], f[N][20], dep[N];
bool vis[N];
vector<int> E[N];
struct edge {
    int u, v, w;
} e[N];
bool cmp(edge a, edge b) {
	return a.w > b.w;
}
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
void dfs(int u, int fa) {
	vis[u] = 1;
	f[u][0] = fa;
	dep[u] = dep[fa] + 1;
	for(auto &v : E[u]) {
		if(v == fa) continue;
		dfs(v, u);
	}
}
int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	int d = dep[u] - dep[v];
	for (int i = 19; i >= 0;i--) {
		if (d >> i & 1) {
            u = f[u][i];
        }
	}
	if(u == v) return u;
	for (int i = 19; i >= 0;i--) {
		if (f[u][i] != f[v][i]) {
            u = f[u][i], v = f[v][i];
        }
	}
	return f[u][0];
}
void solve() {
    cin >> n >> m >> q;
    for (int i = 1; i <= n + m; i++) p[i] = i;
    for (int i = 1; i <= m; i++) cin >> e[i].u >> e[i].v >> e[i].w;
    sort(e + 1, e + m + 1, cmp);
    int cur = n;
	for(int i = 1; i <= m; i++) { 
		int u = e[i].u, v = e[i].v, w = e[i].w;
		u = find(u), v = find(v);
		if (u == v) continue;
		++cur;
		p[u] = p[v] = cur;
		E[cur].push_back(u);
		E[cur].push_back(v);
		a[cur] = w;
	}
	for (int i = cur; i >= 1; i--) {
		if (!vis[i]) {
            dfs(i, 0);
        }
	}
	for (int j = 1; j < 20; j++) {
		for (int i = 1; i <= cur; i++) {
			f[i][j] = f[f[i][j - 1]][j - 1];
		}
	}
    while (q--) {
        int u, v;
		cin >> u >> v;
		if (find(u) != find(v)) {
			cout << -1 << '\n';
			continue;
		}
		cout << a[lca(u, v)] << '\n';
	}
}
```

### LCA

#### 倍增求 LCA
```cpp
int n, m, root;
int depth[N], fa[N][20];
vector<int> adj[N];
void bfs(int root) {
    memset(depth, 0x3f, sizeof(depth));
    depth[0] = 0, depth[root] = 1;
    queue<int> q;
    q.push(root);
    while (q.size()) {
        auto k = q.front();
        q.pop();
        for (auto v : adj[k]) {
            if (depth[v] > depth[k] + 1) {
                depth[v] = depth[k] + 1;
                q.push(v);
                fa[v][0] = k;
                for (int t = 1; t <= 19; t++) fa[v][t] = fa[fa[v][t - 1]][t - 1];
            }
        }
    }
}
int lca(int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 19; k >= 0; k--) {
        if (depth[fa[a][k]] >= depth[b]) a = fa[a][k];
    }
    if (a == b) return a;
    for (int k = 19; k >= 0; k--) {
        if (fa[a][k] != fa[b][k]) {
            a = fa[a][k];
            b = fa[b][k];
        }
    }
    return fa[a][0];
}
```

#### 离线 tarjan 求 LCA
```cpp
void solve() {
    int n, m, root;
    cin >> n >> m >> root;
    vector<vector<int>> adj(n + 1);
    vector<vector<pair<int, int>>> query(n + 1);
    vector<int> ans(m + 1, -1), p(n + 1), vis(n + 1, 0);
    for (int i = 1; i <= n - 1; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].emplace_back(b);
        adj[b].emplace_back(a);
    }
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        if (a != b) { 
            query[a].emplace_back(b, i);
            query[b].emplace_back(a, i);
        }
        if (a == b) ans[i] = a; // 注意特判 a == b 的情况
    }
    for (int i = 1; i <= n; i++) p[i] = i;

    auto find = [&](auto &&find, int x) -> int {
        if (p[x] != x) p[x] = find(find, p[x]);
        return p[x]; 
    };
    auto tarjan = [&](auto &&tarjan, int u) -> void {
        vis[u] = 1;
        for (auto &v : adj[u]) {
            if (!vis[v]) {
                tarjan(tarjan, v);
                p[v] = u;
            }
        }
        for (auto &[v, id] : query[u]) {
            if (vis[v] == 2) {
                int anc = find(find, v);
                ans[id] = anc;
            }
        }
        vis[u] = 2;
    };
    tarjan(tarjan, root);
    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
}
```

### Prim

#### 朴素 Prim $O(n^2)$ 适合稠密图
```cpp
int n;      
int g[N][N];    // 邻接矩阵，存储所有边
int dist[N];    // 存储其他点到当前最小生成树的距离
bool vis[N];     // 存储每个点是否已经在生成树中
// 如果图不连通，则返回 INF, 否则返回最小生成树的树边权重之和
int prim() {
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    int res = 0;
    for (int i = 1; i <= n; i++) {
        int t = -1;
        for (int j = 1; j <= n; j++) {
            if (!vis[j] && (t == -1 || dist[t] > dist[j])) {
                t = j;
            }
        }
        if (i && dist[t] == INF) return INF;
        if (i) res += dist[t];
        vis[t] = true;
        for (int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}
```

#### 堆优化 prim 不如 kruskal
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<pair<int, int>>> adj(n + 1);
    vector<int> d(n + 1, 1e9), vis(n + 1, 0);
    for (int i = 1; i <= m; i++) {
        int x, y, z;
        cin >> x >> y >> z;
        adj[x].push_back({z, y});
        adj[y].push_back({z, x});
    }
    int cnt = 0, ans = 0;
    d[1] = 0;
    priority_queue<array<int, 2>> q;
    q.push({0, 1});
    while (!q.empty()) {
        auto [val, u] = q.top();
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        val = -val;
        if (val < 1e9 / 2) {
            cnt++;
            ans += val;
        }
        for (auto [w, v] : adj[u]) {
            if (d[v] > w) {
                d[v] = w;
                q.push({-d[v], v});
            }
        }
    }
    if (cnt != n) cout << "-1" << '\n';
    else cout << ans << '\n';
}
```

### prufer
将一个带标号 n 个结点的树用 [1, n] 中的 n - 2 个整数表示 <br>
完全图有 n^(n - 2) 棵生成树 <br>
k 个连通块添加 k - 1 条边连通的方案数为 n^(k-2) * s1 * s2 * s3... * sk <br>
```cpp
int n, m;
int f[N], d[N], p[N];
void tree2prufer() {
    for (int i = 1; i < n; i++) {
        cin >> f[i];
        d[f[i]]++;
    }
    for (int i = 0, j = 1; i < n - 2; j++) {
        while (d[j]) j++;
        p[i++] = f[j];
        while (i < n - 2 && --d[p[i - 1]] == 0 && p[i - 1] < j) p[i++] = f[p[i - 1]]; 
    }
    for (int i = 0; i < n - 2; i++) cout << p[i] << ' ';
}
void prufer2tree() {
    for (int i = 1; i <= n - 2; i++) {
        cin >> p[i];
        d[p[i]]++;
    }
    p[n - 1] = n;
    for (int i = 1, j = 1; i < n; i++, j++) {
        while (d[j]) j++;
        f[j] = p[i];
        while (i < n - 1 && --d[p[i]] == 0 && p[i] < j) f[p[i]] = p[i + 1], i++; 
    }
    for (int i = 1; i <= n - 1; i++) cout << f[i] << ' ';
}
void solve() {
    cin >> n >> m;
    if (m == 1) tree2prufer();
    else prufer2tree();
}
```

### SPFA

#### SPFA 求最短路
最坏 $O(n * m)$
```cpp
vector<pair<int, int>> g[N];
int dist[N];
bool vis[N];
void spfa(int u) {
    queue<int> q;
    memset(dist, 0x3f, sizeof(dist));
    dist[u] = 0;
    vis[u] = 1;
    q.push(u);
    while (!q.empty()) {
        auto k = q.front();
        q.pop();
        vis[k] = 0;
        for (auto &[v, w] : g[k]) {
            if (dist[v] > dist[k] + w) {
                dist[v] = dist[k] + w;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                }
            }
        }
    }
}
```

#### 判断负环
需要建立虚拟源点，保证可以走到所有点
```cpp
bool spfa() {
    memset(dist, 0x3f, sizeof(dist));
    memset(cnt, 0, sizeof(cnt));
    stack<int> q;
    for (int i = 1; i <= n; i++) {
        q.push(i);
        vis[i] = 1;
    }
    while (q.size()) {
        auto u = q.top();
        q.pop();
        vis[u] = 0;
        for (auto &[v, w] : g[u]) {
            if (dist[v] > dist[u] + w) { // 找正环时将不等号改为小于即可
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return 1;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                }
            }
        }
    }
    return 0;
}
```

### 同余最短路
可以跑 SPFA，可以保证时间复杂度

### 树的重心
重心定义：
1. 最大子树的节点数最小
2. 每颗子树的节点数不超过总节点数的一半
3. 所有节点走向重心的总边数最小 

重心性质：
1. 一棵树最多两个重心，且相邻
2. 树上增加或删除一个叶子节点，重心最多移动一条边
3. 两棵树连起来，新树重心一定在原来两棵树重心的路径上
4. 树上的边权如果都大于等于零，所有节点都走向重心的距离和最小
5. 如果点有权重，那么所有节点都走向加权重心的距离和最小

```cpp
void solve() {
    int n;
    cin >> n;
    vector<vector<int>> adj(n + 1);
    vector<int> sz(n + 1, 1), mx(n + 1, 0);
    for (int i = 1; i <= n - 1; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    auto dfs = [&](auto &&dfs, int u, int fa) -> void {
        for (auto &v : adj[u]) {
            if (v == fa) continue;
            dfs(dfs, v, u);
            sz[u] += sz[v];
            mx[u] = max(mx[u], sz[v]);
        }  
        mx[u] = max(mx[u], n - sz[u]);
    };
    dfs(dfs, 1, 0);
    int now = n + 1;
    vector<int> ans;
    for (int i = 1; i <= n; i++) {
        if (mx[i] == now) ans.push_back(i);
        else if (mx[i] < now) {
            ans.clear();
            now = mx[i];
            ans.push_back(i);
        }
    }
    for (auto u : ans) cout << u << ' ';
}
```

### 树的直径
定义：树上距离最远的两个点，形成的路径 <br>
两种求法：1：两次 dfs, 适用于边权非负 2：树形 dp 适用于所有树 <br>
性质（边权都为正）：
1. 如果有多条直径，那么这些直径一定拥有共同的中间部分，可能是一个公共点或公共路径
2. 树上任意一点，相隔最远的点的集合，直径的两端点至少有一个在其中
3. 两颗无边权树合并，新的直径的最小值是 $max({h[x], h[y], (h[x] + 1) / 2 + (h[y] + 1) / 2 + 1})$

#### dp 求树的直径
```cpp
void solve() {
    int n;
    cin >> n;
    vector<vector<pair<i64, i64>>> adj(n + 1);
    vector<vector<i64>> dp(n + 1, vector<i64> (2, 0)); // dp[i][0] 单叉链的结尾 dp[i][1] 双叉链的中间节点
    for (int i = 1; i <= n - 1; i++) {
        i64 a, b, c;
        cin >> a >> b >> c;
        adj[a].emplace_back(b, c);
        adj[b].emplace_back(a, c);
    }
    auto dfs = [&](auto &&dfs, int u, int fa) -> void {
        dp[u][0] = 0, dp[u];
        for (auto &[v, w] : adj[u]) {
            if (v == fa) continue;
            dfs(dfs, v, u);
            dp[u][1] = max(dp[u][1], dp[u][0] + dp[v][0] + w);
            dp[u][0] = max(dp[u][0], dp[v][0] + w);
        }
    };
    dfs(dfs, 1, 0);
    i64 ans = 0;
    for (int i = 1; i <= n; i++) ans = max({ans, dp[i][0], dp[i][1]});
    cout << ans << '\n';
}
```

#### 求树的直径的公共部分
```cpp
void solve() {
    int n;
    cin >> n;
    vector<vector<pair<int, int>>> adj(n + 1);
    vector<i64> dis(n + 1, -1), mxdis(n + 1, -1); // dis 是到起点的距离 mxdis 是不走直径点的最大深度
    vector<bool> vis(n + 1, 0);
    vector<int> la(n + 1), ne(n + 1);
    for (int i = 1; i <= n - 1; i++) {
        int x, y, z;
        cin >> x >> y >> z;
        adj[x].push_back({y, z});
        adj[y].push_back({x, z});
    }
    int st, ed;
    i64 d = -1;
    auto dfs1 = [&](auto &&dfs1, int u, int fa, i64 tmpd) -> void {
        if (tmpd > d) {
            st = u;
            d = tmpd;
        }
        for (auto &[v, w] : adj[u]) {
            if (v == fa || vis[v]) continue;
            vis[v] = 1;
            dfs1(dfs1, v, u, tmpd + w);
        }
    };
    auto dfs2 = [&](auto &&dfs2, int u, int fa, i64 tmpd) -> void {
        la[u] = fa;
        dis[u] = tmpd;
        if (tmpd > d) {
            d = tmpd;
            ed = u;
        }
        for (auto &[v, w] : adj[u]) {
            if (v == fa) continue;
            dfs2(dfs2, v, u, tmpd + w);
        }
    };
    dfs1(dfs1, 1, 0, 0);
    d = -1;
    dfs2(dfs2, st, 0, 0);
    for (int i = 1; i <= n; i++) vis[i] = 0;
    for (int i = ed; i != 0; i = la[i]) vis[i] = 1;
    for (int i = ed; i != 0; i = la[i]) {
        d = -1;
        dfs1(dfs1, i, 0, 0);
        mxdis[i] = d;
    }
    for (int i = la[ed], j = ed; i != 0; i = la[i]) {
        ne[i] = j;
        j = i;
    } 
    int l, r, edgenum = 0;
    for (int i = st; i != 0; i = ne[i]) {
        if (dis[ed] - dis[i] == mxdis[i]) {
            r = i;
            break;
        }
    }
    for (int i = r; i != 0; i = la[i]) {
        if (dis[i] == mxdis[i]) {
            l = i;
            break;
        }
        else edgenum++;
    }
    cout << dis[ed] << '\n' << edgenum;
}
```