## 网络流
点只走一次 拆点 拆成的两个点之间的边容量为一 <br>
边只走一次 边容量设为一 <br>

### 最大流模板

#### EK 求最大流 O(nm^2)
```cpp
int n, m, S, T;
int h[N], e[M], ne[M], idx; 
LL f[M], d[N];
int pre[N];
bool vis[N];
void add(int a, int b, LL c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
bool bfs() {
    queue<int> q;
    memset(vis, 0, sizeof(vis));
    q.push(S), vis[S] = 1, d[S] = INF;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i]) {
            int ver = e[i];
            if (!vis[ver] && f[i]) {
                vis[ver] = 1;
                d[ver] = min(d[t], f[i]);
                pre[ver] = i;
                q.push(ver);
                if (ver == T) return 1;
            }
        }
    }
    return 0;
}
LL EK() {
    LL r = 0;
    while (bfs()) {
        r += d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1]) {
            f[pre[i]] -= d[T];
            f[pre[i] ^ 1] += d[T];
        }
    }
    return r;
}
void solve() {
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof(h));
    while (m--) {
        int a, b;
        LL c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    cout << EK() << '\n';
}  
```

#### Dinic 求最大流 O(n^2m)
在单位容量的网络上，Dinic 算法的总时间复杂度是 O(m * min(m^(1/2), n^(2/3))) <br>
对于二分图 Dinic 算法的总时间复杂度是 O(m * n^0.5)
```cpp
int n, m, S, T;
int h[N], e[M], ne[M], idx;
LL f[M], d[N];
int cur[N];
void add(int a, int b, LL c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;    
}
bool bfs() {
    queue<int> q;
    memset(d, -1, sizeof(d));
    q.push(S), d[S] = 0, cur[S] = h[S];
    while (q.size()) {
        auto t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i]) {
            int ver = e[i];
            if (d[ver] == -1 && f[i]) {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                q.push(ver);
                if (ver == T) return 1;
            }
        }
    }
    return 0;
}
LL find(int u, LL limit) {
    if (u == T) return limit;
    LL flow = 0;
    for (int i = cur[u]; i != -1 && flow < limit; i = ne[i]) {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i]) {
            LL t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        } 
    }
    return flow;
}
LL dinic() {
    LL r = 0, flow;
    while (bfs()) {
        while (flow = find(S, INF)) r += flow;
    }
    return r;
}
void solve() {
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof(h));
    while (m--) {
        int a, b;
        LL c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    cout << dinic() << '\n';
}   
```

### 费用流模板
最小费用最大流，只能在不存在负权回路时使用，最大费用最大流只需将边权取反最后将答案取反 <br>

#### EK 求费用流 
O(nmf) f 是最大流
```cpp
int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int d[N], pre[N], incf[N], st[N];
void add(int a, int b, int c, int d) {
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;
}
bool spfa() {
    queue<int> q;
    memset(d, 0x3f, sizeof(d));
    memset(incf, 0, sizeof(incf));
    memset(st, 0, sizeof(st));
    q.push(S), d[S] = 0, incf[S] = INF;
    while (q.size()) {
        auto t = q.front();
        q.pop();
        st[t] = 0;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int ver = e[i];
            if (f[i] && d[ver] > d[t] + w[i]) {
                d[ver] = d[t] + w[i];
                pre[ver] = i;
                incf[ver] = min(f[i], incf[t]);
                if (!st[ver]) {
                    st[ver] = 1;
                    q.push(ver);
                }
            } 
        }
    }
    return incf[T] > 0;
    // 可行费用流 
    // return d[T] < 0; 
}
void EK(int &flow, int &cost) {
    flow = cost = 0;
    while (spfa()) {
        int t = incf[T];
        flow += t, cost += t * d[T];
        for (int i = T; i != S; i = e[pre[i] ^ 1]) {
            f[pre[i]] -= t;
            f[pre[i] ^ 1] += t;
        }
    }
}
void solve() {
    cin >> n >> m >> S >> T;
    memset(h, -1, sizeof(h));
    while (m--) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, c, d);
    }
    int flow, cost;
    EK(flow, cost);
    cout << flow << ' ' << cost << '\n';
}
```

#### 原始对偶 
O(mf logn) f 是最大流 <br>
注意更新范围
```cpp
struct edge {
    int v, f, next;
    int c;
    // long double c;
} e[M];
struct node {
  int v, e;
} p[N];
struct mypair {
    int dis;
    // long double dis;
    int id;
    bool operator<(const mypair& a) const { return dis > a.dis; }
    mypair(int d, int x) { dis = d, id = x; }
    // mypair(long double d, int x) { dis = d, id = x; }
};
int head[N], vis[N];
int dis[N], h[N];
// long double dis[N], h[N];
int n, m, s, t, cnt = 1, maxf;
int minc;
// long double minc;
void addedge(int u, int v, int f, int c) { // or long double c
    e[++cnt].v = v;
    e[cnt].f = f;
    e[cnt].c = c;
    e[cnt].next = head[u];
    head[u] = cnt;
}
bool dijkstra() {
    priority_queue<mypair> q;
    for (int i = 1; i <= n; i++) dis[i] = INF; // 注意更新范围*********
    memset(vis, 0, sizeof(vis));
    dis[s] = 0;
    q.push(mypair(0, s));
    while (!q.empty()) {
        int u = q.top().id;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v, nc = e[i].c + h[u] - h[v];
            if (e[i].f && dis[v] > dis[u] + nc) {
                dis[v] = dis[u] + nc;
                p[v].v = u;
                p[v].e = i;
                if (!vis[v]) q.push(mypair(dis[v], v));
            }
        }
    }
    return dis[t] != INF;
}
void spfa() {
    queue<int> q;
    memset(h, 0x3f, sizeof(h));
    h[s] = 0, vis[s] = 1;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (e[i].f && h[v] > h[u] + e[i].c) {
                h[v] = h[u] + e[i].c;
                if (!vis[v]) {
                    vis[v] = 1;
                    q.push(v);
                }   
            }
        }
    }
}
void work() {
    spfa();  // 先求出初始势能
    while (dijkstra()) {
        int minf = INF;
        for (int i = 1; i <= n; i++) h[i] += dis[i];  // 注意**********
        for (int i = t; i != s; i = p[i].v) minf = min(minf, e[p[i].e].f);
        for (int i = t; i != s; i = p[i].v) {
            e[p[i].e].f -= minf;
            e[p[i].e ^ 1].f += minf;
        }
        maxf += minf;
        minc += minf * h[t];
    }
}
void solve() {
    cin >> n >> m >> s >> t;
    for (int i = 1; i <= m; i++) {
        int u, v, f, c;
        cin >> u >> v >> f >> c;
        addedge(u, v, f, c);
        addedge(v, u, 0, -c);
    }
    work();
    cout << maxf << ' ' << minc << '\n';
}
```

### 点覆盖、独立集
源点向起点连权值边，终点向汇点连权值边，内部边容量为 INF <br>
最大权独立集 = 总权值 - 最小权点覆盖 <br>
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N];
bool st[N];
void dfs(int u) { // 求方案
    st[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        if (f[i] && !st[e[i]]) {
            dfs(e[i]);
        } 
    }
}
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    cin >> n >> m;
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof(h));
    for (int i = 1; i <= n; i++) {
        int w;
        cin >> w;
        add(S, i, w);
    }
    for (int i = 1; i <= n; i++) {
        int w;
        cin >> w;
        add(n + i, T, w);
    }
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(b, n + a, INF);
    }
    cout << dinic() << '\n';
    dfs(S);
    int cnt = 0;
    for (int i = 0; i < idx; i += 2) {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b]) cnt++;  
    }
    cout << cnt << '\n';
    for (int i = 0; i < idx; i += 2) {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b]) {
            if (a == S) cout << b << " +" << '\n';
        }
    }
    for (int i = 0; i < idx; i += 2) {
        int a = e[i ^ 1], b = e[i];
        if (st[a] && !st[b]) {
            if (b == T) cout << a - n << " -" << '\n';
        }
    }
}
```

### 点连通度
拆点后枚举源点和汇点跑最小割
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    cin >> n >> m;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < n; i++) add(i, n + i, 1);
    while (m--) {
        int x, y;
        cin >> x >> y;
        add(n + x, y, INF), add(n + y, x, INF);
    }
    int res = n;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            S = n + i, T = j;
            for (int k = 0; k < idx; k += 2) {
                f[k] += f[k ^ 1];
                f[k ^ 1] = 0;
            }
            res = min(res, dinic());
        }
    }
    cout << res << '\n';
}
```

### 二分图匹配和方案

#### 二分图最大匹配
O(mn^0.5)
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    cin >> m >> n;
    S = 0, T = n + 1;
    memset(h, -1, sizeof(h));
    for (int i = 1; i <= m; i++) add(S, i, 1);
    for (int i = m + 1; i <= n; i++) add(i, T, 1);
    int a, b;
    while (cin >> a >> b, a != -1) add(a, b, 1);
    cout << dinic() << '\n';     
    for (int i = 0; i < idx; i += 2) {
        if (e[i] > m && e[i] <= n && !f[i]) {
            cout << e[i ^ 1] << ' ' << e[i] << '\n';
        }
    }
}   
```

#### 二分图多重匹配
允许每个点与多条边匹配，但有容量限制
```cpp
int m, n, S, T;
int h[N], e[M], ne[M], f[M], idx;
int d[N], cur[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    cin >> m >> n;
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof(h));
    int tot = 0;
    for (int i = 1; i <= m; i++) {
        int c;
        cin >> c;
        add(S, i, c);
        tot += c;
    }
    for (int i = 1; i <= n; i++) {
        int c;
        cin >> c;
        add(m + i, T, c);
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) add(i, m + j, 1);
    }
    if (dinic() != tot) cout << 0 << '\n';
    else {
        cout << 1 << '\n';
        for (int i = 1; i <= m; i++) {
            for (int j = h[i]; j != -1; j = ne[j]) {
                if (e[j] > m && e[j] <= m + n && !f[j]) {
                    cout << e[j] - m << ' ';
                }
            }
            cout << '\n';
        }
    }
}   
```

#### 二分图最大权匹配
不仅要找最多的匹配，还要让匹配边的权值和最大
```cpp
int n, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int d[N], pre[N], incf[N];
bool st[N];
void add(int a, int b, int c, int d) {
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    cin >> n;
    S = 0, T = n * 2 + 1;
    memset(h, -1, sizeof(h));
    for (int i = 1; i <= n; i++) {
        add(S, i, 1, 0);
        add(n + i, T, 1, 0);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int c;
            cin >> c;
            add(i, n + j, 1, c);
        }
    }
    int ansmin, ansmax;
    int flow, cost;
    EK(flow, cost);
    ansmin = cost;
    for (int i = 0; i < idx; i += 2) {
        f[i] += f[i ^ 1], f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];
    }
    EK(flow, cost);
    ansmax = -cost;
    cout << ansmin << '\n';
    cout << ansmax << '\n';
}
```

### 多源汇最大流
建超级源点和汇点，所有超级源点向所有源点连边，所有汇点向超级汇点连边
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    int sc, tc;
    cin >> n >> m >> sc >> tc;
    S = 0, T = n + 1;
    memset(h, -1, sizeof(h));
    while (sc--) {
        int x;
        cin >> x;
        add(S, x, INF);
    }
    while (tc--) {
        int x;
        cin >> x;
        add(x, T, INF);
    }
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    cout << dinic() << '\n';
}   
```

### 多源汇费用流
```cpp
int n, m, S, T;
int h[N], e[M], f[M], w[M], ne[M], idx;
int d[N], pre[N], incf[N];
bool st[N];
void add(int a, int b, int c, int d) {
    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    cin >> m >> n;
    S = 0, T = m + n + 1;
    memset(h, -1, sizeof(h));
    for (int i = 1; i <= m; i++) {
        int a;
        cin >> a;
        add(S, i, a, 0);
    }
    for (int i = 1; i <= n; i++) {
        int a;
        cin >> a;
        add(m + i, T, a, 0);
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            int c;
            cin >> c;
            add(i, m + j, INF, c);
        }
    }
    int flow, cost;
    EK(flow, cost);
    cout << cost << '\n'; // 最小费用
    
    for (int i = 0; i < idx; i += 2) {
        f[i] += f[i ^ 1];
        f[i ^ 1] = 0;
        w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];  
    } 
    EK(flow, cost);
    cout << -cost << '\n'; // 最大费用
}
```

### 上下界可行流

#### 无源汇上下界可行流
```cpp
int n, m, S, T;
int h[N], e[M], f[M], l[M], ne[M], idx;
int d[N], cur[N], A[N];
void add(int a, int b, int c, int d) { // c:下界，d:上界
    e[idx] = b, f[idx] = d - c, l[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    cin >> n >> m;
    S = 0, T = n + 1;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, c, d);
        A[a] -= c, A[b] += c;
    }
    int tot = 0;
    for (int i = 1; i <= n; i++) {
        if (A[i] > 0) {
            add(S, i, 0, A[i]);
            tot += A[i];
        }
        else if (A[i] < 0) add(i, T, 0, -A[i]);
    }
    if (dinic() != tot) cout << "NO" << '\n';
    else {
        cout << "YES" << '\n';
        for (int i = 0; i < m * 2; i += 2) cout << f[i ^ 1] + l[i] << '\n';
    }
}   
```

#### 有源汇上下界最大流
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N], A[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    int s, t;
    cin >> n >> m >> s >> t;
    S = 0, T = n + 1;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }    
    int tot = 0;
    for (int i = 1; i <= n; i++) {
        if (A[i] > 0) {
            add(S, i, A[i]);
            tot += A[i];
        }
        else if (A[i] < 0) add(i, T, -A[i]);
    }
    add(t, s, INF);
    if (dinic() < tot) cout << "No Solution" << '\n';
    else {
        int res = f[idx - 1];
        S = s, T = t;
        f[idx - 1] = f[idx - 2] = 0;
        cout << res + dinic() << '\n';
    }
}   
```

#### 有源汇上下界最小流
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N], A[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void solve() {
    int s, t;
    cin >> n >> m >> s >> t;
    S = 0, T = n + 1;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, d - c);
        A[a] -= c, A[b] += c;
    }    
    int tot = 0;
    for (int i = 1; i <= n; i++) {
        if (A[i] > 0) {
            add(S, i, A[i]);
            tot += A[i];
        }
        else if (A[i] < 0) add(i, T, -A[i]);
    }
    add(t, s, INF);
    if (dinic() < tot) cout << "No Solution" << '\n';
    else {
        int res = f[idx - 1];
        S = t, T = s;
        f[idx - 1] = f[idx - 2] = 0;
        cout << res - dinic() << '\n';
    }
}   
```

### 最大流关键边

#### 求关键边数量
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N];
bool vis_s[N], vis_t[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void dfs(int u, bool st[], int t) {
    st[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = i ^ t;
        int ver = e[i];
        if (f[j] && !st[ver]) dfs(ver, st, t);
    }
}
void solve() {
    cin >> n >> m;
    S = 0, T = n - 1;
    memset(h, -1, sizeof(h));
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    dinic();
    dfs(S, vis_s, 0);
    dfs(T, vis_t, 1);
    int res = 0;
    for (int i = 0; i < m * 2; i += 2) {
        if (!f[i] && vis_s[e[i ^ 1]] && vis_t[e[i]]) { 
            res++;
        }
    }
    cout << res << '\n';
}   
```

### 最大密度子图
边的数量 (E + V * 2) * 2 <br>
无点权无边权 <br>
```cpp
int n, m, S, T;
int h[N], e[M], ne[M], idx;
double f[M];
int d[N], cur[N];
int dg[N];
struct Edge {
    int a, b;
}edges[M];
int ans;
bool st[N];
void add(int a, int b, double c1, double c2) {
    e[idx] = b, f[idx] = c1, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = c2, ne[idx] = h[b], h[b] = idx++;
}
bool bfs() {
    queue<int> q;
    memset(d, -1, sizeof(d));
    q.push(S), d[S] = 0, cur[S] = h[S];
    while (q.size()) {
        auto t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i]) {
            int ver = e[i];
            if (d[ver] == -1 && f[i] > 0) {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                q.push(ver);
                if (ver == T) return 1;
            }
        }
    }
    return 0;
}
double find(int u, double limit) {
    if (u == T) return limit;
    double flow = 0;
    for (int i = cur[u]; i != -1 && flow < limit; i = ne[i]) {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i] > 0) {
            double t = find(ver, min(f[i], limit - flow));
            if (t < eps) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        } 
    }
    return flow;
}
void build(double g) {
    memset(h, -1, sizeof(h));
    idx = 0;
    for (int i = 0; i < m; i++) add(edges[i].a, edges[i].b, 1, 1);
    for (int i = 1; i <= n; i++) {
        add(S, i, m, 0);
        add(i, T, m + 2 * g - dg[i], 0);
    }
}
double dinic(double g) {
    build(g);
    double r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r; 
}
void dfs(int u) {
    st[u] = 1;
    if (u != S) ans++;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int ver = e[i];
        if (!st[ver] && f[i] > 0) dfs(ver);
    }
}
void solve() {
    cin >> n >> m;
    S = 0, T = n + 1;
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        dg[a]++, dg[b]++;
        edges[i] = {a, b};
    }
    double l = 0, r = m;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        double t = dinic(mid);
        if (m * n - t > 0) l = mid;
        else r = mid;
    }
    dinic(l);
    dfs(S);
    if (!ans) {
        cout << 1 << '\n';
        cout << 1 << '\n';
        return;
    }
    cout << ans << '\n';
    for (int i = 1; i <= n; i++) {
        if (st[i]) cout << i << '\n';
    }
}
```

### 最大权闭合子图
最大权为 正权和 - 最小割 <br>
源点向正权点连权值边，负权点向汇点连权值的绝对值，有向图原来的边的权值为无限大 <br>
```cpp
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N];
void add(int a, int b, int c) {
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
}
void dfs(int u) {
    st[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        if (!st[e[i]] && f[i]) {
            dfs(e[i]);
        }
    }
}
void solve() {
    cin >> n >> m;
    S = 0, T = n + m + 1;
    memset(h, -1, sizeof(h));
    for (int i = 1; i <= n; i++) {
        int p;
        cin >> p;
        add(m + i, T, p);
    }    
    int tot = 0;
    for (int i = 1; i <= m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(S, i, c);
        add(i, m + a, INF);
        add(i, m + b, INF);
        tot += c;
    }
    cout << tot - dinic() << '\n';
    dfs(S); // 求方案
    for (int i = 1; i <= m; i++) {
        if (st[i]) cout << i << ' ';
    }
    cout << '\n';
    for (int i = m + 1; i <= m + n; i++) {
        if (st[i]) cout << i - m << ' ';
    }
}
```