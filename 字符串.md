## å­—ç¬¦ä¸²

### æœ¬è´¨ä¸åŒçš„å­åºåˆ—
```cpp
// dp[i] å¼ºåˆ¶ä»¥ s[i] ä¸ºç»“å°¾å¾—æœ¬è´¨ä¸åŒå­åºåˆ—ä¸ªæ•°
vector<long long> pre(n + 1, 0), dp(n + 1, 0); 
vector<int> last(26, 0);
pre[0] = 1;
for (int i = 1; i <= n; i++) {
    int ch = s[i] - 'a';
    if (!last[ch]) dp[i] = pre[i - 1];
    else dp[i] = (pre[i - 1] - pre[last[ch] - 1]) % mod;
    pre[i] = (pre[i - 1] + dp[i]) % mod;
    last[ch] = i;
}
int ans = ((pre[n] - 1) % mod + mod) % mod;
```
```cpp
// dp[i] ä¸ºå‰ i ä¸ªå­—æ¯æ„æˆçš„æ‰€æœ‰æœ¬è´¨ä¸åŒå­åºåˆ—ä¸ªæ•°
vector<int> last(26, -1);
for (int i = 1; i <= n; i++) {
    dp[i] = (dp[i - 1] * 2 + 1) % mod;
    int ch = s[i] - 'a';
    if (last[ch] >= 0) dp[i] -= (dp[last[ch] - 1] + 1);
    dp[i] = (dp[i] % mod + mod) % mod;
    last[ch] = i;
}
```

### å›æ–‡è‡ªåŠ¨æœº
```cpp
namespace pam { // å½“éœ€è¦è·³å¤šæ¬¡æ—¶å¯ä»¥ä½¿ç”¨ oriï¼Œå’Œ ccnt æ¥è®°å½•ä¸Šæ¬¡çŠ¶æ€
    int sz, tot, last;
    int cnt[N], ch[N][26], len[N], fail[N]; // cnt æ˜¯ä»¥æ¯ä¸ªèŠ‚ç‚¹ç»“å°¾çš„å›æ–‡å­ä¸²ä¸ªæ•°ï¼Œlen æ˜¯æ¯ä¸ªå›æ–‡å­ä¸²çš„é•¿åº¦
    // int ori[N], ccnt[N];
    char s[N];
    int node(int l) {  // å»ºç«‹ä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼Œé•¿åº¦ä¸º l
        sz++;
        memset(ch[sz], 0, sizeof(ch[sz]));
        len[sz] = l;
        fail[sz] = cnt[sz] = 0;
        return sz;
    }
    void clear() {  // åˆå§‹åŒ–
        sz = -1;
        last = 0;
        s[tot = 0] = '$';
        node(0);
        node(-1);
        fail[0] = 1;
    }
    int getfail(int x) {  // æ‰¾åç¼€å›æ–‡
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }
    void insert(char c) {  // å»ºæ ‘
        s[++tot] = c;
        int now = getfail(last);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail(fail[now])][c - 'a'];
            ch[now][c - 'a'] = x;
            // cnt[x] = cnt[fail[x]] + 1; å¯ä»¥åœ¨å»ºç«‹çš„æ—¶å€™ç›´æ¥ç®—
        }
        last = ch[now][c - 'a'];
        cnt[last]++; // å¦‚æœåœ¨å»ºç«‹çš„æ—¶å€™ç®—éœ€è¦å»æ‰
    }
    long long solveans(bool ok, int n) { // ok = 1æ¢å¤ï¼Œ ok == 0æ­£å¸¸
        long long ans = 0;
        // for (int i = 0; i <= sz; i++) ori[i] = cnt[i];
        for (int i = sz; i >= 0; i--) cnt[fail[i]] += cnt[i];
        for (int i = 1; i <= sz; i++) {
            /*
            if (ok) {
                ccnt[i] = cnt[i];
                continue;
            }
            */
            for (int i = 1; i <= sz; i++) ans = max(ans, 1ll * len[i] * cnt[i]);
        }
        /*
        if (ok) {
            for (int i = 0; i <= sz; i++) {
                cnt[i] = ori[i];
            }
        }
        */
        return ans;
    }
} 
void solve() {
    int n;
    cin >> n;
    string s;
    cin >> s;
    pam::clear();
    for (auto i : s) pam::insert(i);
    cout << pam::solveans(0, s.size()) << "\n";
}
```

### å­—ç¬¦ä¸²å“ˆå¸Œ
```cpp
const int N = 1e5 + 10, base = 1331;
static const u64 mod = (1ull << 61) - 1;
u64 power[N];
static inline u64 add(u64 a, u64 b) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
}
static inline u64 sub(u64 a, u64 b) {
    return add(a, mod - b);
}
static inline u64 mul(u64 a, u64 b) {
    __uint128_t c = __uint128_t(a) * b;
    return add(c >> 61, c & mod);
}
u64 merge(u64 h1, u64 h2, int len) {
    return add(mul(h1, power[len]), h2);
}
u64 query(const vector<u64> &s, int l, int r) {
    return sub(s[r], mul(s[l - 1], power[r - l + 1]));
}
void init() {
    power[0] = 1;
    for (int i = 1; i < N; i++) power[i] = mul(power[i - 1], base);
}
vector<u64> build(const string &s) {
    int sz = s.size();
    vector<u64> hashed(sz + 1);
    for (int i = 0; i < sz; i++) hashed[i + 1] = add(mul(hashed[i], base), s[i]);
    return hashed;
}
```

### Manacher
```cpp
void solve() {
    string s, t;
    cin >> s;
    vector<int> p(2 * s.size() + 5);
    t += "$#";
    for (auto &u : s) {
        t += u;
        t += '#';
    }
    t += '^';
    int ans = 1;
    int maxr = 0, mid = 0;
    for (int i = 1; i + 1 < t.size(); i++) {
        if (i < maxr) p[i] = min(p[2 * mid - i], maxr - i);
        else p[i] = 1;
        while (t[i - p[i]] == t[i + p[i]]) p[i]++;
        if (i + p[i] > maxr) {
            maxr = i + p[i];
            mid = i;
        }
        if (i % 2 == 0) ans = max(ans, p[i] / 2 + p[i] / 2 - 1);
        else ans = max(ans, p[i] - 1);
    }
    cout << ans << '\n';
}
```

### $Z$å‡½æ•°
ğ‘§[ğ‘–] è¡¨ç¤º ğ‘  å’Œ ğ‘ [ğ‘–, ğ‘› âˆ’ 1]ï¼ˆå³ä»¥ ğ‘ [ğ‘–] å¼€å¤´çš„åç¼€ï¼‰çš„æœ€é•¿å…¬å…±å‰ç¼€ï¼ˆ$LCP$ï¼‰çš„é•¿åº¦
```cpp
vector<int> z_function(string s) { 
    int n = (int)s.size();
    vector<int> z(n);
    z[0] = n;
    for (int i = 1, l = 0, r = 0; i < n; i++) {
        if (i <= r && z[i - l] < r - i + 1) z[i] = z[i - l];
        else {
            z[i] = max(0, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;
        }
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}
```

### æœ€å°è¡¨ç¤ºæ³•

#### åˆ¤æ–­ä¸¤å­—ç¬¦ä¸²æœ€å°è¡¨ç¤ºæ³•æ˜¯å¦ç›¸åŒ
```cpp
int get_min(string s, int len) {
    int i = 0, j = 1;
    while (i < len && j < len) {
        int k = 0;
        while (k < len && s[i + k] == s[j + k]) k++;
        if (k == len) break;
        if (s[i + k] > s[j + k]) i += k + 1;
        else j += k + 1;
        if (i == j) j++;
    }
    int k = min(i, j);
    return k;
}
void solve() {
    string a, b;
    cin >> a >> b;
    int n = a.size(), m = b.size();
    a += a, b += b;
    int x = get_min(a, n), y = get_min(b, m);
    if (a.substr(x, n) != b.substr(y, m)) cout << "No" << '\n';
    else {
        cout << "Yes" << '\n';
        cout << a.substr(x, n) << '\n';
    }
}
```

### ACè‡ªåŠ¨æœº
$n$ ä¸ªæ¨¡å¼ä¸²å’Œä¸€ä¸ªæ–‡æœ¬ä¸², æ±‚æ¯ä¸ªæ¨¡å¼ä¸²åœ¨æ–‡æœ¬ä¸²é‡Œå‡ºç°è¿‡å‡ æ¬¡
```cpp
const int N = 2e5 + 10;
int n;
int tr[N][26], id[N], sz[N], fail[N], idx;
vector<int> g[N];
void insert(string str, int x) {
    int p = 0;
    for (int i = 0; i < str.size(); i++) {
        int u = str[i] - 'a';
        if (!tr[p][u]) tr[p][u] = ++idx;
        p = tr[p][u];
    }
    id[x] = p;
}
void build() {
    queue<int> q;
    for (int i = 0; i < 26; i++) {
        if (tr[0][i]) { 
            q.push(tr[0][i]);
        }
    }
    while (q.size()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++) {
            int p = tr[u][i];
            if (!p) tr[u][i] = tr[fail[u]][i];
            else {
                fail[p] = tr[fail[u]][i];
                q.push(p);
            }
        }
    }
}
void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        string str;
        cin >> str;
        insert(str, i);
    }
    build();
    string str;
    cin >> str;
    for (int i = 0, j = 0; i < str.size(); i++) {
        int u = str[i] - 'a';
        j = tr[j][u];
        sz[j]++; 
    }
    for (int i = 1; i <= idx; i++) g[fail[i]].push_back(i);
    auto dfs = [&](auto &&dfs, int u) -> void {
        for (auto v : g[u]) {
            dfs(dfs, v);
            sz[u] += sz[v]; 
        }
    };
    dfs(dfs, 0);
    for (int i = 1; i <= n; i++) cout << sz[id[i]] << '\n';
}
```

### KMP
å­—ç¬¦ä¸²çš„æœ€å°å¾ªç¯é•¿åº¦ = $m - ne[m]$ <br>
$p$ æ˜¯å‘¨æœŸï¼Œ$len(s) - p$ æ˜¯ $border$ <br>
$s$ æ˜¯æ–‡æœ¬ä¸²ï¼Œ$p$ æ˜¯æ¨¡å¼ä¸²ï¼Œ$n$ æ˜¯ $s$ çš„é•¿åº¦ï¼Œ$m$ æ˜¯ $p$ çš„é•¿åº¦ <br>
æ±‚æ¨¡å¼ä¸²çš„ Next æ•°ç»„ï¼š$ne[i]$ å°±æ˜¯æ¨¡å¼ä¸²å‰ç¼€ $i$ çš„ $border$ <br>
```cpp
for (int i = 2, j = 0; i <= m; i++) {
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j++;
    ne[i] = j;
}
```
åŒ¹é…
```cpp
for (int i = 1, j = 0; i <= n; i++) {
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j++;
    if (j == m) {
        j = ne[j];
        // åŒ¹é…æˆåŠŸåçš„é€»è¾‘
        // cout << i - m + 1 << '\n'; æ¨¡å¼ä¸²åœ¨æ–‡æœ¬ä¸²ä¸­çš„å¼€å¤´
    }
}
```

### SA
sa[i]:æ’åç¬¬ i ä½çš„æ˜¯ç¬¬å‡ ä¸ªåç¼€ï¼Œrk[i]ï¼šç¬¬ i ä¸ªåç¼€æ’ç¬¬å‡ ï¼Œheight[i]ï¼šsa[i] å’Œ sa[i - 1]çš„æœ€é•¿å…¬å…±å‰ç¼€ lcp(i - 1, i) <br>
lcp(i, j) = min(lcp(i, k), lcp(k, j)) i <= k <= j lcp(i, j) = min(lcp(i, i + 1), lcp(i + 1, ...), lcp(j - 1, j)) <br>
```cpp
const int N = 1000010;
int n, m;
string s;
int sa[N], x[N], y[N], c[N], rk[N], height[N];
void get_sa() {
    for (int i = 1; i <= n; i++) c[x[i] = s[i]]++;
    for (int i = 2; i <= m; i++) c[i] += c[i - 1];
    for (int i = n; i; i--) sa[c[x[i]]--] = i;
    for (int k = 1; k <= n; k <<= 1) {
        int num = 0;
        for (int i = n - k + 1; i <= n; i++) y[++num] = i;
        for (int i = 1; i <= n; i++) {
            if (sa[i] > k) {
                y[ ++ num] = sa[i] - k;
            }
        }
        for (int i = 1; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[x[i]]++ ;
        for (int i = 2; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i; i--) sa[c[x[y[i]]]--] = y[i], y[i] = 0;
        swap(x, y);
        x[sa[1]] = 1, num = 1;
        for (int i = 2; i <= n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? num : ++num;
        if (num == n) break;
        m = num;
    }
}
void get_height() {
    for (int i = 1; i <= n; i++) rk[sa[i]] = i;
    for (int i = 1, k = 0; i <= n; i++) {
        if (rk[i] == 1) continue;
        if (k) k--;
        int j = sa[rk[i] - 1];
        while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
        height[rk[i]] = k;
    }
}
void solve() {
    cin >> s;
    n = s.size(), m = 122;
    s = ' ' + s;
    get_sa();
    get_height();
    for (int i = 1; i <= n; i++) cout << sa[i] << ' ';
    cout << '\n';
    for (int i = 1; i <= n; i++) cout << height[i] << ' ';
}
```

#### æœ¬è´¨ä¸åŒçš„å­ä¸²
æ‰€æœ‰åç¼€çš„å‰ç¼€é›†åˆå°±æ˜¯æ‰€æœ‰å­ä¸²é›†åˆ <br>
ans = i from 1 - n (len[rk[i]] - height[rk[i]]) = n * (n + 1) / 2 - sum(height)

### SAM
SAM æ˜¯ä¸ªçŠ¶æ€æœºï¼ŒåŸä¸²çš„æ‰€æœ‰å­ä¸²å’Œä» SAM èµ·ç‚¹å¼€å§‹çš„æ‰€æœ‰è·¯å¾„ä¸€ä¸€å¯¹åº”ï¼Œæ‰€ä»¥ç»ˆç‚¹å°±æ˜¯åŒ…å«åç¼€çš„ç‚¹ã€‚<br>
æ¯ä¸ªç‚¹åŒ…å«è‹¥å¹²å­ä¸²ï¼Œæ¯ä¸ªå­ä¸²éƒ½ä¸€ä¸€å¯¹åº”ä¸€æ¡ä»èµ·ç‚¹åˆ°è¯¥ç‚¹çš„è·¯å¾„ã€‚ä¸”è¿™äº›å­ä¸²ä¸€å®šæ˜¯é‡Œé¢æœ€é•¿å­ä¸²çš„è¿ç»­åç¼€ã€‚ <br>
ä¸€ä¸ªçŠ¶æ€è¡¨ç¤ºçš„æ˜¯å‡ºç°ä½ç½®ç›¸åŒï¼Œä½†é•¿åº¦ä¸åŒçš„ä¸€ç³»åˆ—ä¸² <br>
endpos(s)ï¼šå­ä¸² s æ‰€æœ‰å‡ºç°çš„ä½ç½®ï¼ˆå°¾å­—æ¯ä¸‹æ ‡ï¼‰é›†åˆã€‚SAM ä¸­çš„æ¯ä¸ªçŠ¶æ€éƒ½ä¸€ä¸€å¯¹åº”ä¸€ä¸ª endpos çš„ç­‰ä»·ç±»ã€‚<br>
ä»¤ s1, s2 ä¸º S çš„ä¸¤ä¸ªå­ä¸²ï¼Œä¸å¦¨è®¾ |s1| â‰¤ |s2|ã€‚åˆ™ s1 æ˜¯ s2 çš„åç¼€å½“ä¸”ä»…å½“ endpos(s1) âŠ‡ endpos(s2)ï¼Œs1 ä¸æ˜¯ s2 çš„åç¼€å½“ä¸”ä»…å½“ endpos(s1) âˆ© endpos(s2) = âˆ… <br>
ä¸¤ä¸ªå­ä¸²çš„ endpos ç›¸åŒï¼Œé‚£ä¹ˆçŸ­ä¸²ä¸ºé•¿ä¸²çš„åç¼€ã€‚ <br>
å¯¹äºä¸€ä¸ªçŠ¶æ€ stï¼Œä»¥åŠä»»æ„çš„ longest(st) çš„åç¼€ sï¼Œå¦‚æœ s çš„é•¿åº¦æ»¡è¶³ï¼š|shortest(st)| â‰¤ |s| â‰¤ |longsest(st)|ï¼Œé‚£ä¹ˆ s âˆˆ substrings(st)ã€‚ <br>

#### æœ¬è´¨ä¸åŒå­ä¸²æ•°é‡
æ±‚å’Œ SAM ä¸Šæ¯ä¸ªç‚¹è¡¨ç¤ºçš„å­ä¸²æ•°é‡

#### å‡ºç°æ¬¡æ•°ä¸ä¸º 1 çš„å­ä¸²å‡ºç°æ¬¡æ•° * å­ä¸²é•¿åº¦çš„æœ€å¤§å€¼
æ¯ä¸ªå­ä¸²å‡ºç°çš„æ¬¡æ•°å°±æ˜¯å¯¹åº” endpos çš„å¤§å° <br>
node[u].len æ˜¯çŠ¶æ€ u æ‰€èƒ½è¡¨ç¤ºçš„æœ€é•¿å­ä¸²çš„é•¿åº¦ <br>
f[u] ä»¥çŠ¶æ€ u è¡¨ç¤ºçš„æ‰€æœ‰å­ä¸²ï¼Œåœ¨æ•´ä¸ªåŸä¸²ä¸­å‡ºç°äº†å¤šå°‘æ¬¡ <br>
```cpp
const int N = 2e6 + 10;
int tot = 1, last = 1;
struct Node {
    int len, fa;
    int ch[26];
} node[N];
string str;
LL f[N], ans;
vector<vector<int>> g(N);
void extend(int c) {
    int p = last, np = last = ++tot;
    f[tot] = 1;
    node[np].len = node[p].len + 1;
    for (; p && !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;
    if (!p) node[np].fa = 1;
    else {
        int q = node[p].ch[c];
        if (node[q].len == node[p].len + 1) node[np].fa = q;
        else {
            int nq = ++tot;
            node[nq] = node[q], node[nq].len = node[p].len + 1;
            node[q].fa = node[np].fa = nq;
            for (; p && node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;
        }
    }
}
void dfs(int u) { 
    for (auto v : g[u]) {
        dfs(v);
        f[u] += f[v];
    }
    if (f[u] > 1) ans = max(ans, f[u] * node[u].len);
}
void solve() {
    cin >> str;
    for (auto u : str) extend(u - 'a');
    for (int i = 2; i <= tot; i++) g[node[i].fa].push_back(i);
    dfs(1);
    cout << ans << '\n';
}
```

#### æ±‚åŒ¹é…ä¸²çš„ï¼ˆæœ€é•¿çš„ï¼‰å‰ç¼€æ˜¯æ¨¡å¼ä¸²ä¸Šçš„å­ä¸²çš„é•¿åº¦
åªè¦åœ¨ SAM ä¸Šæš´åŠ›èµ°å°±è¡Œ

#### n ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­ä¸²
```cpp
const int N = 20010;
int n;
int tot = 1, last = 1;
string str;
struct Node {
    int len, fa;
    int ch[26];
} node[N];
int ans[N], now[N];
vector<vector<int>> g(N);
void extend(int c) {
    int p = last, np = last = ++tot;
    node[np].len = node[p].len + 1;
    for (; p && !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;
    if (!p) node[np].fa = 1;
    else {
        int q = node[p].ch[c];
        if (node[q].len == node[p].len + 1) node[np].fa = q;
        else {
            int nq = ++tot;
            node[nq] = node[q], node[nq].len = node[p].len + 1;
            node[q].fa = node[np].fa = nq;
            for (; p && node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;
        }
    }
}
void dfs(int u) {
    for (auto v : g[u]) {
        dfs(v);
        now[u] = max(now[u], now[v]);
    }
}
void solve() {
    cin >> n;
    cin >> str;
    for (auto u : str) extend(u - 'a');
    for (int i = 1; i <= tot; i++) ans[i] = node[i].len;
    for (int i = 2; i <= tot; i++) g[node[i].fa].push_back(i);

    for (int i = 0; i < n - 1; i++) {
        cin >> str;
        memset(now, 0, sizeof(now));
        int p = 1, t = 0;
        for (auto u : str) {
            int c = u - 'a';
            while (p > 1 && !node[p].ch[c]) p = node[p].fa, t = node[p].len;
            if (node[p].ch[c]) p = node[p].ch[c], t++;
            now[p] = max(now[p], t);
        }
        dfs(1);
        for (int j = 1; j <= tot; j++) ans[j] = min(ans[j], now[j]);
    }
    int res = 0;
    for (int i = 1; i <= tot; i++) res = max(res, ans[i]);
    cout << res << '\n';
}
```