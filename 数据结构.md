## æ•°æ®ç»“æ„

### å¹¶æŸ¥é›†
```cpp
struct DSU {
    vector<int> fa, dis;
    DSU(int n) {
        fa.assign(n + 1, 0);
        dis.assign(n + 1, 0);
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int u) {
        if (fa[u] == u) return u;
        int f = find(fa[u]);
        dis[u] += dis[fa[u]];
        return fa[u] = f;
    }
    void merge(int u, int v) {
        int fu = find(u), fv = find(v);
        if (fu == fv) return;
        fa[fv] = fu;
    }
    int dist(int u) {
        find(u);
        return dis[u];
    }
};
```

### å•è°ƒæ ˆ

æ±‚å³è¾¹è·ç¦»æœ€è¿‘çš„æ¯”å½“å‰å€¼å¤§çš„ä¸€ä¸ªå…ƒç´ 
```cpp
void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1), ans(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    stack<pair<int, int>> st;
    for (int i = n; i >= 1; i--) {
        while (!st.empty() && st.top().first <= a[i]) st.pop();
        if (st.empty()) ans[i] = 0;
        else ans[i] = st.top().second;
        st.push({a[i], i});
    }
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
}
```

æ±‚æŸ±çŠ¶å›¾ä¸­çš„æœ€å¤§çŸ©å½¢<br>
æ‰¾åˆ°æ¯ä¸ªå€¼å¯¹åº”çš„å·¦å³ä¸¤è¾¹ç¬¬ä¸€ä¸ªå°äºå½“å‰å€¼çš„ä½ç½®

### å•è°ƒé˜Ÿåˆ—

#### æ‰¾å‡ºæ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼
```cpp
void solve() {
    int n, k;
    cin >> n >> k;
    vector<i64> a(n + 1), mi(n + 1, 1e18), mx(n + 1, -1e18);
    for (int i = 1; i <= n; i++) cin >> a[i];
    deque<pair<i64, int>> qmx, qmi;
    for (int i = 1; i <= n; i++) {
        while (!qmx.empty() && i - qmx.front().second + 1 > k) qmx.pop_front(); // åˆ¤æ–­é˜Ÿå¤´æ˜¯å¦åœ¨çª—å£
        while (!qmi.empty() && i - qmi.front().second + 1 > k) qmi.pop_front();
        while (!qmx.empty() && qmx.back().first <= a[i]) qmx.pop_back(); 
        while (!qmi.empty() && qmi.back().first >= a[i]) qmi.pop_back();
        qmx.push_back({a[i], i});
        qmi.push_back({a[i], i});
        if (i >= k) {
            mx[i] = qmx.front().first;
            mi[i] = qmi.front().first;
        }
    }
    for (int i = k; i <= n; i++) cout << mi[i] << ' ';
    cout << '\n';
    for (int i = k; i <= n; i++) cout << mx[i] << ' ';
}
```

#### æ±‚ k * k çš„çŸ©é˜µä¸­çš„æœ€å¤§å€¼å’Œæœ€å°å€¼
```cpp
void solve() {
    int n, m, k;
    cin >> n >> m >> k;
    vector<vector<int>> d(n + 1, vector<int> (m + 1));
    vector<vector<int>> row_min(n + 1, vector<int> (m + 1));  // æ¯è¡Œçš„æœ€å°å€¼
    vector<vector<int>> row_max(n + 1, vector<int> (m + 1));  // æ¯è¡Œçš„æœ€å¤§å€¼
    vector<int> a(n + 1), b(n + 1), c(n + 1);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> d[i][j];
        }
    }
    auto get_values = [&](const vector<int>& a, vector<int>& b, int tot, bool find_max) -> void {
        deque<pair<int, int>> q;
        for (int i = 1; i <= tot; i++) {
            while (!q.empty() && i - q.front().second + 1 > k) q.pop_front();
            while (!q.empty() && (find_max ? q.back().first <= a[i] : q.back().first >= a[i])) q.pop_back();
            q.push_back({a[i], i});
            b[i] = q.front().first;
        }
    };
    // è®¡ç®—æ¯ä¸€è¡Œçš„æœ€å°å€¼å’Œæœ€å¤§å€¼
    for (int i = 1; i <= n; i++) {
        get_values(d[i], row_min[i], m, 0);  // è·å–æœ€å°å€¼
        get_values(d[i], row_max[i], m, 1);   // è·å–æœ€å¤§å€¼
    }
    int ans = 2e9;
    // éå†æ¯åˆ—è¿›è¡Œè®¡ç®—
    for (int i = k; i <= m; i++) {
        for (int j = 1; j <= n; j++) a[j] = row_min[j][i];  // æ›´æ–°æœ€å°å€¼
        get_values(a, b, n, 0);  // è·å–æœ€å°å€¼
        for (int j = 1; j <= n; j++) a[j] = row_max[j][i];  // æ›´æ–°æœ€å¤§å€¼
        get_values(a, c, n, 1);  // è·å–æœ€å¤§å€¼
        // è®¡ç®—ç»“æœ
        for (int j = k; j <= n; j++) ans = min(ans, c[j] - b[j]);
    }
    cout << ans << '\n';
}
```

### ç¬›å¡å°”æ ‘
```cpp
struct Node { 
    int idx, val;       // èŠ‚ç‚¹ç´¢å¼• èŠ‚ç‚¹çš„å€¼
    int par, ch[2];     // çˆ¶èŠ‚ç‚¹ç´¢å¼• å·¦å³å­èŠ‚ç‚¹ç´¢å¼•
    void init(int _idx, int _val, int _par) {
        idx = _idx, val = _val, par = _par, ch[0] = ch[1] = 0;
    }
} tree[N];
int root;
int cartesian_build(int n) { 
    for (int i = 1; i <= n; i++) {
        int k = i - 1;
        // å°æ ¹å †
        while (tree[k].val > tree[i].val) k = tree[k].par;
        // å¤§æ ¹å †
        //while (k > 0 && tree[k].val < tree[i].val) k = tree[k].par;
        tree[i].ch[0] = tree[k].ch[1];
        tree[k].ch[1] = i;
        tree[i].par = k;
        tree[tree[i].ch[0]].par = i;
    }
    return tree[0].ch[1];
}
void solve() {
    int n;
    cin >> n;
    tree[0].init(0, 0, 0);
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        tree[i].init(i, x, 0);
    } 
    root = cartesian_build(n);
}
```

### ç‚æœµè‰æ ‘
```cpp
#define IT set<node>::iterator
struct node {
    int l, r;
    mutable int v;
    bool operator < (const node &x) const {
        return l < x.l;
    }
    node (int L, int R, int V) {
        l = L, r = R, v = V;
    }
};
set<node> s;
IT split(int pos) {
    IT it = s.lower_bound(node(pos, 0, 0));
    if (it != s.end() && it->l == pos) return it;
    it--;
    int L = it->l, R = it->r, V = it->v;
    s.erase(it);
    s.insert(node(L, pos - 1, V));
    return s.insert(node(pos, R, V)).first;
}
void tp(int l, int r, int v) {
    IT itr = split(r + 1), itl = split(l);
    s.erase(itl, itr);
    s.insert(node(l, r, v));
}
int ask(int l, int r) {
    set<int> cnt;
    IT itr = split(r + 1), itl = split(l);
    for (IT it = itl; it != itr; it++) {
        cnt.insert(it->v);
    }
    return cnt.size();
}
void solve() {
    int q;
    cin >> q;
    s.insert(node(1, 100002, 0));
    while (q--) {
        int l, r, x;
        cin >> l >> r >> x;
        tp(l, r, x);
        cout << ask(1, 100002) << '\n';
    }
}
```

### å°æ³¢çŸ©é˜µæ ‘
```cpp
struct BitRank {
    // block ç®¡ç†ä¸€è¡Œä¸€è¡Œçš„ bit
    std::vector<unsigned long long> block;
    std::vector<unsigned int> count;
    BitRank() {}
    // ä½å‘é‡é•¿åº¦
    void resize(const unsigned int num) {
        block.resize(((num + 1) >> 6) + 1, 0);
        count.resize(block.size(), 0);
    }
    // è®¾ç½® i ä½bit
    void set(const unsigned int i, const unsigned long long val) {
        block[i >> 6] |= (val << (i & 63));
    }
    void build() {
        for (unsigned int i = 1; i < block.size(); i++) {
            count[i] = count[i - 1] + __builtin_popcountll(block[i - 1]);
        }
    }
    // [0, i) 1 çš„ä¸ªæ•°
    unsigned int rank1(const unsigned int i) const {
        return count[i >> 6] +
            __builtin_popcountll(block[i >> 6] & ((1ULL << (i & 63)) - 1ULL));
    }
    // [i, j) 1 çš„ä¸ªæ•°
    unsigned int rank1(const unsigned int i, const unsigned int j) const {
        return rank1(j) - rank1(i);
    }
    // [0, i) 0 çš„ä¸ªæ•°
    unsigned int rank0(const unsigned int i) const { return i - rank1(i); }
    // [i, j) 0 çš„ä¸ªæ•°
    unsigned int rank0(const unsigned int i, const unsigned int j) const {
        return rank0(j) - rank0(i);
    }
};

class WaveletMatrix {
private:
    unsigned int height;
    std::vector<BitRank> B;
    std::vector<int> pos;
    
public:
    WaveletMatrix() {}
    WaveletMatrix(std::vector<int> vec)
        : WaveletMatrix(vec, *std::max_element(vec.begin(), vec.end()) + 1) {}
    // sigma: å­—æ¯è¡¨å¤§å°(å­—ç¬¦ä¸²çš„è¯)ï¼Œæ•°å­—åºåˆ—çš„è¯æ˜¯æ•°çš„ç§ç±»
    WaveletMatrix(std::vector<int> vec, const unsigned int sigma) {
        init(vec, sigma);
    }
    void init(std::vector<int>& vec, const unsigned int sigma) {
        height = (sigma == 1) ? 1 : (64 - __builtin_clzll(sigma - 1));
        B.resize(height), pos.resize(height);
        for (unsigned int i = 0; i < height; ++i) {
            B[i].resize(vec.size());
            for (unsigned int j = 0; j < vec.size(); ++j) {
                B[i].set(j, get(vec[j], height - i - 1));
            }
            B[i].build();
            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {
                return !get(c, height - i - 1);
            });
            pos[i] = it - vec.begin();
        }
    }

    int get(const int val, const int i) { return val >> i & 1; }
    // [l, r) ä¸­ val å‡ºç°çš„é¢‘ç‡

    int rank(const int val, const int l, const int r) {
        return rank(val, r) - rank(val, l);
    }
    // [0, i) ä¸­ val å‡ºç°çš„é¢‘ç‡
    int rank(int val, int i) {
        int p = 0;
        for (unsigned int j = 0; j < height; ++j) {
            if (get(val, height - j - 1)) {
                p = pos[j] + B[j].rank1(p);
                i = pos[j] + B[j].rank1(i);
            } else {
                p = B[j].rank0(p);
                i = B[j].rank0(i);
            }
        }
        return i - p;
    }
    // [l, r) ä¸­ç¬¬ k å°
    int quantile(int k, int l, int r) {
        int res = 0;
        for (unsigned int i = 0; i < height; ++i) {
            const int j = B[i].rank0(l, r);
            if (j > k) {
                l = B[i].rank0(l);
                r = B[i].rank0(r);
            } else {
                l = pos[i] + B[i].rank1(l);
                r = pos[i] + B[i].rank1(r);
                k -= j;
                res |= (1 << (height - i - 1));
            }
        }
        return res;
    }
    int rangefreq(const int i, const int j, const int a, const int b, const int l,
                  const int r, const int x) {
        if (i == j || r <= a || b <= l) return 0;
        const int mid = (l + r) >> 1;
        if (a <= l && r <= b) {
            return j - i;
        } else {
            const int left =
                rangefreq(B[x].rank0(i), B[x].rank0(j), a, b, l, mid, x + 1);
            const int right = rangefreq(pos[x] + B[x].rank1(i),
                                        pos[x] + B[x].rank1(j), a, b, mid, r, x + 1);
            return left + right;
        }
    }
    // [l,r) åœ¨ [a, b) å€¼åŸŸçš„æ•°å­—ä¸ªæ•°
    int rangefreq(const int l, const int r, const int a, const int b) {
        return rangefreq(l, r, a, b, 0, 1 << height, 0);
    }
    int rangemin(const int i, const int j, const int a, const int b, const int l,
                 const int r, const int x, const int val) {
        if (i == j || r <= a || b <= l) return -1;
        if (r - l == 1) return val;
        const int mid = (l + r) >> 1;
        const int res =
            rangemin(B[x].rank0(i), B[x].rank0(j), a, b, l, mid, x + 1, val);
        if (res < 0)
            return rangemin(pos[x] + B[x].rank1(i), pos[x] + B[x].rank1(j), a, b, mid,
                            r, x + 1, val + (1 << (height - x - 1)));
        else
            return res;
    }
    // [l,r) åœ¨ [a,b) å€¼åŸŸå†…å­˜åœ¨çš„æœ€å°å€¼æ˜¯ä»€ä¹ˆï¼Œä¸å­˜åœ¨è¿”å› -1
    int rangemin(int l, int r, int a, int b) {
        return rangemin(l, r, a, b, 0, 1 << height, 0, 0);
    }
};

int n, q;
void solve() {
    cin >> n >> q;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    WaveletMatrix wm(a);
    while (q--) {
        int l, r;
        cin >> l >> r;
        int k = (r - l + 1) / 2;
        r++;
        cout << wm.quantile(k, l, r) << '\n'; // ç¬¬ k å°ä»¥ 0 ä¸ºä¸‹æ ‡
    }
}
```

### å¯æŒä¹…åŒ–æ•°æ®ç»“æ„

#### å¯æŒä¹…åŒ–Trie
æ¯æ¬¡åªä¿®æ”¹è¢«æ·»åŠ æˆ–å€¼è¢«ä¿®æ”¹çš„èŠ‚ç‚¹ï¼Œè€Œä¿ç•™æ²¡æœ‰è¢«æ”¹åŠ¨çš„èŠ‚ç‚¹ï¼Œåœ¨ä¸Šä¸€ä¸ªç‰ˆæœ¬çš„åŸºç¡€ä¸Šè¿è¾¹ï¼Œä½¿æœ€åæ¯ä¸ªç‰ˆæœ¬çš„ Trie æ ‘çš„æ ¹éå†æ‰€èƒ½åˆ†ç¦»å‡ºçš„ Trie æ ‘éƒ½æ˜¯å®Œæ•´ä¸”åŒ…å«å…¨éƒ¨ä¿¡æ¯çš„ã€‚ <br>
1:åºåˆ—æœ«å°¾æ’å…¥ä¸€ä¸ªæ•° x <br>
2:è¯¢é—® [l, r] ä¸­çš„ä¸€ä¸ª p ä½ç½®ä½¿å¾—åç¼€å¼‚æˆ– x æœ€å¤§ <br>
```cpp
int n, m;
int s[N];
int tr[M][2], max_id[M];
int root[N], idx;
void insert(int i, int k, int p, int q) {
    if (k < 0) {
        max_id[q] = i;
        return;
    }
    int v = s[i] >> k & 1;
    if (p) tr[q][v ^ 1] = tr[p][v ^ 1];
    tr[q][v] = ++idx;
    insert(i, k - 1, tr[p][v], tr[q][v]);
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]); 
}
int query(int root, int C, int L) {
    int p = root;
    for (int i = 23; i >= 0; i--) {
        int v = C >> i & 1;
        if (max_id[tr[p][v ^ 1]] >= L) p = tr[p][v ^ 1];
        else p = tr[p][v];
    }
    int ans = C ^ s[max_id[p]];
    return ans;
}
void solve() {
    cin >> n >> m;
    max_id[0] = -1;
    root[0] = ++idx;
    insert(0, 23, 0, root[0]);
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        s[i] = s[i - 1] ^ x;
        root[i] = ++idx;
        insert(i, 23, root[i - 1], root[i]);
    }
    string op;
    int l, r, x;
    while (m--) {
        cin >> op;
        if (op[0] == 'A') {
            cin >> x;
            n++;
            s[n] = s[n - 1] ^ x;
            root[n] = ++idx;
            insert(n, 23, root[n - 1], root[n]);
        }
        else {
            cin >> l >> r >> x;
            cout << query(root[r - 1], s[n] ^ x, l - 1) << '\n';
        }
    }
}
```

#### ä¸»å¸­æ ‘
æŸ¥è¯¢åŒºé—´ç¬¬ k å°å€¼
```cpp
int n, m;
int a[N];
vector<int> nums;
struct Node {
    int l, r;
    int cnt; // åŒºé—´å…ƒç´ ä¸ªæ•°
} tr[N * 4 + N * 17]; // N * 4 + NlogN
int root[N], idx;
int find(int x) {
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}
int build(int l, int r) {
    int p = ++idx;
    if (l == r) return p;
    int mid = l + r >> 1;
    tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
    return p;
}
int insert(int p, int l, int r, int x) {
    int q = ++idx;
    tr[q] = tr[p];
    if (l == r) {
        tr[q].cnt++;
        return q;
    } 
    int mid = l + r >> 1;
    if (x <= mid) tr[q].l = insert(tr[p].l, l, mid, x);
    else tr[q].r = insert(tr[p].r, mid + 1, r, x);
    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
}
int query(int q, int p, int l, int r, int k) {
    if (l == r) return r;
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r >> 1;
    if (k <= cnt) return query(tr[q].l, tr[p].l, l, mid, k);
    else return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);
}
void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        nums.push_back(a[i]);
    }
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    root[0] = build(0, nums.size() - 1);
    for (int i = 1; i <= n; i++) root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));
    while (m--) {
        int l, r, k;
        cin >> l >> r >> k;
        cout << nums[query(root[r], root[l - 1], 0, nums.size() - 1, k)] << '\n';
    }
}  
```

### æè¶…çº¿æ®µæ ‘
```cpp
struct LiChao {
    struct Line {
        long long k, b;                    // y = kÂ·x + b
        Line(long long _k = 0, long long _b = (1LL << 62)) : k(_k), b(_b) {}
        long long operator()(long long x) const { return k * x + b; }
    };
    struct Node {
        Line line;
        int  ch[2]{0, 0};                   // å·¦ å³
    };
    vector<Node> tr;
    int root = 0;
    const int X_MIN, X_MAX;                // å®šä¹‰åæ ‡èŒƒå›´
    LiChao(int l, int r) : X_MIN(l), X_MAX(r) {
        tr.reserve(10'000'000);                   
        tr.push_back(Node{}); 
    }
    int new_node(Line ln) {
        tr.push_back({ln, {0, 0}});
        return (int)tr.size() - 1;
    }
    /* --- å•ç‚¹æ’ç›´çº¿ --- */
    void add_line(Line ln) { root = add_line(root, X_MIN, X_MAX, ln); }
    int add_line(int id, int l, int r, Line ln) {
        if(!id) { id = new_node(ln); return id; }
        int mid = (l + r) >> 1;
        bool lefBetter = ln(l) < tr[id].line(l);
        bool midBetter = ln(mid) < tr[id].line(mid);
        if (midBetter) swap(tr[id].line, ln);
        if (l == r) return id;
        if (lefBetter != midBetter) tr[id].ch[0] = add_line(tr[id].ch[0], l, mid, ln);        // â˜… å†™å›
        else tr[id].ch[1] = add_line(tr[id].ch[1], mid+1, r, ln);      // â˜… å†™å›
        return id;
    }
    /* --- åŒºé—´æ’ç›´çº¿ (å¯é€‰) --- */
    void add_segment(Line ln, int L, int R) {
        root = add_segment(root, X_MIN, X_MAX, ln, L, R);
    }
    int add_segment(int id, int l, int r, Line ln, int L, int R) {
        if (R < l || r < L) return id;
        if (L <= l && r <= R) return add_line(id, l, r, ln);
        int mid = (l + r) >> 1;
        tr[id].ch[0] = add_segment(tr[id].ch[0], l, mid, ln, L, R);
        tr[id].ch[1] = add_segment(tr[id].ch[1], mid + 1, r, ln, L, R);
        return id;
    }
    /* --- æŸ¥è¯¢ç‚¹ (æœ€å°å€¼) --- */
    long long query(long long x) { return query(root, X_MIN, X_MAX, x); }
    long long query(int id, int l, int r, long long x) const {
        if (!id) return (1LL << 62);                 // +INF
        if (l == r) return tr[id].line(x);
        int mid = (l + r) >> 1;
        long long cur = tr[id].line(x);
        if (x <= mid) return min(cur, query(tr[id].ch[0], l, mid, x));
        else return min(cur, query(tr[id].ch[1], mid + 1, r, x));
    }
    /* --- æ¸…ç©ºæ•´æ£µæ ‘ï¼ˆå¤šç»„æ•°æ®æ—¶å»ºè®®é‡å»ºå¯¹è±¡ï¼‰ --- */
    void clear() {
        tr.clear(); tr.shrink_to_fit();
        root = 0;
    }
};
```

### è«é˜Ÿ
å¯¹äºåºåˆ—ä¸Šçš„åŒºé—´è¯¢é—®é—®é¢˜ï¼Œå¦‚æœä» [l, r] çš„ç­”æ¡ˆèƒ½å¤Ÿ O(1) æ‰©å±•åˆ° [l - 1, r], [l + 1, r], [l, r + 1], [l, r - 1]ï¼ˆå³ä¸ [l, r] ç›¸é‚»çš„åŒºé—´ï¼‰çš„ç­”æ¡ˆï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ O(n sqrtn) çš„å¤æ‚åº¦å†…æ±‚å‡ºæ‰€æœ‰è¯¢é—®çš„ç­”æ¡ˆã€‚
#### æ™®é€šè«é˜Ÿ 
B = n / sqrtl(m) <br>
æˆ‘ä»¬è®¾å—é•¿åº¦ä¸º $S$ï¼Œé‚£ä¹ˆå¯¹ä»»æ„å¤šä¸ªåœ¨åŒä¸€å—å†…çš„æŸ¥è¯¢ï¼Œç§»åŠ¨çš„è·ç¦»å°±æ˜¯ $n$ï¼Œä¸€å…± $\frac{n}{S}$ ä¸ªå—ï¼Œç§»åŠ¨çš„æ€»æ¬¡æ•°å°±æ˜¯ $\frac{n^2}{S}$ï¼Œç§»åŠ¨å¯èƒ½è·¨è¶Šå—ï¼Œæ‰€ä»¥è¿˜éœ€è¦åŠ ä¸Šä¸€ä¸ª $mS$ çš„å¤æ‚åº¦ï¼Œæ€»å¤æ‚åº¦ä¸º
$
O\left( \frac{n^2}{S} + mS \right)
$
æˆ‘ä»¬è¦è®©è¿™ä¸ªå€¼å°½é‡å°ï¼Œé‚£ä¹ˆå°±è¦å°†ä¸¤ä¸ªé¡¹å°½é‡ç›¸ç­‰ï¼Œå‘ç° $S$ å– $\frac{n}{\sqrt{m}}$ æ˜¯æœ€ä¼˜çš„ï¼Œæ­¤æ—¶å¤æ‚åº¦ä¸º
$O(n\sqrt{m})$

åŒºé—´ç§ç±»æ•°
```cpp
const int N = 50003, M = 2e5 + 5, S = 1e6 + 10;
int n, m, len;
int w[N], ans[M];
struct Query {
    int id, l, r;
} q[M];
int cnt[S];
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    else {
        if (i & 1) return a.r < b.r;
        else return a.r > b.r;
    }
}
void add(int x, int &res) {
    if (!cnt[x]) res++;
    cnt[x]++;
}
void del(int x, int &res) {
    cnt[x]--;
    if (!cnt[x]) res--;
}
void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
    cin >> m;
    len = n / (sqrtl(m) + 1) + 1;
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);
    int res = 0;
    for (int k = 0, nowl = 1, nowr = 0; k < m; k++) {
        int id = q[k].id, l = q[k].l, r = q[k].r;
        while (nowl > l) add(w[--nowl], res);
        while (nowr < r) add(w[++nowr], res);
        while (nowl < l) del(w[nowl++], res);
        while (nowr > r) del(w[nowr--], res);
        ans[id] = res;
    }
    for (int i = 0; i < m; i++) cout << ans[i] << '\n';
}
```

åŒºé—´ä¼—æ•°
```cpp
const int N = 2e5 + 10, M = 2e5 + 10, S = 2e5 + 10;
int n, m, len;
int w[N], ans[M];
struct Query {
    int id, l, r;
} q[M];
int cnt1[S], cnt2[S]; // cnt1 æ˜¯æ¯ä¸ªæ•°å‡ºç°æ¬¡æ•° cnt2 æ˜¯å‡ºç°æ¬¡æ•°ä¸ºè¿™ä¸ªçš„å…±æœ‰å‡ ä¸ª
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    else {
        if (i & 1) return a.r < b.r;
        else return a.r > b.r;
    }
}
void add(int x, int &res) {
    cnt2[cnt1[x]]--;
    cnt1[x]++;
    cnt2[cnt1[x]]++;
    res = max(res, cnt1[x]);
}
void del(int x, int &res) {
    if (cnt1[x] == res && cnt2[cnt1[x]] == 1) res--;
    cnt2[cnt1[x]]--;
    cnt1[x]--;
    cnt2[cnt1[x]]++;
}
void solve() {
    map<int, int> id;
    int idx = 0;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
        id[w[i]] = 1;
    }
    for (auto &[u, _] : id) _ = ++idx;
    for (int i = 1; i <= n; i++) w[i] = id[w[i]];
    cnt2[0] = idx;
    len = n / (sqrtl(m) + 1) + 1;
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);
    int res = 0;
    for (int k = 0, nowl = 1, nowr = 0; k < m; k++) {
        int id = q[k].id, l = q[k].l, r = q[k].r;
        while (nowl > l) add(w[--nowl], res);
        while (nowr < r) add(w[++nowr], res);
        while (nowl < l) del(w[nowl++], res);
        while (nowr > r) del(w[nowr--], res);
        ans[id] = res;
    }
    for (int i = 0; i < m; i++) cout << ans[i] << '\n';
}
```

åŒºé—´å¼‚æˆ–å’Œä¸º K<br>
ç»™å®šæŸ¥è¯¢ $l,r$ï¼Œå¯¹äºæ‰€æœ‰çš„ $x, y(l â‰¤ x â‰¤ y â‰¤ r)$ï¼Œèƒ½å¤Ÿæ»¡è¶³ $a_xâŠ•a_{x+1}âŠ•â‹¯âŠ•a_y=k$ çš„ $x, y$ æœ‰å¤šå°‘ç»„
```cpp
const int N = 1e5 + 10, M = 1e5 + 10, S = 4e5 + 10;
int n, m, k, len;
i64 w[N], ans[M];
struct Query {
    int id, l, r;
} q[M];
int cnt[S];
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    else {
        if (i & 1) return a.r < b.r;
        else return a.r > b.r;
    }
}
void add(int x, i64 &res) {
    if (k) {
        res -= (i64)cnt[x] * cnt[x ^ k];
        cnt[x]++;
        res += (i64)cnt[x] * cnt[x ^ k];
    }
    else {
        res -= (i64)cnt[x] * (cnt[x] - 1) / 2;
        cnt[x]++;
        res += (i64)cnt[x] * (cnt[x] - 1) / 2;
    }
}
void del(int x, i64 &res) {
    if (k) {
        res -= (i64)cnt[x] * cnt[x ^ k];
        cnt[x]--;
        res += (i64)cnt[x] * cnt[x ^ k];
    }
    else {
        res -= (i64)cnt[x] * (cnt[x] - 1) / 2;
        cnt[x]--;
        res += (i64)cnt[x] * (cnt[x] - 1) / 2;
    }
}
void solve() {
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
        w[i] ^= w[i - 1];
    }
    len = n / (sqrtl(m) + 1) + 1;
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);
    i64 res = 0;
    for (int k = 0, nowl = 1, nowr = 0; k < m; k++) {
        int id = q[k].id, l = q[k].l - 1, r = q[k].r;
        while (nowl > l) add(w[--nowl], res);
        while (nowr < r) add(w[++nowr], res);
        while (nowl < l) del(w[nowl++], res);
        while (nowr > r) del(w[nowr--], res);
        ans[id] = res;
    }
    for (int i = 0; i < m; i++) cout << ans[i] << '\n';
}
```

#### å¸¦ä¿®è«é˜Ÿ
åœ¨åŸºç¡€è«é˜Ÿä¸Šæ·»åŠ ä¸€ç»´æ—¶é—´ <br>
åºåˆ—é•¿ä¸º ğ‘›, ğ‘š ä¸ªè¯¢é—®ï¼Œğ‘¡ ä¸ªä¿®æ”¹<br>
å—é•¿å– $\frac{n^{2/3} t^{1/3}}{m^{1/3}}$

æ±‚åŒºé—´ç§ç±»æ•°ï¼Œå¯å•ç‚¹ä¿®æ”¹
```cpp
const int N = 150000, M = 150000, S = 1e6 + 10;
int n, m, len, nq, nm;
int w[N], cnt[S], ans[M];
struct Query {
    int id, l, r, t;
} q[M];
struct Modify {
    int p, c;
} c[M];
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int al = get(a.l), ar = get(a.r);
    int bl = get(b.l), br = get(b.r);
    if (al != bl) return al < bl;
    if (ar != br) return ar < br;
    return a.t < b.t;
}
void add(int x, int& res) {
    if (!cnt[x]) res++;
    cnt[x]++;
}
void del(int x, int& res) {
    cnt[x]--;
    if (!cnt[x]) res--;
}
void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> w[i];
    for (int i = 0; i < m; i++) {
        char op;
        int a, b;
        cin >> op >> a >> b;
        if (op == 'Q')  {
            nq++;
            q[nq] = {nq, a, b, nm};
        }
        else c[++nm] = {a, b};
    }    
    len = cbrtl((long double)n * n * (1 + nm) / (1 + nq)) + 1;
    sort(q + 1, q + nq + 1, cmp);
    int res = 0;
    for (int nowl = 1, nowr = 0, t = 0, k = 1; k <= nq; k++) {
        int id = q[k].id, l = q[k].l, r = q[k].r, tm = q[k].t;
        while (nowl > l) add(w[--nowl], res);
        while (nowr < r) add(w[++nowr], res);
        while (nowl < l) del(w[nowl++], res);
        while (nowr > r) del(w[nowr--], res);
        while (t < tm) {
            t++;
            if (c[t].p >= nowl && c[t].p <= nowr) {
                del(w[c[t].p], res);
                add(c[t].c, res);
            }
            swap(w[c[t].p], c[t].c);
        }
        while (t > tm) {
            if (c[t].p >= nowl && c[t].p <= nowr) {
                del(w[c[t].p], res);
                add(c[t].c, res);
            }
            swap(w[c[t].p], c[t].c);
            t--;
        }
        ans[id] = res;
    }
    for (int i = 1; i <= nq; i++) cout << ans[i] << '\n';
}
```

åŒºé—´å‡ºç°æ¬¡æ•°çš„ mex <br>
ç»´æŠ¤æ¯ä¸ªæ•°å‡ºç°æ¬¡æ•°å’Œå‡ºç°æ¬¡æ•°ä¸ºè¿™ä¸ªçš„å…±æœ‰å‡ ä¸ª æŸ¥è¯¢åªè¦æš´åŠ›éå†ç¬¬äºŒä¸ªæ•°ç»„

#### å›æ»šè«é˜Ÿ
åªæœ‰å¢åŠ ä¸å¯å®ç°æˆ–è€…åªæœ‰åˆ é™¤ä¸å¯å®ç°çš„æ—¶å€™ï¼Œå°±å¯ä»¥ä½¿ç”¨å›æ»šè«é˜Ÿåœ¨ $O(n \sqrt m)$ çš„æ—¶é—´å†…è§£å†³é—®é¢˜ã€‚å›æ»šè«é˜Ÿçš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯ï¼šæ—¢ç„¶åªèƒ½å®ç°ä¸€ä¸ªæ“ä½œï¼Œé‚£ä¹ˆå°±åªä½¿ç”¨ä¸€ä¸ªæ“ä½œï¼Œå‰©ä¸‹çš„äº¤ç»™å›æ»šè§£å†³ã€‚ <br>

åªå¢å›æ»šè«é˜Ÿ<br>

æŸ¥è¯¢åŒºé—´å‡ºç°æ¬¡æ•°ä¹˜ä»¥å½“å‰å€¼çš„æœ€å¤§å€¼
```cpp
const int N = 1e5 + 10, M = 1e5 + 10, S = 1e5 + 10;
int n, m, len;
int w[N], rw[N], cnt[S];
i64 ans[M];
struct Query {
    int id, l, r;
} q[M];
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    else return a.r < b.r;
}
void add(int x, i64& res) {
    cnt[x]++;
    res = max(res, (i64)cnt[x] * rw[x]);
}
void solve() {
    map<int, int> id;
    int idx = 0;
    cin >> n >> m;
    len = n / (sqrtl(m) + 1) + 1;
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
        id[w[i]] = 1;
    }    
    for (auto &[u, _] : id) {
        _ = ++idx;
        rw[idx] = u;
    }
    for (int i = 1; i <= n; i++) w[i] = id[w[i]];
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);
    for (int x = 0; x < m;) {
        int y = x;
        while (y < m && get(q[y].l) == get(q[x].l)) y++;
        int right = get(q[x].l) * len + len - 1;
        // æš´åŠ›æ±‚å—å†…çš„è¯¢é—®
        while (x < y && q[x].r <= right) { 
            i64 res = 0;
            int id = q[x].id, l = q[x].l, r = q[x].r;
            for (int k = l; k <= r; k++) add(w[k], res);
            ans[id] = res;
            for (int k = l; k <= r; k++) cnt[w[k]]--;
            x++;
        } 
        // æ±‚å—å¤–çš„è¯¢é—®
        i64 res = 0;
        int nowr = right, nowl = right + 1;
        while (x < y) {
            int id = q[x].id, l = q[x].l, r = q[x].r;
            while (nowr < r) add(w[++nowr], res);
            i64 backup = res;
            while (nowl > l) add(w[--nowl], res);
            ans[id] = res;
            while (nowl < right + 1) cnt[w[nowl++]]--;
            res = backup;
            x++;
        }
        memset(cnt, 0, sizeof(cnt));
    }
    for (int i = 0; i < m; i++) cout << ans[i] << '\n';
}
```

åŒºé—´ä¸­ç›¸åŒçš„æ•°çš„æœ€è¿œé—´éš”è·ç¦»
```cpp
const int N = 2e5 + 10, M = 2e5 + 10, S = 2e5 + 10;
int n, m, len;
int w[N], First[S], Right[S]; // First ä»£è¡¨å‘å³æ‰©å±•æ—¶çš„ç¬¬ä¸€ä¸ªä½ç½® Right ä»£è¡¨æœ€é å³çš„ä½ç½®
int ans[M];
struct Query {
    int id, l, r;
} q[M];
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    else return a.r < b.r;
}
void add(int pos, int& res, int type) { // type = 1 å‘å³æ·»åŠ  type = 0 å‘å·¦æ·»åŠ 
    if (type) First[w[pos]] = min(First[w[pos]], pos);
    Right[w[pos]] = max(Right[w[pos]], pos);
    if (type) res = max(res, pos - First[w[pos]]);
    else res = max(res, Right[w[pos]] - pos);
}
void solve() {
    map<int, int> id;
    int idx = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
        id[w[i]] = 1;
    }    
    cin >> m;
    len = n / (sqrtl(m) + 1) + 1;
    for (auto &[u, _] : id) _ = ++idx;
    for (int i = 1; i <= n; i++) w[i] = id[w[i]];
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);
    for (int i = 1; i <= idx; i++) {
        First[i] = n + 1;
        Right[i] = 0;
    }
    for (int x = 0; x < m;) {
        int y = x;
        while (y < m && get(q[y].l) == get(q[x].l)) y++;
        int right = get(q[x].l) * len + len - 1;
        // æš´åŠ›æ±‚å—å†…çš„è¯¢é—®
        while (x < y && q[x].r <= right) { 
            int res = 0;
            int id = q[x].id, l = q[x].l, r = q[x].r;
            for (int k = l; k <= r; k++) add(k, res, 1);
            ans[id] = res;
            for (int k = l; k <= r; k++) {
                First[w[k]] = n + 1;
                Right[w[k]] = 0;
            }
            x++;
        } 
        // æ±‚å—å¤–çš„è¯¢é—®
        int res = 0;
        int nowr = right, nowl = right + 1;
        while (x < y) {
            int id = q[x].id, l = q[x].l, r = q[x].r;
            while (nowr < r) add(++nowr, res, 1);
            int backup = res;
            while (nowl > l) add(--nowl, res, 0);
            ans[id] = res;
            nowl = max(nowl, right + 1);
            res = backup;
            x++;
        }
        for (int i = 1; i <= idx; i++) {
            First[i] = n + 1;
            Right[i] = 0;
        }
    }
    for (int i = 0; i < m; i++) cout << ans[i] << '\n';
}
```

åªåˆ å›æ»šè«é˜Ÿ<br>

åŒºé—´ mex
```cpp
const int N = 2e5 + 10, M = 2e5 + 10;
int n, m, len, bnum;
int a[N], ans[N], cnt[N], bl[N], bi[N];
struct Query {
    int id, l, r;
} q[M];
bool cmp(Query a, Query b) {
    int i = bi[a.l], j = bi[b.l];
    if (i != j) return i < j;
    else return a.r > b.r;
}
void del(int num, int &res) {
    if (--cnt[num] == 0) {
        res = min(res, num);
    }
}
void add(int num) {
    cnt[num]++;
}
void solve() {
    cin >> n >> m;
    len = n / (sqrtl(m) + 1) + 1;
    bnum = (n + len - 1) / len;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        bi[i] = (i - 1) / len + 1;
    }
    for (int i = 1; i <= m; i++) {
        cin >> q[i].l >> q[i].r;
        q[i].id = i;
    }
    for (int i = 1; i <= bnum; i++) bl[i] = (i - 1) * len + 1;
    sort(q + 1, q + m + 1, cmp);
    for (int i = 1; i <= n; i++) cnt[a[i]]++;
    int res = 0;
    while (cnt[res]) res++;
    int winl = 1, winr = n;
    for (int block = 1, qi = 1; block <= bnum && qi <= m; block++) {
        while (winl < bl[block]) del(a[winl++], res);
        int beforeJob = res;
        for (; qi <= m && bi[q[qi].l] == block; qi++) {
            int jobl = q[qi].l;
            int jobr = q[qi].r;
            int id = q[qi].id;
            while (winr > jobr) del(a[winr--], res);
            int backup = res;
            while (winl < jobl) del(a[winl++], res);
            ans[id] = res;
            res = backup;
            while (winl > bl[block]) add(a[--winl]);
        }
        while (winr < n) add(a[++winr]);
        res = beforeJob;
    }
    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
}
```

#### æ ‘ä¸Šè«é˜Ÿ
å°†æ ‘ä¸Šè·¯å¾„è½¬åŒ–ä¸ºæ‹¬å·åºåˆ—åçš„åŒºé—´é—®é¢˜ <br>
ç»Ÿè®¡æ ‘ä¸Šè·¯å¾„ä¸­ä¸åŒçš„æƒå€¼ä¸ªæ•°
```cpp
const int N = 1e5 + 10, M = 1e5 + 10;
int n, m, len, w[N];
vector<int> adj[N];
int depth[N], fa[N][16];
int seq[N], top, first[N], last[N]; // æ‹¬å·åºåˆ—ï¼Œæ¯ä¸ªç‚¹åœ¨æ ‘ä¸­ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®
int cnt[N], st[N], ans[N];
struct Query {
    int id, l, r, p; // p è¡¨ç¤ºè¯¢é—®ä¸­æ˜¯å¦åŒ…å« lca
} q[N];
void dfs(int u, int fa) { // æ±‚æ‹¬å·åºåˆ—
    seq[++top] = u;
    first[u] = top;
    for (auto &v : adj[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
    seq[++top] = u;
    last[u] = top;
}
void bfs() {
    memset(depth, 0x3f, sizeof(depth));
    depth[0] = 0, depth[1] = 1;
    queue<int> q;
    q.push(1);
    while (q.size()) {
        auto u = q.front();
        q.pop();
        for (auto &v : adj[u]) {
            if (depth[v] > depth[u] + 1) {
                depth[v] = depth[u] + 1;
                q.push(v);
                fa[v][0] = u;
                for (int t = 1; t <= 15; t++) fa[v][t] = fa[fa[v][t - 1]][t - 1];
            }
        }
    }
}
int lca(int a, int b) {
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 15; k >= 0; k--) {
        if (depth[fa[a][k]] >= depth[b]) {
            a = fa[a][k];
        }
    }
    if (a == b) return a;
    for (int k = 15; k >= 0; k--) {
        if (fa[a][k] != fa[b][k]) {
            a = fa[a][k];
            b = fa[b][k];
        }
    }
    return fa[a][0];
}
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    else return a.r < b.r;
}
void add(int x, int &res) {
    st[x] ^= 1;
    if (!st[x]) {
        cnt[w[x]]--;
        if (!cnt[w[x]]) res--;
    }
    else {
        if (!cnt[w[x]]) res++;
        cnt[w[x]]++;
    }
}
void solve() {
    cin >> n >> m;
    map<int, int> id;
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
        id[w[i]] = 1;
    }
    int idx = 0;
    for (auto &[u, _] : id) _ = ++idx;
    for (int i = 1; i <= n; i++) w[i] = id[w[i]];
    for (int i = 1; i < n; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    dfs(1, -1); // æ±‚æ‹¬å·åºåˆ—
    bfs();
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        if (first[a] > first[b]) swap(a, b);
        int p = lca(a, b);
        if (a == p) q[i] = {i, first[a], first[b]};
        else q[i] = {i, last[a], first[b], p};
    }
    len = top / (sqrtl(m) + 1) + 1;
    sort(q, q + m, cmp);
    int res = 0;
    for (int i = 0, L = 1, R = 0; i < m; i++) {
        int id = q[i].id, l = q[i].l, r = q[i].r, p = q[i].p;
        while (R < r) add(seq[++R], res);
        while (R > r) add(seq[R--], res);
        while (L < l) add(seq[L++], res);
        while (L > l) add(seq[--L], res);
        if (p) add(p, res);
        ans[id] = res;
        if (p) add(p, res);
    }
    for (int i = 0; i < m; i++) cout << ans[i] << '\n';
}
```

#### äºŒæ¬¡ç¦»çº¿è«é˜Ÿ
é¢˜ç›®çœ‹èµ·æ¥å¾ˆé€‚åˆä½¿ç”¨è«é˜Ÿç®—æ³•å¤„ç†ï¼Œä½†æ˜¯ä»–ä»¬çš„å•æ¬¡è½¬ç§»å¹¶éæ˜¯ O(1) çš„ï¼Œè¿™æ—¶ç›´æ¥ä½¿ç”¨è«é˜Ÿå³ä½¿è°ƒæ•´å—é•¿ï¼Œä¹Ÿä¼šå¯¼è‡´å¤æ‚åº¦ä¸æ­£ç¡®ã€‚æ­¤æ—¶ï¼Œå¦‚æœæ¯æ¬¡è½¬ç§»å¯¹ç­”æ¡ˆçš„è´¡çŒ®å¯ä»¥è¿›è¡Œå·®åˆ†ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†è¿™äº›è½¬ç§»æ‹†å¼€ç¦»çº¿ä¸‹æ¥ï¼Œä½¿ç”¨å…¶å®ƒç®—æ³•æ‰¹é‡å¤„ç†ã€‚æˆ‘ä»¬ç”¨ f(x, l, r) è¡¨ç¤º x å…³äº [l, r] äº§ç”Ÿçš„è´¡çŒ®ã€‚å¦‚æˆ‘ä»¬åœ¨å°†å½“å‰åŒºé—´ [l, r] æ‰©å±•åˆ° [l, r + 1] æ—¶ï¼Œæˆ‘ä»¬è¦æ±‚çš„æ˜¯ f(a_{r + 1}, l, r)ã€‚å¦‚æœå¯ä»¥å·®åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶å†™æˆ f(a_{r + 1}, 1, r) - f(a_{r + 1}, 1, l - 1)ï¼Œå…¶ä¸­ç¬¬ä¸€é¡¹æˆ‘ä»¬å¯ä»¥å¯¹äºæ¯ä¸ª r éƒ½é¢„å¤„ç†å‡ºæ¥ï¼Œåä¸€é¡¹æˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸ªè¿™æ ·çš„é¡¹éƒ½ç¦»çº¿å­˜åˆ°å¯¹åº”çš„ l - 1 ä¸Šï¼Œç„¶åä»å°åˆ°å¤§æšä¸¾å¹¶æ‰«æçº¿å¤„ç†ã€‚å…¶å®ƒå‡ ä¸ªè½¬ç§»çš„æ–¹å‘ä¹Ÿéƒ½å¯ä»¥ç±»ä¼¼åœ°å¤„ç†ã€‚ <br>
æ¯æ¬¡æŸ¥è¯¢ä¸€ä¸ªåŒºé—´å†…æœ‰å¤šå°‘å¯¹ (i, j) æ»¡è¶³ l <= i < j <= r ä¸” w[i] ^ w[j] åœ¨äºŒè¿›åˆ¶ä¸‹æœ‰ k ä¸ªä¸€
```cpp
int n, m, k, len;
int w[N];
LL ans[N];
struct Query {
    int id, l, r;
    LL res;
} q[N];
struct Range {
    int id, l, r, t; // t ç­‰äº -1 ä»£è¡¨å‡å»ï¼Œç­‰äº 1 ä»£è¡¨åŠ ä¸Š
};
vector<Range> range[N];
int f[N], g[N];
int get_count(int x) {
    int res = 0;
    while (x) {
        res += x & 1;
        x >>= 1;
    }
    return res;
}
int get(int x) {
    return x / len;
}
bool cmp(Query a, Query b) {
    int i = get(a.l), j = get(b.l);
    if (i != j) return i < j;
    else return a.r < b.r;
}
void solve() {
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) cin >> w[i];
    vector<int> nums;
    for (int i = 0; i < 1 << 14; i++) {
        if (get_count(i) == k) nums.push_back(i);
    }
    for (int i = 1; i <= n; i++) {
        for (auto y : nums) g[w[i] ^ y]++;
        f[i] = g[w[i + 1]];
    }
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        q[i] = {i, l, r};
    }
    len = sqrt(n) + 1;
    sort(q, q + m, cmp);
    for (int i = 0, L = 1, R = 0; i < m; i++) {
        int id = q[i].id, l = q[i].l, r = q[i].r;
        if (R < r) range[L - 1].push_back({i, R + 1, r, -1});
        while (R < r)  q[i].res += f[R++];
        if (R > r) range[L - 1].push_back({i, r + 1, R, 1});
        while (R > r) q[i].res -= f[--R];
        if (L < l) range[R].push_back({i, L, l - 1, -1});
        while (L < l) q[i].res += f[L - 1] + !k, L++;
        if (L > l) range[R].push_back({i, l, L - 1, 1});
        while (L > l) q[i].res -= f[L - 2] + !k, L--;
    }
    memset(g, 0, sizeof(g));
    for (int i = 1; i <= n; i++) {
        for (auto y: nums) g[w[i] ^ y]++;
        for (auto& rg: range[i]) {
            int id = rg.id, l = rg.l, r = rg.r, t = rg.t;
            for (int x = l; x <= r; x++) q[id].res += g[w[x]] * t;
        }
    }
    for (int i = 1; i < m; i++) q[i].res += q[i - 1].res;
    for (int i = 0; i < m; i++) ans[q[i].id] = q[i].res;
    for (int i = 0; i < m; i++) cout << ans[i] << '\n';
}
```

### æ ‘é“¾å‰–åˆ†
å°†ä¸€æ£µæ ‘è½¬åŒ–æˆä¸€ä¸ªåºåˆ—, å°†ä¸€ä¸ªè·¯å¾„è½¬åŒ–ä¸º log æ®µçš„åŒºé—´ <br>
æ”¯æŒè·¯å¾„åŠ ï¼Œè·¯å¾„æ±‚å’Œï¼Œå­æ ‘åŠ ï¼Œå­æ ‘æ±‚å’Œ <br>
```cpp
int n, m, root; // n ä¸ªç‚¹ m ä¸ªæ“ä½œæ ¹èŠ‚ç‚¹ä¸º root
int w[N], id[N], nw[N], cnt; // w ç‚¹æƒ nw æ–°çš„æƒå€¼
int dep[N], sz[N], top[N], fa[N], son[N];
vector<int> adj[N];
struct Tree {
    int l, r;
    i64 add, sum;
} tr[N * 4];
void dfs1(int u, int father, int depth) { // æ›´æ–° depï¼Œfaï¼Œszï¼Œson çš„ä¿¡æ¯
    dep[u] = depth, fa[u] = father, sz[u] = 1;
    for (auto v : adj[u]) {
        if (v == father) continue;
        dfs1(v, u, depth + 1);
        sz[u] += sz[v];
        if (sz[son[u]] < sz[v]) son[u] = v;
    }
}
void dfs2(int u, int t) { // t æ˜¯å½“å‰ç‚¹æ‰€åœ¨é‡é“¾çš„é¡¶ç‚¹
    id[u] = ++cnt, nw[cnt] = w[u], top[u] = t;
    if (!son[u]) return;
    dfs2(son[u], t);
    for (auto v : adj[u]) {
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}
void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}
void pushdown(int u) {
    auto &root = tr[u], &le = tr[u << 1], &ri = tr[u << 1 | 1];
    if (root.add) {
        le.add += root.add, le.sum += root.add * (le.r - le.l + 1);
        ri.add += root.add, ri.sum += root.add * (ri.r - ri.l + 1);
        root.add = 0;
    }
}
void build(int u, int l, int r) {
    tr[u] = {l, r, 0, nw[r]};
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}
void update(int u, int l, int r, int k) {
    if (l <= tr[u].l && r >= tr[u].r) {
        tr[u].add += k;
        tr[u].sum += (i64)k * (tr[u].r - tr[u].l + 1);
        return;
    } 
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) update(u << 1, l, r, k);
    if (r > mid) update(u << 1 | 1, l, r, k);
    pushup(u);
}
i64 query(int u, int l, int r) {
    if (l <= tr[u].l && r >= tr[u].r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    i64 res = 0;
    if (l <= mid) res += query(u << 1, l, r);
    if (r > mid) res += query(u << 1 | 1, l, r);
    return res;
}
void update_path(int u, int v, int k) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        update(1, id[top[u]], id[u], k);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v); // id[v] ä¸ºåŸå§‹ (u,v) çš„ lca
    update(1, id[v], id[u], k);
}
i64 query_path(int u, int v) {
    i64 res = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += query(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    res += query(1, id[v], id[u]);
    return res;
}
void update_tree(int u, int k) {
    update(1, id[u], id[u] + sz[u] - 1, k);
}
i64 query_tree(int u) {
    return query(1, id[u], id[u] + sz[u] - 1);
}
void solve() {
    int p;
    cin >> n >> m >> root;
    for (int i = 1; i <= n; i++) cin >> w[i];
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b), adj[b].push_back(a);
    }    
    dfs1(root, 0, 1);
    dfs2(root, root);
    build(1, 1, n);
    while (m--) {
        int op, u, v, k;
        cin >> op;
        if (op == 1) { // è·¯å¾„åŠ  k
            cin >> u >> v >> k;
            update_path(u, v, k);
        }
        else if (op == 2) { // è¾“å‡ºè·¯å¾„æƒå€¼å’Œ
            cin >> u >> v;
            cout << query_path(u, v) << '\n';
        }
        else if (op == 3) { // å­æ ‘åŠ  k
            cin >> u >> k;
            update_tree(u, k);
        }
        else {
            cin >> u;
            cout << query_tree(u) << '\n';
        }
    }
}
```

### æ ‘å¥—æ ‘

#### æ”¯æŒå•ç‚¹ä¿®æ”¹ï¼ŒæŸ¥è¯¢ä¸€ä¸ªåŒºé—´å†…çš„å‰é©±
```cpp
int n, m;
struct Tree {
    int l, r;
    multiset<int> s;
} tr[N * 4];
int w[N];
void build(int u, int l, int r) {
    tr[u] = {l, r};
    tr[u].s.insert(INF), tr[u].s.insert(-INF);
    for (int i = l; i <= r; i++) tr[u].s.insert(w[i]);
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}
void change(int u, int p, int x) {
    tr[u].s.erase(tr[u].s.find(w[p]));
    tr[u].s.insert(x);
    if (tr[u].l == tr[u].r) return;
    int mid = tr[u].l + tr[u].r >> 1;
    if (p <= mid) change(u << 1, p, x);
    else change(u << 1 | 1, p, x);
}
int query(int u, int a, int b, int x) {
    if (tr[u].l >= a && tr[u].r <= b) {
        auto it = tr[u].s.lower_bound(x);
        it--;
        return *it;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    int res = -INF;
    if (a <= mid) res = max(res, query(u << 1, a, b, x));
    if (b > mid) res = max(res, query(u << 1 | 1, a, b, x));
    return res;
}
void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> w[i];
    build(1, 1, n);
    while (m--) {
        int op;
        cin >> op;
        if (op == 1) { // ä¿®æ”¹ä¸€ä¸ªç‚¹
            int pos, x;
            cin >> pos >> x;
            change(1, pos, x);
            w[pos] = x;
        }
        else { // æŸ¥è¯¢åŒºé—´ä¸­çš„å‰é©±
            int l, r, x;
            cin >> l >> r >> x;
            cout << query(1, l, r, x) << '\n';
        }
    }
}
```

1.æŸ¥è¯¢ k åœ¨åŒºé—´çš„æ’å <br>
2.æŸ¥è¯¢åŒºé—´æ’åä¸º k çš„æ•° <br>
3.ä¿®æ”¹æŸä¸€ä½ç½®ä¸Šçš„æ•° <br>
4.æŸ¥è¯¢ k åœ¨åŒºé—´çš„å‰é©± <br>
5.æŸ¥è¯¢ k åœ¨åŒºé—´çš„åç»§ <br>
```cpp
int n, m;
struct Node {
    int s[2], v, p, sz;
    void init(int _v, int _p) {
        v = _v, p = _p;
        sz = 1;
    }
} tr[N];
int L[N], R[N], T[N], idx;
int w[N];
void pushup(int x) {
    tr[x].sz = tr[tr[x].s[0]].sz + tr[tr[x].s[1]].sz + 1;
}
void rotate(int x) {
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}
void splay(int& root, int x, int k) {
    while (tr[x].p != k) {
        int y = tr[x].p, z = tr[y].p;
        if (z != k) {
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
    if (!k) root = x;
}
void insert(int& root, int v) {
    int u = root, p = 0;
    while (u) p = u, u = tr[u].s[v > tr[u].v];
    u = ++ idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(root, u, 0);
}
int get_k(int root, int v) {
    int u = root, res = 0;
    while (u) {
        if (tr[u].v < v) res += tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}
void update(int& root, int x, int y) {
    int u = root;
    while (u) {
        if (tr[u].v == x) break;
        if (tr[u].v < x) u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    splay(root, u, 0);
    int l = tr[u].s[0], r = tr[u].s[1];
    while (tr[l].s[1]) l = tr[l].s[1];
    while (tr[r].s[0]) r = tr[r].s[0];
    splay(root, l, 0), splay(root, r, l);
    tr[r].s[0] = 0;
    pushup(r), pushup(l);
    insert(root, y);
}
void build(int u, int l, int r) {
    L[u] = l, R[u] = r;
    insert(T[u], -INF), insert(T[u], INF);
    for (int i = l; i <= r; i++) insert(T[u], w[i]);
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}
int query(int u, int a, int b, int x) {
    if (L[u] >= a && R[u] <= b) return get_k(T[u], x) - 1;
    int mid = L[u] + R[u] >> 1;
    int res = 0;
    if (a <= mid) res += query(u << 1, a, b, x);
    if (b > mid) res += query(u << 1 | 1, a, b, x);
    return res;
}
void change(int u, int p, int x) {
    update(T[u], w[p], x);
    if (L[u] == R[u]) return;
    int mid = L[u] + R[u] >> 1;
    if (p <= mid) change(u << 1, p, x);
    else change(u << 1 | 1, p, x);
}
int get_pre(int root, int v) {
    int u = root, res = -INF;
    while (u) {
        if (tr[u].v < v) res = max(res, tr[u].v), u = tr[u].s[1];
        else u = tr[u].s[0];
    }
    return res;
}
int get_suc(int root, int v) {
    int u = root, res = INF;
    while (u) {
        if (tr[u].v > v) res = min(res, tr[u].v), u = tr[u].s[0];
        else u = tr[u].s[1];
    }
    return res;
}
int query_pre(int u, int a, int b, int x) {
    if (L[u] >= a && R[u] <= b) return get_pre(T[u], x);
    int mid = L[u] + R[u] >> 1;
    int res = -INF;
    if (a <= mid) res = max(res, query_pre(u << 1, a, b, x));
    if (b > mid) res = max(res, query_pre(u << 1 | 1, a, b, x));
    return res;
}
int query_suc(int u, int a, int b, int x) {
    if (L[u] >= a && R[u] <= b) return get_suc(T[u], x);
    int mid = L[u] + R[u] >> 1;
    int res = INF;
    if (a <= mid) res = min(res, query_suc(u << 1, a, b, x));
    if (b > mid) res = min(res, query_suc(u << 1 | 1, a, b, x));
    return res;
}
void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> w[i];
    build(1, 1, n);
    while (m--) {
        int op;
        cin >> op;
        if (op == 1) {
            int l, r, x;
            cin >> l >> r >> x;
            cout << query(1, l, r, x) + 1 << '\n';
        }
        else if (op == 2) {
            int a, b, k;
            cin >> a >> b >> k;
            int l = 0, r = 1e8;
            while (l < r) {
                int mid = l + r + 1 >> 1;
                if (query(1, a, b, mid) + 1 <= k) l = mid;
                else r = mid - 1;
            }
            cout << r << '\n';
        }
        else if (op == 3) {
            int pos, x;
            cin >> pos >> x;
            change(1, pos, x);
            w[pos] = x;
        }
        else if (op == 4) {
            int l, r, x;
            cin >> l >> r >> x;
            int ans = query_pre(1, l, r, x);
            if (ans == -INF) cout << -2147483647 << '\n';
            else cout << ans << '\n';
        }
        else {
            int l, r, x;
            cin >> l >> r >> x;
            int ans = query_suc(1, l, r, x);
            if (ans == INF) cout << 2147483647 << '\n';
            else cout << ans << '\n';
        }
    }
}
```

### æ ‘çŠ¶æ•°ç»„

#### ä¸€ç»´æ ‘çŠ¶æ•°ç»„
```cpp
i64 tr[N];
void add(int x, i64 k) {  
    for (int i = x; i <= n; i += i & (-i)) {
        tr[i] += k;
    }
}
i64 query(int x) {   
    i64 res = 0;
    for (int i = x; i; i -= i & (-i)) res += tr[i];
    return res;
}
i64 query(int l, int r) { 
    if (l == 1) return query(r);
    else return query(r) - query(l - 1);
}
```

#### åŒºé—´ç§ç±»æ•°
```cpp
const int N = 1e6 + 10;
int la[N], tr[N];
void add(int x, int k) {
    for (int i = x; i <= 1e6; i += i & (-i)) {
        tr[i] += k;
    }
}
int query(int x) {
    int res = 0;
    for (int i = x; i; i -= i & (-i)) res += tr[i];
    return res;
}
int query(int l, int r) {
    return query(r) - query(l - 1);
}
void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) cin >> a[i];
    int m;
    cin >> m;
    vector<array<int, 4>> q(m);
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        q[i] = {l, r, i, 0};
    }
    sort(q.begin(), q.end(), [&](array<int, 4> a, array<int, 4> b) {
        return a[1] < b[1];
    });
    int now = -1;
    for (int i = 1; i <= n; i++) {
        if (la[a[i]]) add(la[a[i]], -1);
        add(i, 1);
        la[a[i]] = i;
        while (now + 1 < m && q[now + 1][1] == i) {
            now++;
            q[now][3] = query(q[now][0], q[now][1]);
        }
    }
    sort(q.begin(), q.end(), [&](array<int, 4> a, array<int, 4> b) {
        return a[2] < b[2];
    });
    for (auto &[l, r, id, ans] : q) cout << ans << '\n';
}
```

#### åŒºé—´åŠ  åŒºé—´æŸ¥è¯¢
$$
\begin{aligned}
\text{ä½ç½® } p \text{ çš„å‰ç¼€å’Œ}
&= \sum_{i=1}^{p} a[i] = \sum_{i=1}^{p} \sum_{j=1}^{i} d[j] = \sum_{i=1}^{p} d[i]\,(p - i + 1) \\
&= (p + 1)\sum_{i=1}^{p} d[i] \;-\; \sum_{i=1}^{p} i\,d[i].
\end{aligned}
$$
```cpp
const int N = 1e5 + 10;
int n, m;
i64 a[N], tr1[N], tr2[N]; 
void add(int x, i64 k) {
    for (int i = x; i <= n; i += i & (-i)) {
        tr1[i] += k;
        tr2[i] += x * k;
    }
}
i64 query(int x) {
    i64 res = 0;
    for (int i = x; i; i -= i & (-i)) {
        res += tr1[i] * (x + 1);
        res -= tr2[i];
    }
    return res;
}
void add(int l, int r, i64 k) {
    add(l, k);
    add(r + 1, -k);
}
i64 query(int l, int r) {
    return query(r) - query(l - 1);
}
void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = n; i >= 2; i--) a[i] -= a[i - 1];
    for (int i = 1; i <= n; i++) add(i, a[i]);
    while (m--) {
        int op, x, y;
        cin >> op >> x >> y;
        if (op == 1) {
            i64 k;
            cin >> k;
            add(x, y, k);
        }
        else cout << query(x, y) << '\n';
    }
}
```

#### äºŒç»´æ ‘çŠ¶æ•°ç»„
```cpp
i64 tr[N][N];
void add(int x, int y, i64 k) {
    for (int i = x; i <= n; i += i & (-i)) {
        for (int j = y; j <= m; j += j & (-j)) {
            tr[i][j] += k;
        } 
    }
}
i64 query(int x, int y) {
    i64 res = 0;
    for (int i = x; i; i -= i & (-i)) {
        for (int j = y; j; j -= j & (-j)) {
            res += tr[i][j];
        }
    }
    return res;
}
i64 query(int a, int b, int c, int d) {
    return query(c, d) - query(c, b - 1) - query(a - 1, d) + query(a - 1, b - 1);
}
```

#### åŒºåŸŸåŠ  åŒºåŸŸæŸ¥è¯¢
äºŒç»´æ•°ç»„ä¸Šçš„å·®åˆ†æ•°ç»„ï¼š$ğ‘‘(ğ‘–,ğ‘—) = ğ‘(ğ‘–,ğ‘—) âˆ’ ğ‘(ğ‘–âˆ’1,ğ‘—) âˆ’ ğ‘(ğ‘–,ğ‘—âˆ’1) + ğ‘(ğ‘–âˆ’1,ğ‘—âˆ’1)$ <br>
$$
\begin{aligned}
\sum_{i=1}^{x}\sum_{j=1}^{y}\sum_{h=1}^{i}\sum_{k=1}^{j} d(h,k)
&= \sum_{i=1}^{x}\sum_{j=1}^{y} d(i,j)\,(x-i+1)\,(y-j+1) \\
&= \sum_{i=1}^{x}\sum_{j=1}^{y} \Big(d(i,j)\,(xy+x+y+1) - d(i,j)\,i\,(y+1) - d(i,j)\,j\,(x+1) + d(i,j)\,i\,j\Big).
\end{aligned}
$$
```cpp
i64 tr1[N][N], tr2[N][N], tr3[N][N], tr4[N][N]; 
void add(int x, int y, i64 k) {
    for (int i = x; i <= n; i += i & (-i)) {
        for (int j = y; j <= m; j += j & (-j)) {
            tr1[i][j] += k;
            tr2[i][j] += k * x;
            tr3[i][j] += k * y;
            tr4[i][j] += k * x * y;
        }
    }
}
i64 query(int x, int y) {
    i64 res = 0;
    for (int i = x; i; i -= i & (-i)) {
        for (int j = y; j; j -= j & (-j)) {
            res += tr1[i][j] * (x + 1) * (y + 1) - tr2[i][j] * (y + 1) -
                   tr3[i][j] * (x + 1) + tr4[i][j];
        }
    }
    return res;
}
void add(int a, int b, int c, int d, i64 k) {
    add(a, b, k);
    add(a, d + 1, -k);
    add(c + 1, b, -k);
    add(c + 1, d + 1, k);
}
i64 query(int a, int b, int c, int d) {
    return query(c, d) - query(c, b - 1) - query(a - 1, d) + query(a - 1, b - 1);
}
```

### çº¿æ®µæ ‘
#### æ±‚åŒºé—´æœ€å¤§è¿ç»­å­æ®µå’Œ
```cpp
int w[N];
struct Node { 
    int l, r;
    int sum, lmax, rmax, tmax;
} tr[N * 4];
void pushup(int u) {
    auto &le = tr[u << 1], &ri = tr[u << 1 | 1], &rt = tr[u];
    rt.sum = le.sum + ri.sum;
    rt.lmax = max(le.lmax, le.sum + ri.lmax);
    rt.rmax = max(ri.rmax, ri.sum + le.rmax);
    rt.tmax = max({le.tmax, ri.tmax, le.rmax + ri.lmax});
}
void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, r, w[r], w[r], w[r], w[r]};
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
Node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    int mid = tr[u].l + tr[u].r >> 1;
    if (r <= mid) return query(u << 1, l, r);
    else if (l > mid) return query(u << 1 | 1, l, r);
    else {
        auto le = query(u << 1, l, r);
        auto ri = query(u << 1 | 1, l, r);
        Node res;
        res.sum = le.sum + ri.sum;
        res.lmax = max(le.lmax, le.sum + ri.lmax);
        res.rmax = max(ri.rmax, ri.sum + le.rmax);
        res.tmax = max({le.tmax, ri.tmax, le.rmax + ri.lmax});
        return res;
    }
}
void modify(int u, int x, int v) {
    if (tr[u].l == x && tr[u].r == x) tr[u] = {x, x, v, v, v, v};
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}
```

#### åŒºé—´æœ€å¤§å…¬çº¦æ•° æ”¯æŒåŒºé—´åŠ 
```cpp
i64 w[N];
struct Node {
    int l, r;
    i64 sum, d;
} tr[N * 4];
void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
    tr[u].d = __gcd(tr[u << 1].d, tr[u << 1 | 1].d);
}
void build(int u, int l, int r) {
    if (l == r) {
        i64 b = w[r] - w[r - 1];
        tr[u] = {l, r, b, b};
    }
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
} 
void modify(int u, int x, i64 v) {
    if (tr[u].l == x && tr[u].r == x) {
        i64 b = tr[u].sum + v;
        tr[u] = {x, x, b, b};
    }
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}
Node query(int u, int l, int r) {
    if (l > r) return {0};
    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (r <= mid) return query(u << 1, l, r);
        else if (l > mid) return query(u << 1 | 1, l, r);
        else {
            auto le = query(u << 1, l, r);
            auto ri = query(u << 1 | 1, l, r);
            Node res;
            res.sum = le.sum + ri.sum;
            res.d = __gcd(le.d, ri.d);
            return res;
        }
    }
}
void solve() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> w[i];
    build(1, 1, n);
    while (m--) {
        char op;
        int l, r;
        cin >> op >> l >> r;
        if (op == 'Q') {
            auto le = query(1, 1, l);
            auto ri = query(1, l + 1, r);
            cout << abs(__gcd(le.sum, ri.d)) << '\n';
        }
        else {
            i64 k;
            cin >> k;
            modify(1, l, k);
            if (r + 1 <= n) modify(1, r + 1, -k);
        }
    }
}
```

#### åŒºé—´åŠ ï¼ŒåŒºé—´æ±‚å’Œ
```cpp
i64 w[N];
struct Node {
    int l, r;
    i64 sum, add;
} tr[N * 4];
void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}
void pushdown(int u) {
    auto &root = tr[u], &le = tr[u << 1], &ri = tr[u << 1 | 1];
    if (root.add) {
        le.add += root.add, le.sum += i64(le.r - le.l + 1) * root.add;
        ri.add += root.add, ri.sum += i64(ri.r - ri.l + 1) * root.add;
        root.add = 0;
    }
}
void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, l, w[l], 0};
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, i64 v) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].sum += i64(tr[u].r - tr[u].l + 1) * v;
        tr[u].add += v;
    }
    else { // ä¸€å®šè¦åˆ†è£‚
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, v);
        if (r > mid) modify(u << 1 | 1, l, r, v);
        pushup(u);
    }
}   
i64 query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    i64 sum = 0;
    if (l <= mid) sum += query(u << 1, l, r);
    if (r > mid) sum += query(u << 1 | 1, l, r);
    return sum;
}
```

#### åŒºé—´åŠ , åŒºé—´æå€¼
```cpp
struct Node {
    int l, r;
    i64 add, low, lownum; // åŒºé—´æå°å€¼å’Œæå°å€¼ä¸ªæ•°
} tr[N * 4];
void pushup(int u) {
    if (tr[u << 1].low < tr[u << 1 | 1].low) {
        tr[u].low = tr[u << 1].low;
        tr[u].lownum = tr[u << 1].lownum;
    }
    else if (tr[u << 1].low > tr[u << 1 | 1].low) {
        tr[u].low = tr[u << 1 | 1].low;
        tr[u].lownum = tr[u << 1 | 1].lownum;
    }
    else {
        tr[u].low = tr[u << 1].low;
        tr[u].lownum = tr[u << 1].lownum + tr[u << 1 | 1].lownum;
    }
}
void pushdown(int u) {
    auto &root = tr[u], &le = tr[u << 1], &ri = tr[u << 1 | 1];
    if (root.add) {
        le.add += root.add, le.low += root.add;
        ri.add += root.add, ri.low += root.add;
        root.add = 0;
    }
}
void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, l, 0, 0, 1};
    else {
        tr[u] = {l, r, 0};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int v) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].low += v;
        tr[u].add += v;
    }
    else { // ä¸€å®šè¦åˆ†è£‚
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, v);
        if (r > mid) modify(u << 1 | 1, l, r, v);
        pushup(u);
    }
}  
i64 query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        if (tr[u].low == 0) return tr[u].lownum;
        else return 0;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    i64 sum = 0;
    if (l <= mid) sum += query(u << 1, l, r);
    if (r > mid) sum += query(u << 1 | 1, l, r);
    return sum;
}
```

#### åŒºé—´åŠ ï¼ŒåŒºé—´ä¹˜ï¼ŒåŒºé—´æ±‚å’Œ
```cpp
i64 w[N];
struct Node {
    int l, r;
    i64 sum, add, mul;
} tr[N * 4];
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % mod;
}
void eval(Node &t, i64 add, i64 mul) {
    t.sum = (t.sum * mul + add * (t.r - t.l + 1)) % mod;
    t.mul = t.mul * mul % mod;
    t.add = (t.add * mul + add) % mod;
}
void pushdown(int u) {
    eval(tr[u << 1], tr[u].add, tr[u].mul);
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul);
    tr[u].add = 0, tr[u].mul = 1;
}
void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, r, w[l], 0, 1};
    else {
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
// åŒºé—´åŠ  (add, 1) åŒºé—´ä¹˜ (0, mul)
void modify(int u, int l, int r, i64 add, i64 mul) {
    if (tr[u].l >= l && tr[u].r <= r) eval(tr[u], add, mul);
    else {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u);
    }
}
i64 query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    i64 sum = 0;
    if (l <= mid) sum += query(u << 1, l, r);
    if (r > mid) sum += query(u << 1 | 1, l, r);
    sum %= mod;
    return sum;
}
```

#### çº¿æ®µæ ‘äºŒåˆ†
```cpp
// æŸ¥è¯¢ l-r å†… ç¬¬ä¸€ä¸ªå¤§äº x çš„ä½ç½®
int query(int u, int l, int r, int x) {
	if (tr[u].maxv <= x) return -1; // å¦‚æœæ— æ•ˆå°±ç›´æ¥è¿”å› -1
    if (tr[u].l == tr[u].r) return tr[u].l;  // æ‰¾åˆ°ä¸€ä¸ªè§£
    else if (l <= tr[u].l && tr[u].r <= r) { // è¢«ç›®æ ‡åŒºé—´åŒ…å«ï¼Œå¯ä»¥æä¾›ä¿¡æ¯
        if (tr[u << 1].maxv > x) return query(u << 1, l, r, x); 
        else return query(u << 1 | 1, l, r, x);
    }
    else { // ä»…ç›¸äº¤ï¼Œè¦ç»§ç»­åˆ’åˆ†åŒºé—´ï¼Œç›´åˆ°è¢«åŒ…å«
        int mid = tr[u].l + tr[u].r >> 1;
        int res = -1;
        if (l <= mid) res = query(u << 1, l, r, x); // å»å«æœ‰çš„åŒºé—´å†…
        if (res == -1 && r > mid) res = query(u << 1 | 1, l, r, x); 
        return res;
    }
}
```

#### åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘
åŒºé—´åŠ ï¼ŒåŒºé—´æ±‚å’Œ <br>
ç©ºé—´å¯ä»¥å¼€ $4qlog(v)$ï¼Œä½†åº”è¯¥è®¡ç®—ç©ºé—´ï¼Œç„¶åå°½é‡å¼€å¤§ç‚¹
```cpp
struct Node {
    int lson, rson;
    i64 sum, add;
} tr[N];
int idx;
// æ–°å»ºèŠ‚ç‚¹æ—¶è¿˜è¦åˆå§‹åŒ–è¿™ä¸ªèŠ‚ç‚¹
int newnode(int l, int r) {
    ++idx;
    return idx;
}
void pushup(int u) {
    tr[u].sum = tr[tr[u].lson].sum + tr[tr[u].rson].sum;
}
void pushdown(int u, int l, int r) {
    int mid = l + r >> 1;
    if (!tr[u].lson) tr[u].lson = newnode(l, mid);
    if (!tr[u].rson) tr[u].rson = newnode(mid + 1, r);
    auto &root = tr[u], &le = tr[tr[u].lson], &ri = tr[tr[u].rson];
    if (root.add) {
        le.add += root.add, le.sum += (mid - l + 1) * root.add;
        ri.add += root.add, ri.sum += (r - mid) * root.add;
        root.add = 0;
    }
}
void modify(int u, int l, int r, int L, int R, i64 v) {
    if (l >= L && r <= R) {
        tr[u].sum += (r - l + 1) * v;
        tr[u].add += v;
        return;
    }
    pushdown(u, l, r);
    int mid = l + r >> 1;
    if (L <= mid) modify(tr[u].lson, l, mid, L, R, v);
    if (R > mid) modify(tr[u].rson, mid + 1, r, L, R, v);
    pushup(u);
}   
i64 query(int u, int l, int r, int L, int R) {
    if (l >= L && r <= R) return tr[u].sum;
    pushdown(u, l, r);
    int mid = l + r >> 1;
    i64 sum = 0;
    if (L <= mid) sum += query(tr[u].lson, l, mid, L, R);
    if (R > mid) sum += query(tr[u].rson, mid + 1, r, L, R);
    return sum;
}
void solve() {
    int n, m;
    cin >> n >> m;
    int rt = newnode(1, n);
    while (m--) {
        int op, l, r;
        cin >> op >> l >> r;
        if (op == 1) {
            int k;
            cin >> k;
            modify(rt, 1, n, l, r, k);
        }
        else cout << query(rt, 1, n, l, r) << '\n';
    }
}
```

#### å‰å¸æœºçº¿æ®µæ ‘
$O(m(logn)^2)$
```cpp
const i64 INF = 1e18;
int w[N];
struct Node {
    int l, r;
    // mx: åŒºé—´æœ€å¤§å€¼ mx_: åŒºé—´å†å²æœ€å¤§å€¼ se: åŒºé—´ä¸¥æ ¼æ¬¡å¤§å€¼ cntï¼šåŒºé—´æœ€å¤§å€¼çš„å‡ºç°æ¬¡æ•°
    i64 mx, mx_, se, cnt; 
    // sumï¼šåŒºé—´å’Œ add1ï¼šæœ€å¤§å€¼çš„åŠ æ ‡è®° add1_: æœ€å¤§å€¼çš„å†å²æœ€å¤§åŠ æ ‡è®° add2ï¼šéæœ€å¤§å€¼çš„åŠ æ ‡è®° add2_ï¼šéæœ€å¤§å€¼çš„å†å²æœ€å¤§åŠ æ ‡è®°
    i64 sum, add1, add1_, add2, add2_;
} tr[N * 4];
void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
    tr[u].mx_ = max(tr[u << 1].mx_, tr[u << 1 | 1].mx_);
    if (tr[u << 1].mx == tr[u << 1 | 1].mx) {
        tr[u].mx = tr[u << 1].mx;
        tr[u].se = max(tr[u << 1].se, tr[u << 1 | 1].se);
        tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;
    }
    else if (tr[u << 1].mx > tr[u << 1 | 1].mx) {
        tr[u].mx = tr[u << 1].mx;
        tr[u].se = max(tr[u << 1].se, tr[u << 1 | 1].mx);
        tr[u].cnt = tr[u << 1].cnt;
    }
    else {
        tr[u].mx = tr[u << 1 | 1].mx;
        tr[u].se = max(tr[u << 1].mx, tr[u << 1 | 1].se);
        tr[u].cnt = tr[u << 1 | 1].cnt;
    }
}
void update(int u, int k1, int k1_, int k2, int k2_) { // æœ€å¤§å€¼ç”¨ k1 éæœ€å¤§å€¼ç”¨ k2
    tr[u].sum += 1ll * k1 * tr[u].cnt + 1ll * k2 * (tr[u].r - tr[u].l + 1 - tr[u].cnt);
    tr[u].mx_ = max(tr[u].mx_, tr[u].mx + k1_);
    tr[u].add1_ = max(tr[u].add1_, tr[u].add1 + k1_);
    tr[u].mx += k1, tr[u].add1 += k1;
    tr[u].add2_ = max(tr[u].add2_, tr[u].add2 + k2_);
    if (tr[u].se != -INF) tr[u].se += k2;
    tr[u].add2 += k2;
}
void pushdown(int u) {
    i64 tmp = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
    if (tr[u << 1].mx == tmp) update(u << 1, tr[u].add1, tr[u].add1_, tr[u].add2, tr[u].add2_);
    else update(u << 1, tr[u].add2, tr[u].add2_, tr[u].add2, tr[u].add2_);
    if (tr[u << 1 | 1].mx == tmp) update(u << 1 | 1, tr[u].add1, tr[u].add1_, tr[u].add2, tr[u].add2_);
    else update(u << 1 | 1, tr[u].add2, tr[u].add2_, tr[u].add2, tr[u].add2_);
    tr[u].add1 = tr[u].add1_ = tr[u].add2 = tr[u].add2_ = 0;
}
void build(int u, int l, int r) {
    tr[u].l = l, tr[u].r = r;
    tr[u].add1 = tr[u].add1_ = tr[u].add2 = tr[u].add2_ = 0;
    if (l == r) {
        tr[u].sum = tr[u].mx_ = tr[u].mx = w[l];
        tr[u].se = -INF, tr[u].cnt = 1;
        return;
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}
void modify1(int u, int l, int r, int k) { // åŒºé—´åŠ 
    if (l <= tr[u].l && tr[u].r <= r) { 
        update(u, k, k, k, k); 
        return; 
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) modify1(u << 1, l, r, k);
    if (r > mid) modify1(u << 1 | 1, l, r, k);
    pushup(u);
}
void modify2(int u, int l, int r, int k) { // åŒºé—´æœ€å°å€¼
    if (k >= tr[u].mx) return;
    if (l <= tr[u].l && tr[u].r <= r && k > tr[u].se) { 
        update(u, k - tr[u].mx, k - tr[u].mx, 0, 0); 
        return; 
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) modify2(u << 1, l, r, k);
    if (r > mid) modify2(u << 1 | 1, l, r, k);
    pushup(u);
}
i64 query3(int u, int l, int r) { // åŒºé—´å’Œ
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    i64 sum = 0;
    if (l <= mid) sum += query3(u << 1, l, r);
    if (r > mid) sum += query3(u << 1 | 1, l, r);
    return sum;
}
i64 query4(int u, int l, int r) { // æŸ¥è¯¢åŒºé—´æœ€å¤§å€¼
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].mx;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    i64 mx = -INF;
    if (l <= mid) mx = max(mx, query4(u << 1, l, r));
    if (r > mid) mx = max(mx, query4(u << 1 | 1, l, r));
    return mx;
}
i64 query5(int u, int l, int r) { // æŸ¥è¯¢åŒºé—´å†å²æœ€å¤§å€¼
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].mx_;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    i64 mx = -INF;
    if (l <= mid) mx = max(mx, query5(u << 1, l, r));
    if (r > mid) mx = max(mx, query5(u << 1 | 1, l, r));
    return mx;
}
``` 

#### çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾
```cpp
int n;
vector<pair<int, int>> adj[8 * N + 1];
vector<int> id(N + 1);
struct Node {
    int l, r;
} tr[N * 4];
void build(int u, int l, int r) {
    tr[u] = {l, r};
    if (l == r) {
        id[l] = u;
        adj[n * 4 + u].push_back({u, 0});
        return;
    }
    int mid = l + r >> 1;
    adj[u << 1].push_back({u, 0});
    adj[u << 1 | 1].push_back({u, 0});
    adj[n * 4 + u].push_back({n * 4 + (u << 1), 0});
    adj[n * 4 + u].push_back({n * 4 + (u << 1 | 1), 0});
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}
void add(int u, int l, int r, int aim, int w, int type) { // type = 1: å•ç‚¹å‘åŒºé—´ type = 0: åŒºé—´å‘å•ç‚¹
    if (tr[u].l >= l && tr[u].r <= r) {
        if (type) adj[aim].push_back({4 * n + u, w});
        else adj[u].push_back({4 * n + aim, w});
        return;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) add(u << 1, l, r, aim, w, type);
    if (r > mid) add(u << 1 | 1, l, r, aim, w, type);
}
void solve() {
    int q, s;
    cin >> n >> q >> s;
    build(1, 1, n);
    while (q--) {
        int op;
        cin >> op;
        if (op == 1) {
            int v, u, w;
            cin >> v >> u >> w;
            adj[id[v]].push_back({n * 4 + id[u], w});
        }
        else if (op == 2) {
            int v, l, r, w;
            cin >> v >> l >> r >> w;
            add(1, l, r, id[v], w, 1);
        }
        else {
            int v, l, r, w;
            cin >> v >> l >> r >> w;
            add(1, l, r, id[v], w, 0);
        }
    }
    vector<i64> dis(8 * n + 1, 1e18);
    vector<bool> vis(8 * n + 1, 0);
    dis[id[s]] = 0;
    priority_queue<pair<i64, int>, vector<pair<i64, int>>, greater<pair<i64, int>>> qq;
    qq.push({0, id[s]});
    while (!qq.empty()) {
        auto [d, u] = qq.top();
        qq.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto &[v, w] : adj[u]) {
            if (dis[v] > d + w) {
                dis[v] = d + w;
                qq.push({dis[v], v});
            }
        } 
    }
    for (int i = 1; i <= n; i++) {
        i64 val = dis[id[i]];
        if (val >= 1e18 / 2) val = -1;
        cout << val << ' ';
    }
}
```

### å‹ç¼©Trieæ ‘
```cpp
// æ„å»ºå‹ç¼©å‰ç¼€æ ‘
void buildTrie(int u, int l, int r, int depth) {
    if (l == r) {
        leafPos[arr[l].id] = u;
        return;
    }
    int startDepth = depth;
    while (depth < (int)arr[l].s.size()
           && depth < (int)arr[r].s.size()
           && arr[l].s[depth] == arr[r].s[depth]) {
        ++depth;
    }
    // å¦‚æœæœ‰å…¬å…±å‰ç¼€ï¼Œå°±æ–°å»ºä¸­é—´èŠ‚ç‚¹
    if (depth > startDepth) {
        int v = ++nodeCnt;
        tree[u].children.push_back(v);
        tree[v].parent = u;
        u = v;
    }
    // æŒ‰ç¬¬ depth ä½åˆ†ç»„é€’å½’
    for (int i = l, j; i <= r; i = j) {
        j = i + 1;
        while (j <= r && arr[j].s[depth] == arr[i].s[depth]) {
            ++j;
        }
        int v = ++nodeCnt;
        tree[u].children.push_back(v);
        tree[v].parent = u;
        buildTrie(v, i, j - 1, depth + 1);
    }
}
```

### å·¦åæ ‘ã€å¯å¹¶å †
å¯¹äºä¸€æ£µäºŒå‰æ ‘ï¼Œæˆ‘ä»¬å®šä¹‰ å¤–èŠ‚ç‚¹ ä¸ºå­èŠ‚ç‚¹æ•°å°äºä¸¤ä¸ªçš„èŠ‚ç‚¹ï¼Œå®šä¹‰ä¸€ä¸ªèŠ‚ç‚¹çš„ dist ä¸ºå…¶åˆ°å­æ ‘ä¸­æœ€è¿‘çš„å¤–èŠ‚ç‚¹æ‰€ç»è¿‡çš„è¾¹çš„æ•°é‡ã€‚ç©ºèŠ‚ç‚¹çš„ dist ä¸º 0ã€‚å·¦åæ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œå®ƒä¸ä»…å…·æœ‰å †çš„æ€§è´¨ï¼Œå¹¶ä¸”æ˜¯ã€Œå·¦åã€çš„ï¼šæ¯ä¸ªèŠ‚ç‚¹å·¦å„¿å­çš„ dist éƒ½å¤§äºç­‰äºå³å„¿å­çš„ distã€‚å› æ­¤ï¼Œå·¦åæ ‘æ¯ä¸ªèŠ‚ç‚¹çš„ dist éƒ½ç­‰äºå…¶å³å„¿å­çš„ dist åŠ ä¸€ã€‚ <br>
åˆ é™¤æ ¹ åˆå¹¶æ ¹çš„å·¦å³å„¿å­å³å¯ã€‚ <br>
åˆ é™¤ä»»æ„èŠ‚ç‚¹ å…ˆå°†å·¦å³å„¿å­åˆå¹¶ï¼Œç„¶åè‡ªåº•å‘ä¸Šæ›´æ–° distã€ä¸æ»¡è¶³å·¦åæ€§è´¨æ—¶äº¤æ¢å·¦å³å„¿å­ï¼Œå½“ dist æ— éœ€æ›´æ–°æ—¶ç»“æŸé€’å½’ï¼š <br>
æ•´ä¸ªå †åŠ ä¸Š/å‡å»ä¸€ä¸ªå€¼ã€ä¹˜ä¸Šä¸€ä¸ªæ­£æ•° åœ¨æ ¹æ‰“ä¸Šæ ‡è®°ï¼Œåˆ é™¤æ ¹/åˆå¹¶å †ï¼ˆè®¿é—®å„¿å­ï¼‰æ—¶ä¸‹ä¼ æ ‡è®°å³å¯ <br>
```cpp
int n;
int v[N], dist[N], l[N], r[N], idx; // æƒå€¼ï¼Œè·ç¦»ï¼Œå·¦å„¿å­ï¼Œå³å„¿å­
int p[N]; // å¹¶æŸ¥é›†
bool st[N];
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
bool cmp(int x, int y) { // åˆ¤æ–­ x æ˜¯å¦å°äº y
    if (v[x] != v[y]) return v[x] < v[y];
    return x < y;
}
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (cmp(y, x)) swap(x, y);
    r[x] = merge(r[x], y);
    if (dist[r[x]] > dist[l[x]]) swap(r[x], l[x]);
    dist[x] = dist[r[x]] + 1;
    return x;
}
void solve() {
    cin >> n;
    while (n--) {
        int t;
        cin >> t;
        if (t == 1) { // æ–°å»ºå·¦åæ ‘å †
            int x;
            cin >> x;
            v[++idx] = x;
            dist[idx] = 1;
            p[idx] = idx;
        }
        else if (t == 2) { // å°†ç¬¬ x ä¸ªæ’å…¥çš„æ•°å’Œç¬¬ y ä¸ªæ’å…¥çš„æ•°æ‰€åœ¨çš„å·¦åæ ‘åˆå¹¶(å¦‚æœ x æˆ– y è¢«åˆ è¿‡äº†æˆ–è€… x å’Œ y åœ¨åŒä¸€ä¸ªå·¦åæ ‘ä¸Šå°±å¿½è§†)
            int x, y;
            cin >> x >> y;
            if (!st[x] && !st[y]) {
                x = find(x), y = find(y);
                if (x != y) {
                    if (cmp(y, x)) swap(x, y);
                    p[y] = x;
                    merge(x, y);
                }
            }
        }   
        else if (t == 3) { // è¾“å‡ºç¬¬ x ä¸ªæ•°æ‰€åœ¨å·¦åæ ‘çš„å †é¡¶
            int x;
            cin >> x;
            x = find(x);
            cout << v[x] << '\n';
        }
        else { // åˆ é™¤ç¬¬ x ä¸ªæ•°æ‰€åœ¨å·¦åæ ‘çš„æœ€å€¼ï¼ˆå¦‚æœç›¸åŒçš„æœ‰å¤šä¸ªåˆ é™¤æœ€æ—©æ’å…¥çš„æ•°ï¼‰å¦‚æœç¬¬ x ä¸ªæ•°å·²ç»è¢«åˆ é™¤è¾“å‡º -1
            int x;
            cin >> x;
            if (st[x]) {
                cout << -1 << '\n';
                continue;
            }
            x = find(x);
            st[x] = 1;
            int nowtop = merge(l[x], r[x]);
            p[nowtop] = nowtop, p[x] = nowtop;
        }
    }    
}
```

### CDQåˆ†æ²»

#### ä¸‰ç»´ååº
nlog^2 æ¯ä¸ªç‚¹æœ‰ä¸‰ä¸ªå±æ€§ï¼Œè¯•æ±‚ï¼šè¿™ä¸ªåºåˆ—é‡Œæœ‰å¤šå°‘å¯¹ç‚¹å¯¹ (i, j) æ»¡è¶³ 
$$
\mathrm{Count}
= \bigl|\{(i,j)\mid a_j\le a_i,\ b_j\le b_i,\ c_j\le c_i,\ j\neq i\}\bigr|
$$
```cpp
int n, m;
struct Data {
    int a, b, c, s, res;   // s æ˜¯å½“å‰ç‚¹å‡ºç°çš„æ¬¡æ•°ï¼Œres æ˜¯æ»¡è¶³ä¸‰ç»´ååºçš„ä¸ªæ•°
    bool operator< (const Data& t) const {
        if (a != t.a) return a < t.a;
        if (b != t.b) return b < t.b;
        return c < t.c;
    }
    bool operator== (const Data& t) {
        return (a == t.a && b == t.b && c == t.c); 
    }
} q[N], w[N]; // w æ˜¯å½’å¹¶æ’åºçš„è¾…åŠ©æ•°ç»„
int tr[M], ans[N];
int lowbit(int x) {
    return x & -x;
}
void add(int x, int v) {
    for (int i = x; i < M; i += lowbit(i)) tr[i] += v;
}
int query(int x) {
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}
void merge_sort(int l, int r) {
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(l, mid), merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (q[i].b <= q[j].b) add(q[i].c, q[i].s), w[k++] = q[i++];
        else q[j].res += query(q[j].c), w[k++] = q[j++];
    }
    while (i <= mid) add(q[i].c, q[i].s), w[k++] = q[i++];
    while (j <= r) q[j].res += query(q[j].c), w[k++] = q[j++];
    for (i = l; i <= mid; i++) add(q[i].c, -q[i].s);
    for (i = l, j = 0; j < k; i++, j++) q[i] = w[j];
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        q[i] = {a, b, c, 1};
    }
    sort(q, q + n);
    int k = 1;
    for (int i = 1; i < n; i++) {
        if (q[i] == q[k - 1]) q[k - 1].s++;
        else q[k++] = q[i];
    }
    merge_sort(0, k - 1);
    for (int i = 0; i < k; i++) ans[q[i].res + q[i].s - 1] += q[i].s;
    for (int i = 0; i < n; i++) cout << ans[i] << '\n';
}
```

#### äºŒç»´åŒºåŸŸå’Œã€äºŒç»´æ•°ç‚¹
```cpp
int n, m;
struct Data {
    int x, y, z, p, id, sign; // z è¡¨ç¤ºæ˜¯æŸ¥è¯¢ç‚¹è¿˜æ˜¯çœŸå®ç‚¹, p æ˜¯ç‚¹æƒå€¼, id æ˜¯æ¯ä¸ªç‚¹å±äºå“ªä¸ªè¯¢é—®ï¼Œsign è¡¨ç¤ºæ­£è´Ÿ
    LL sum;
    bool operator< (const Data& t) const {
        if (x != t.x) return x < t.x;
        if (y != t.y) return y < t.y;
        return z < t.z;
    }
} q[N], w[N];
LL ans[N];
void merge_sort(int l, int r) {
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(l, mid), merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    LL sum = 0;
    while (i <= mid && j <= r) {
        if (q[i].y <= q[j].y) sum += !q[i].z * q[i].p, w[k++] = q[i++];
        else q[j].sum += sum, w[k++] = q[j++];
    }
    while (i <= mid) sum += !q[i].z * q[i].p, w[k++] = q[i++];
    while (j <= r) q[j].sum += sum, w[k++] = q[j++];
    for (i = l, j = 0; j < k; i++, j++) q[i] = w[j];
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        int x, y, p;
        cin >> x >> y >> p;
        q[i] = {x, y, 0, p};
    }
    int k = n;
    for (int i = 1; i <= m; i++) {
        int x, y, xx, yy;
        cin >> x >> y >> xx >> yy;
        q[k++] = {xx, yy, 1, 0, i, 1};
        q[k++] = {x - 1, yy, 1, 0, i, -1};
        q[k++] = {xx, y - 1, 1, 0, i, -1};
        q[k++] = {x - 1, y - 1, 1, 0, i, 1};
    }
    sort(q, q + k);
    merge_sort(0, k - 1);
    for (int i = 0; i < k; i++) {
        if (q[i].z) {
            ans[q[i].id] += q[i].sum * q[i].sign;
        }
    }
    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
}
```

#### åŠ¨æ€é€†åºå¯¹
ç°åœ¨ç»™å‡º 1âˆ¼n çš„ä¸€ä¸ªæ’åˆ—ï¼ŒæŒ‰ç…§æŸç§é¡ºåºä¾æ¬¡åˆ é™¤ m ä¸ªå…ƒç´ ï¼Œä½ çš„ä»»åŠ¡æ˜¯åœ¨æ¯æ¬¡åˆ é™¤ä¸€ä¸ªå…ƒç´ ä¹‹å‰ç»Ÿè®¡æ•´ä¸ªåºåˆ—çš„é€†åºå¯¹æ•°ã€‚
```cpp
int n, m;
struct Data {
    int a, t, res; // å€¼ï¼Œæ—¶é—´æˆ³ï¼Œå½“å‰ç‚¹çš„é€†åºå¯¹æ•°
} q[N], w[N];
int tr[N], pos[N]; // pos æ˜¯å€¼å¯¹ä¸‹æ ‡çš„æ˜ å°„
LL ans[N];
int lowbit(int x) {
    return x & -x;
}
void add(int x, int v) {
    for (int i = x; i < N; i += lowbit(i)) tr[i] += v;
}
LL query(int x) {
    LL res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;  
}
void merge_sort(int l, int r) {
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(l, mid), merge_sort(mid + 1, r);
    int i = mid, j = r;
    while (i >= l && j >= mid + 1) {
        if (q[i].a > q[j].a) add(q[i].t, 1), i--;
        else q[j].res += query(q[j].t - 1), j--;
    } 
    while (j >= mid + 1) q[j].res += query(q[j].t - 1), j--;
    for (int k = i + 1; k <= mid; k++) add(q[k].t, -1);
    j = l, i = mid + 1;
    while (j <= mid && i <= r) {
        if (q[i].a < q[j].a) add(q[i].t, 1), i++;
        else q[j].res += query(q[j].t - 1), j++;
    }
    while (j <= mid) q[j].res += query(q[j].t - 1), j++;
    for (int k = mid + 1; k < i; k++) add(q[k].t, -1);
    i = l, j = mid + 1;
    int k = 0;
    while (i <= mid && j <= r) {
        if (q[i].a <= q[j].a) w[k++] = q[i++];
        else w[k++] = q[j++];
    }
    while (i <= mid) w[k++] = q[i++];
    while (j <= r) w[k++] = q[j++];

    for (i = l, j = 0; j < k; i++, j++) q[i] = w[j];
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> q[i].a;
        pos[q[i].a] = i;
    }
    for (int i = 0, j = n; i < m; i++) {
        int a;
        cin >> a;
        q[pos[a]].t = j--;
        pos[a] = -1;
    }
    for (int i = 1, j = n - m; i <= n; i++) {
        if (pos[i] != -1) {
            q[pos[i]].t = j--;
        }
    }
    merge_sort(0, n - 1);
    for (int i = 0; i < n; i++) ans[q[i].t] = q[i].res;
    for (int i = 2; i <= n; i++) ans[i] += ans[i - 1];
    for (int i = 0, j = n; i < m; i++, j--) cout << ans[j] << '\n';
}
```

### DSU on tree
æ±‚æ¯ä¸ªå­æ ‘ä¸Šé¢œè‰²å‡ºç°æ¬¡æ•°æœ€å¤šçš„ï¼Œæ‰€æœ‰é¢œè‰²ä¹‹å’Œ
```cpp
int n;
int h[N], e[M], ne[M], idx;
int color[N], cnt[N], sz[N], son[N];
LL ans[N], sum;
int mx; // é¢œè‰²å‡ºç°æœ€å¤§æ¬¡æ•°
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
int dfs_son(int u, int father) { // ç¡®å®šé‡å„¿å­
    sz[u] = 1;
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j == father) continue;
        sz[u] += dfs_son(j, u);
        if (sz[j] > sz[son[u]]) son[u] = j;
    }
    return sz[u];
}
void update(int u, int father, int sign, int pson) { // sign è¡¨ç¤ºåŠ æˆ–è€…æ¸…ç©º
    int c = color[u];
    cnt[c] += sign;
    if (cnt[c] > mx) mx = cnt[c], sum = c;
    else if (cnt[c] == mx) sum += c;
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j == father || j == pson) continue;
        update(j, u, sign, pson);
    }
}
void dfs(int u, int father, int op) { // op == 0 ä¸ºè½»å„¿å­ä¸éœ€ä¿ç•™ï¼Œop == 1 ä¸ºé‡å„¿å­è´¡çŒ®ä¿ç•™
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j == father || j == son[u]) continue;
        dfs(j, u, 0);
    }
    if (son[u]) dfs(son[u], u, 1);
    update(u, father, 1, son[u]);
    ans[u] = sum;
    if (!op) update(u, father, -1, 0), sum = mx = 0;
}
void solve() {
    cin >> n;
    memset(h, -1, sizeof(h));
    for (int i = 1; i <= n; i ++ ) cin >> color[i];
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    dfs_son(1, -1);
    dfs(1, -1, 1);
    for (int i = 1; i <= n; i++) cin >> ans[i];
}
```

### LCT
åŠ¨æ€æŸ¥è¯¢ä¸¤ç‚¹ä¹‹é—´æ˜¯å¦è¿é€šå¯ä»¥é€šè¿‡åˆ¤æ–­åŸæ ‘æ ¹èŠ‚ç‚¹æ˜¯å¦ç›¸åŒæ¥åˆ¤æ–­, å½“ç„¶ç”¨ lct åˆ¤æ–­æ•™æ…¢ï¼Œå¦‚æœåªæœ‰åŠ è¾¹å¯ä»¥ä½¿ç”¨å¹¶æŸ¥é›† <br>
æŸ¥è¯¢è·¯å¾„ç‚¹æƒå€¼å¼‚æˆ–å’Œï¼ŒåŠ¨æ€åŠ è¾¹ï¼Œåˆ è¾¹ï¼Œä¿®æ”¹ç‚¹æƒ <br>
```cpp
int n, m;
struct Node {
    int s[2], p, v;
    int sum, rev;
} tr[N];
int stk[N];
void pushrev(int x) {
    swap(tr[x].s[0], tr[x].s[1]);
    tr[x].rev ^= 1;
}
void pushup(int x) {
    tr[x].sum = tr[tr[x].s[0]].sum ^ tr[x].v ^ tr[tr[x].s[1]].sum;
}
void pushdown(int x) {
    if (tr[x].rev) {
        pushrev(tr[x].s[0]), pushrev(tr[x].s[1]);
        tr[x].rev = 0;
    }
}
bool isroot(int x) {
    return tr[tr[x].p].s[0] != x && tr[tr[x].p].s[1] != x;
}
void rotate(int x) {
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    if (!isroot(y)) tr[z].s[tr[z].s[1] == y] = x;
    tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}
void splay(int x) {
    int top = 0, r = x;
    stk[++top] = r;
    while (!isroot(r)) stk[++top] = r = tr[r].p;
    while (top) pushdown(stk[top--]);
    while (!isroot(x)) {
        int y = tr[x].p, z = tr[y].p;
        if (!isroot(y)) {
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
}
void access(int x) { // å»ºç«‹ä¸€æ¡ä»æ ¹åˆ° x çš„è·¯å¾„ï¼ŒåŒæ—¶å°† x å˜æˆ splay çš„æ ¹èŠ‚ç‚¹
    int z = x;
    for (int y = 0; x; y = x, x = tr[x].p) {
        splay(x);
        tr[x].s[1] = y, pushup(x);
    }
    splay(z);
}
void makeroot(int x) { // å°† x å˜æˆåŸæ ‘çš„æ ¹èŠ‚ç‚¹
    access(x);
    pushrev(x);
}
int findroot(int x) { // æ‰¾åˆ° x æ‰€åœ¨åŸæ ‘çš„æ ¹èŠ‚ç‚¹, å†å°†åŸæ ‘çš„æ ¹èŠ‚ç‚¹æ—‹è½¬åˆ° splay çš„æ ¹èŠ‚ç‚¹
    access(x);
    while (tr[x].s[0]) pushdown(x), x = tr[x].s[0];
    splay(x);
    return x;
}
void split(int x, int y) { // ç»™ x å’Œ y ä¹‹é—´çš„è·¯å¾„å»ºç«‹ä¸€ä¸ª splayï¼Œå…¶æ ¹èŠ‚ç‚¹æ˜¯ y
    makeroot(x);
    access(y);
}
void link(int x, int y) { // å¦‚æœ x å’Œ y ä¸è¿é€šï¼Œåˆ™åŠ å…¥ä¸€æ¡ x å’Œ y ä¹‹é—´çš„è¾¹
    makeroot(x);
    if (findroot(y) != x) tr[x].p = y;
}
void cut(int x, int y) { // å¦‚æœ x å’Œ y ä¹‹é—´å­˜åœ¨è¾¹ï¼Œåˆ™åˆ é™¤è¯¥è¾¹
    makeroot(x);
    if (findroot(y) == x && tr[y].p == x && !tr[y].s[0]) {
        tr[x].s[1] = tr[y].p = 0;
        pushup(x);
    }
}
void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> tr[i].v;
    while (m--) {
        int t, x, y;
        cin >> t >> x >> y;
        if (t == 0) {
            split(x, y);
            cout << tr[y].sum << '\n';
        }
        else if (t == 1) link(x, y);
        else if (t == 2) cut(x, y);
        else {
            splay(x);
            tr[x].v = y;
            pushup(x);
        }
    }
}
```

### Splay

#### åŒºé—´ç¿»è½¬
å¤šæ£µæ ‘æ—¶ root æ¢ä¸º root[b]
```cpp
int n, m;
struct Node {
    int s[2], p, v;
    int sz, flag;
    void init(int _v, int _p) {
        v = _v, p = _p;
        sz = 1;
    }
} tr[N];
int root, idx;
void pushup(int x) {
    tr[x].sz = tr[tr[x].s[0]].sz + tr[tr[x].s[1]].sz + 1;
}
void pushdown(int x) {
    if (tr[x].flag) {
        swap(tr[x].s[0], tr[x].s[1]);
        tr[tr[x].s[0]].flag ^= 1;
        tr[tr[x].s[1]].flag ^= 1;
        tr[x].flag = 0;
    }
}
void rotate(int x) {
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}
void splay(int x, int k) {
    while (tr[x].p != k) {
        int y = tr[x].p, z = tr[y].p;
        if (z != k) {
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
    if (!k) root = x;
}
void insert(int v) {
    int u = root, p = 0;
    while (u) {
        p = u;
        u = tr[u].s[v > tr[u].v] == p; // æŒ‰å€¼æ¯”è¾ƒæ—¶ u = tr[u].s[v > tr[u].v];
    }
    u = ++idx;
    if (p) tr[p].s[v > tr[p].v] = u;
    tr[u].init(v, p);
    splay(u, 0);
}
int get_k(int k) {
    int u = root; 
    while (1) {
        pushdown(u);
        if (tr[tr[u].s[0]].sz >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].sz + 1 == k) return u; // è¿”å›å€¼çœ‹é¢˜ç›®è¦æ±‚
        else {
            k -= tr[tr[u].s[0]].sz + 1;
            u = tr[u].s[1];
        }
    }
    return -1;
}
void output(int u) {
    pushdown(u);
    if (tr[u].s[0]) output(tr[u].s[0]);
    if (tr[u].v >= 1 && tr[u].v <= n) cout << tr[u].v << ' ';
    if (tr[u].s[1]) output(tr[u].s[1]);
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i <= n + 1; i++) insert(i); // å¤šæ’å…¥äº†æ— ç©·å°å’Œæ— ç©·å¤§
    while (m--) {
        int l, r;
        cin >> l >> r; // ç”±äºå­˜åœ¨æ— ç©·å°ï¼Œæ‰€ä»¥åº”è¯¥ä¿®æ”¹ l + 1 åˆ° r + 1, åº”è¯¥ä½¿ç”¨ l å’Œ r + 2
        l = get_k(l), r = get_k(r + 2);
        splay(l, 0), splay(r, l);
        tr[tr[r].s[0]].flag ^= 1;
    }
    output(root);
}
```

ç»´æŠ¤æ•°åˆ— <br>
1.åœ¨å½“å‰æ•°åˆ—çš„ç¬¬ pos ä¸ªæ•°å­—åæ’å…¥ tot ä¸ªæ•°å­— <br>
2.ä»å½“å‰æ•°åˆ—çš„ç¬¬ pos ä¸ªæ•°å­—å¼€å§‹åˆ é™¤ tot ä¸ªæ•°å­— <br>
3.å°†ä»å½“å‰æ•°åˆ—çš„ç¬¬ pos ä¸ªæ•°å­—å¼€å§‹çš„ tot ä¸ªæ•°å­—ä¿®æ”¹ä¸º c <br>
4.å°†ä»å½“å‰æ•°åˆ—çš„ç¬¬ pos ä¸ªæ•°å­—å¼€å§‹çš„ tot ä¸ªæ•°å­—ç¿»è½¬ <br>
5.è®¡ç®—ä»å½“å‰æ•°åˆ—çš„ç¬¬ pos ä¸ªæ•°å­—å¼€å§‹çš„ tot ä¸ªæ•°å­—çš„å’Œ <br>
6.æ±‚å‡ºæ•´ä¸ªåºåˆ—çš„æœ€å¤§å­æ®µå’Œ(è‡³å°‘åŒ…å«ä¸€ä¸ªæ•°å­—) <br>
```cpp
int n, m;
struct Node {
    int s[2], v, p;
    int rev, same;
    int sz, sum, ms, ls, rs;
    void init(int _v, int _p) {
        s[0] = s[1] = 0, v = _v, p = _p;
        rev = same = 0;
        sz = 1, sum = ms = v;
        ls = rs = max(v, 0);
    }
} tr[N];
int root, nodes[N], tt;
int w[N];
void pushup(int x) {
    auto &u = tr[x], &l = tr[u.s[0]], &r = tr[u.s[1]];
    u.sz = l.sz + r.sz + 1;
    u.sum = l.sum + r.sum + u.v;
    u.ls = max(l.ls, l.sum + u.v + r.ls);
    u.rs = max(r.rs, r.sum + u.v + l.rs);
    u.ms = max({l.ms, r.ms, l.rs + u.v + r.ls});
}
void pushdown(int x) {
    auto &u = tr[x], &l = tr[u.s[0]], &r = tr[u.s[1]];
    if (u.same) {
        u.same = u.rev = 0;
        if (u.s[0]) l.same = 1, l.v = u.v, l.sum = l.v * l.sz;
        if (u.s[1]) r.same = 1, r.v = u.v, r.sum = r.v * r.sz;
        if (u.v > 0) {
            if (u.s[0]) l.ms = l.ls = l.rs = l.sum;
            if (u.s[1]) r.ms = r.ls = r.rs = r.sum;
        }
        else {
            if (u.s[0]) l.ms = l.v, l.ls = l.rs = 0;
            if (u.s[1]) r.ms = r.v, r.ls = r.rs = 0;
        }
    }
    else if (u.rev) {
        u.rev = 0, l.rev ^= 1, r.rev ^= 1;
        swap(l.ls, l.rs), swap(r.ls, r.rs);
        swap(l.s[0], l.s[1]), swap(r.s[0], r.s[1]);
    }
}
void rotate(int x) {
    int y = tr[x].p, z = tr[y].p;
    int k = tr[y].s[1] == x;
    tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
    tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
    tr[x].s[k ^ 1] = y, tr[y].p = x;
    pushup(y), pushup(x);
}
void splay(int x, int k) {
    while (tr[x].p != k) {
        int y = tr[x].p, z = tr[y].p;
        if (z != k) {
            if ((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
            else rotate(y);
        }
        rotate(x);
    }
    if (!k) root = x;
}
int get_k(int k) {
    int u = root; 
    while (1) {
        pushdown(u);
        if (tr[tr[u].s[0]].sz >= k) u = tr[u].s[0];
        else if (tr[tr[u].s[0]].sz + 1 == k) return u;
        else {
            k -= tr[tr[u].s[0]].sz + 1;
            u = tr[u].s[1];
        }
    }
    return -1;
}
int build(int l, int r, int p) { // ä»¥ p ä¸ºçˆ¶äº²å»ºæ ‘
    int mid = l + r >> 1;
    int u = nodes[tt--];
    tr[u].init(w[mid], p);
    if (l < mid) tr[u].s[0] = build(l, mid - 1, u);
    if (r > mid) tr[u].s[1] = build(mid + 1, r, u);
    pushup(u);
    return u;
}
void dfs(int u) {
    if (tr[u].s[0]) dfs(tr[u].s[0]);
    if (tr[u].s[1]) dfs(tr[u].s[1]);
    nodes[++tt] = u;
}
void solve() {
    for (int i = 1; i < N; i++) nodes[++tt] = i; // åƒåœ¾å›æ”¶
    cin >> n >> m;
    tr[0].ms = w[0] = w[n + 1] = -INF;
    for (int i = 1; i <= n; i++) cin >> w[i];
    root = build(0, n + 1, 0);
    string op;
    while (m--) {
        cin >> op;
        if (op == "INSERT") {
            int pos, tot; // æ’å…¥ä½ç½®å’Œä¸ªæ•°
            cin >> pos >> tot;
            for (int i = 0; i < tot; i++) cin >> w[i];
            int l = get_k(pos + 1), r = get_k(pos + 2); // ç”±äºæœ‰å“¨å…µè¦åŠ  1
            splay(l, 0), splay(r, l);
            int u = build(0, tot - 1, r);
            tr[r].s[0] = u;
            pushup(r), pushup(l);
        }
        else if (op == "DELETE") {
            int pos, tot; // åˆ é™¤ä½ç½®å’Œä¸ªæ•°
            cin >> pos >> tot;
            int l = get_k(pos), r = get_k(pos + tot + 1);
            splay(l, 0), splay(r, l);
            dfs(tr[r].s[0]); // å°† r çš„å·¦å­æ ‘åˆ æ‰
            tr[r].s[0] = 0;
            pushup(r), pushup(l);
        }   
        else if (op == "MAKE-SAME") {
            int pos, tot, c;
            cin >> pos >> tot >> c;
            int l = get_k(pos), r = get_k(pos + tot + 1);
            splay(l, 0), splay(r, l);
            auto &son = tr[tr[r].s[0]];
            son.same = 1, son.v = c, son.sum = c * son.sz;
            if (c > 0) son.ms = son.ls = son.rs = son.sum;
            else son.ms = c, son.ls = son.rs = 0;
            pushup(r), pushup(l);
        }
        else if (op == "REVERSE") {
            int pos, tot;
            cin >> pos >> tot;
            int l = get_k(pos), r = get_k(pos + tot + 1);
            splay(l, 0), splay(r, l);
            auto &son = tr[tr[r].s[0]];
            son.rev ^= 1;
            swap(son.ls, son.rs);
            swap(son.s[0], son.s[1]);
            pushup(r), pushup(l);
        }
        else if (op == "GET-SUM") {
            int pos, tot;
            cin >> pos >> tot;
            int l = get_k(pos), r = get_k(pos + tot + 1);
            splay(l, 0), splay(r, l);
            cout << tr[tr[r].s[0]].sum << '\n';
        }
        else if (op == "MAX-SUM") cout << tr[root].ms << '\n';
    }
}
```

### STè¡¨
```cpp
void solve() {
    int n;
    cin >> n;
    vector<int> lg(n + 1, 0);
    vector<vector<int>> st(n + 1, vector<int> (20, 0));
    for (int i = 1; i <= n; i++) {
        cin >> st[i][0];
        if (i >= 2) lg[i] = lg[i >> 1] + 1;
    }
    for (int j = 1; j <= lg[n]; j++) {
        for (int i = 1; i <= n - (1 << j) + 1; i++) {
            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
    auto query = [&](int l, int r) -> int {
        int x = lg[r - l + 1];
        return max(st[l][x], st[r - (1 << x) + 1][x]);
    };
}
```

#### æœ€å°‘çº¿æ®µè¦†ç›–ç¯
çº¿æ®µä¹‹é—´äº’ä¸åŒ…å«ï¼Œè¾“å‡ºå¼ºåˆ¶é€‰æŸä¸ªçº¿æ®µåçš„æœ€å°å€¼
```cpp
void solve() {
    int n, m;
    cin >> n >> m;
    vector<array<i64, 3>> q(2 * n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> q[i][1] >> q[i][2];
        if (q[i][2] < q[i][1]) q[i][2] += m;
        q[i][0] = q[i + n][0] = i;
        q[i + n][1] = q[i][1] + m;
        q[i + n][2] = q[i][2] + m;
    }
    sort(q.begin() + 1, q.end(), [&](array<i64, 3> a, array<i64, 3> b) {
        return a[1] < b[1];
    });
    vector<int> lg(2 * n + 1, 0);
    vector<vector<int>> st(2 * n + 1, vector<int> (20, 0));
    for (int i = 1, j = 1; i <= 2 * n; i++) {
       if (i >= 2) lg[i] = lg[i >> 1] + 1;
        while (j < 2 * n && q[j + 1][1] <= q[i][2]) j++;
        st[i][0] = j;
    }       
    for (int j = 1; j <= lg[2 * n]; j++) {
        for (int i = 1; i <= 2 * n - (1 << j) + 1; i++) {
            st[i][j] = st[st[i][j - 1]][j - 1];
        }
    }
    vector<int> ans(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        int res = 1, pos = i;
        for (int j = 19; j >= 0; j--) {
            if (st[pos][j] && q[st[pos][j]][2] < q[i][1] + m) {
                res += 1 << j;
                pos = st[pos][j];
            }
        }
        ans[q[i][0]] = res + 1;
    }
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
}
```

### Treap
```cpp
int n;
struct Node {
    int l, r;
    int key, val;
    int cnt, sz;
} tr[N];
int root, idx;
bool exist;
void pushup(int p) {
    tr[p].sz = tr[tr[p].l].sz + tr[tr[p].r].sz + tr[p].cnt;
}
int get_node(int key) {
    tr[++idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].sz = 1;
    return idx;
}
void build() {
    get_node(-INF), get_node(INF);
    root = 1, tr[1].r = 2;
    pushup(root);
}
void zig(int &p) { // å³æ—‹
    int q = tr[p].l;
    tr[p].l = tr[q].r;
    tr[q].r = p;
    p = q;
    pushup(tr[p].r), pushup(p);
}
void zag(int &p) { // å·¦æ—‹
    int q = tr[p].r;
    tr[p].r = tr[q].l;
    tr[q].l = p;
    p = q;
    pushup(tr[p].l), pushup(p);
}
void insert(int &p, int key) {
    if (!p) p = get_node(key);
    else if (tr[p].key == key) tr[p].cnt++;
    else if (tr[p].key > key) {
        insert(tr[p].l, key);
        if (tr[tr[p].l].val > tr[p].val) zig(p);
    }
    else {
        insert(tr[p].r, key);
        if (tr[tr[p].r].val > tr[p].val) zag(p);
    }
    pushup(p);
}
void remove(int &p, int key) {
    if (!p) return;
    if (tr[p].key == key) {
        if (tr[p].cnt > 1) tr[p].cnt--;
        else if (tr[p].l || tr[p].r) {
            if (!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val) {
                zig(p);
                remove(tr[p].r, key);
            }
            else {
                zag(p);
                remove(tr[p].l, key);
            } 
        }
        else p = 0;
    }
    else if (tr[p].key > key) remove(tr[p].l, key);
    else remove(tr[p].r, key);
    pushup(p);
}
int get_rank_by_key(int p, int key) {
    if (!p) return 0;
    if (tr[p].key == key) {
        exist = 1;
        return tr[tr[p].l].sz + 1;
    }
    else if (tr[p].key > key) return get_rank_by_key(tr[p].l, key);
    else return tr[tr[p].l].sz + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}
int get_key_by_rank(int p, int rank) {
    if (!p) return INF;
    if (tr[tr[p].l].sz >= rank) return get_key_by_rank(tr[p].l, rank);
    else if (tr[tr[p].l].sz + tr[p].cnt >= rank) return tr[p].key;
    else return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].sz - tr[p].cnt);
}
int get_prev(int p, int key) {
    if (!p) return -INF;
    if (tr[p].key >= key) return get_prev(tr[p].l, key);
    else return max(tr[p].key, get_prev(tr[p].r, key));
}
int get_nxt(int p, int key) {
    if (!p) return INF;
    if (tr[p].key <= key) return get_nxt(tr[p].r, key);
    else return min(tr[p].key, get_nxt(tr[p].l, key));
}
void solve() {
    build();
    cin >> n;
    while (n--) {
        exist = 0;
        int opt, x;
        cin >> opt >> x;
        if (opt == 1) insert(root, x);
        else if (opt == 2) remove(root, x);
        else if (opt == 3) {
            int ans = get_rank_by_key(root, x) - 1;
            if (exist) cout << ans << '\n';
            else cout << ans + 1 << '\n';
        }
        else if (opt == 4) cout << get_key_by_rank(root, x + 1) << '\n';
        else if (opt == 5) cout << get_prev(root, x) << '\n';
        else cout << get_nxt(root, x) << '\n';
    }
}   
```

### Trie
0 å·ç‚¹æ—¢æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåˆæ˜¯ç©ºèŠ‚ç‚¹ <br>
son[][] å­˜å‚¨æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹ <br>
cnt[] å­˜å‚¨ä»¥æ¯ä¸ªèŠ‚ç‚¹ç»“å°¾çš„å•è¯æ•°é‡ <br>
```cpp
int son[N][26], cnt[N], idx;
// æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸²
void insert(string str) {
    int p = 0;
    int len = str.size();
    for (int i = 0; i < len; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
// æŸ¥è¯¢å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•°
int query(string str) {
    int p = 0;
    int len = str.size();
    for (int i = 0; i < len; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

#### æœ€å¤§å¼‚æˆ–å¯¹
```cpp
const int N = 1e5 + 10, M = 31 * N;
int n, a[N], son[M][2], idx;
void insert(int x) {
    int p = 0;
    for (int i = 30; i >= 0; i--) {
        int u = x >> i & 1;
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
}
int query(int x) {
    int p = 0;
    int res = 0;
    for (int i = 30; i >= 0; i--) {
        int u = x >> i & 1;
        if (son[p][!u]) {
            p = son[p][!u];
            res = res * 2 + !u;
        }
        else {
            p = son[p][u];
            res = res * 2 + u;
        }
    }
    return res;
}
void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        insert(a[i]);
    }
    i64 ans = 0;
    for (int i = 1; i <= n; i++) {
        i64 now = query(a[i]);
        ans = max(ans, a[i] ^ now);
    }
    cout << ans << '\n';
}
```