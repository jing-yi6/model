## 数学

### 本源勾股数
a是奇数, b是偶数，c是奇数 a * a + b * b = c * c <br>
a = s * t, c  = (s * s + t * t) / 2, b  = (s * s - t * t) / 2, t < s, t 和 s 为奇数且互素 <br>

### 多项式
65537 998244353 1004535809 4179340454199820289

#### NTT
```cpp
namespace NTT {
    int limit;
    vector<int> A, B, rev;
    inline int add(int x, int y) { return x += y, x >= mod ? x - mod : x; }
    inline int mul(int x, int y) { return 1ll * x * y % mod; }
    int qpow(int x, int y) {
        int res = 1;
        for (; y; y >>= 1, x = mul(x, x)) if (y & 1) res = mul(res, x);
        return res;
    }
    void init() {
        int ed = n * 2, bit = -1;
        for (limit = 1; limit <= ed; limit <<= 1) ++bit;
        A.resize(limit); B.resize(limit); rev.resize(limit);
        for (int i = 0; i < limit; ++i)    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << bit);
    }
    void ntt(vector<int>& P, int op) {
        for (int i = 0; i < limit; ++i) {
            if (i < rev[i])swap(P[i], P[rev[i]]);
        }
        for (int mid = 1; mid < limit; mid <<= 1) {
            int euler = qpow(3, (mod - 1) / (mid << 1));
            if (op < 0)    euler = qpow(euler, mod - 2);
            for (int i = 0, pos = mid << 1; i < limit; i += pos) {
                int wk = 1;
                for (int j = 0; j < mid; ++j, wk = mul(wk, euler)) {
                    int x = P[i + j], y = mul(wk, P[i + j + mid]);
                    P[i + j] = add(x, y), P[i + j + mid] = add(x, mod - y);
                }
            }
        }
        if (op > 0)    return;
        int inv = qpow(limit, mod - 2);
        for (int i = 0; i < limit; ++i)    P[i] = mul(P[i], inv);
    }
    void work() {
        for (int i = 0; i <= n; ++i) A[i] = i & 1 ? mod - infact[i] : infact[i];
        for (int i = 0; i <= n; ++i) B[i] = mul(g[i], infact[i]);
        ntt(A, 1), ntt(B, 1);
        for (int i = 0; i < limit; ++i) A[i] = mul(A[i], B[i]);
        ntt(A, -1);
    }
} using namespace NTT;
```
```cpp
namespace Polynomial {
    using Poly = std::vector<int>;
    constexpr int P(998244353), G(3), L(1 << 23); // L : max length of dft
    inline void inc(int &x, int y) { (x += y) >= P ? x -= P : 0; }
    inline int mod(int64_t x) { return x % P; }
    inline int fpow(int x, int k = P - 2) {
        int r = 1;
        for (; k; k >>= 1, x = 1LL * x * x % P)
            if (k & 1) r = 1LL * r * x % P;
        return r;
    }
    int w[L], _ = [] {
        w[L / 2] = 1;
        for (int i = L / 2 + 1, x = fpow(G, (P - 1) / L); i < L; i++) w[i] = 1LL * w[i - 1] * x % P;
        for (int i = L / 2 - 1; i >= 0; i--) w[i] = w[i << 1];
        return 0;
    }();
    void dft(int *a, int n) {  // 原地 NTT（前置 assert：n 必须是 2 的幂）
        assert((n & n - 1) == 0);
        for (int k = n >> 1; k; k >>= 1) {
            for (int i = 0; i < n; i += k << 1) {
                for (int j = 0; j < k; j++) {
                    int y = a[i + j + k];
                    a[i + j + k] = 1LL * (a[i + j] - y + P) * w[k + j] % P;
                    inc(a[i + j], y);
                }
            }
        }
    }
    void idft(int *a, int n) {  //原地逆 NTT；末尾乘 n⁻¹ 并做一次 反转
        assert((n & n - 1) == 0);
        for (int k = 1; k < n; k <<= 1) {
            for (int i = 0; i < n; i += k << 1) {
                for (int j = 0; j < k; j++) {
                    int x = a[i + j], y = 1LL * a[i + j + k] * w[k + j] % P;
                    a[i + j + k] = x - y < 0 ? x - y + P : x - y;
                    inc(a[i + j], y);
                }
            }
        }
        for (int i = 0, inv = P - (P - 1) / n; i < n; i++) a[i] = 1LL * a[i] * inv % P;
        std::reverse(a + 1, a + n);
    }
    // 做 “半宽 DFT” → “再卷一次点” 可把长度 n 的 DFT 拓成 2n，在半分治求指数的场景中常用（你后面的 exp2/exp 用到）
    void dftDoubling(int *a, int n) {  
        std::copy_n(a, n, a + n);
        idft(a + n, n);
        for (int i = 0; i < n; i++) a[n + i] = 1LL * w[n + i] * a[n + i] % P;
        dft(a + n, n);
    }
    // 返回大于等于 len 的最小 2^k
    int norm(int n) { return 1 << std::__lg(n * 2 - 1); }
    void norm(Poly &a) {
        if (!a.empty())
            a.resize(norm(a.size()));
    }
    void dft(Poly &a) { dft(a.data(), a.size()); }
    void idft(Poly &a) { idft(a.data(), a.size()); }
    inline Poly &dotEq(Poly &a, Poly b) { // 点乘
        assert(a.size() == b.size());
        for (int i = 0; i < a.size(); i++)
            a[i] = 1LL * a[i] * b[i] % P;
        return a;
    }
    inline Poly dot(Poly a, Poly b) { return dotEq(a, b); }
    Poly operator*(const Poly &a, const Poly &b) { // 快速卷积
        int len = a.size() + b.size() - 1;
        if (a.size() <= 16 || b.size() <= 16) {
            Poly c(len);
            for (size_t i = 0; i < a.size(); i++)
                for (size_t j = 0; j < b.size(); j++)
                    c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;
            return c;
        }
        int n = norm(len);
        Poly foo = a;
        foo.resize(n);
        dft(foo);
        if (&a == &b) dotEq(foo, foo);
        else {
            Poly bar = b;
            bar.resize(n);
            dft(bar);
            dotEq(foo, bar);
        }
        idft(foo);
        foo.resize(len);
        return foo;
    }
    Poly &operator*=(Poly &a, int b) { for (auto &x : a) x = 1LL * x * b % P; return a; }
    Poly operator*(Poly a, int b) { return a *= b; }
    Poly operator*(int a, Poly b) { return b *= a; }
    Poly &operator/=(Poly &a, int b) { return a *= fpow(b); }
    Poly operator/(Poly a, int b) { return a /= b; }
    Poly &operator+=(Poly &a, Poly b) {
        a.resize(std::max(a.size(), b.size()));
        for (int i = 0; i < b.size(); i++) inc(a[i], b[i]);
        return a;
    }
    Poly operator+(Poly a, Poly b) { return a += b; }
    Poly &operator-=(Poly &a, Poly b) {
        a.resize(std::max(a.size(), b.size()));
        for (int i = 0; i < b.size(); i++) inc(a[i], P - b[i]);
        return a;
    }
    Poly operator-(Poly a, Poly b) { return a -= b; }
    Poly operator-(Poly a) { for (auto &x : a) x ? x = P - x : 0; return a; }
    Poly &operator>>=(Poly &a, int x) {
        if (x >= (int)a.size()) a.clear();
        else a.erase(a.begin(), a.begin() + x);
        return a;
    }
    Poly &operator<<=(Poly &a, int x) {
        a.insert(a.begin(), x, 0);
        return a;
    }
    Poly operator>>(Poly a, int x) { return a >>= x; }
    Poly operator<<(Poly a, int x) { return a <<= x; }
    Poly invRec(Poly a) {  // 多项式逆
        int n = a.size();
        assert((n & n - 1) == 0);
        if (n == 1) return {fpow(a[0])};
        int m = n >> 1;
        Poly b = invRec(Poly(a.begin(), a.begin() + m)), c = b;
        b.resize(n);
        dft(a), dft(b), dotEq(a, b), idft(a);
        for (int i = 0; i < m; i++) a[i] = 0;
        for (int i = m; i < n; i++) a[i] = P - a[i];
        dft(a), dotEq(a, b), idft(a);
        for (int i = 0; i < m; i++) a[i] = c[i];
        return a;
    }
    Poly inverse(Poly a) {
        int n = a.size();
        norm(a);
        a = invRec(a);
        a.resize(n);
        return a;
    }
    Poly operator/(Poly a, Poly b) { // return: c(len = n - m + 1), a = b * c + r
        int n = a.size(), m = b.size();
        if (n < m) return {0};
        int k = 1 << std::__lg(n - m << 1 | 1);
        std::reverse(a.begin(), a.end());
        std::reverse(b.begin(), b.end());
        a.resize(k), b.resize(k), b = invRec(b);
        a = a * b;
        a.resize(n - m + 1);
        std::reverse(a.begin(), a.end());
        return a;
    }
    std::pair<Poly, Poly> div(Poly a, Poly b) { // c, r
        int m = b.size();
        Poly c = a / b;
        b = b * c;
        a.resize(m - 1);
        for (int i = 0; i < m - 1; i++) inc(a[i], P - b[i]);
        return {c, a};
    }
    Poly operator%(Poly a, Poly b) { // return: r(len = m - 1)
        return div(a, b).second;
    }
    Poly sqrt(Poly a) {
        int raw = a.size();
        int d = 0;
        while (d < raw && !a[d]) d++;
        if (d == raw) return a;
        assert(~d & 1); // if (d & 1) return {};
        norm(a >>= d);
        int len = a.size();
        Poly b(len), binv(1), bsqr{a[0]}, foo, bar; // sqrt, sqrt_inv, sqrt_sqr
        b[0] = [](int x) {
            int ans = 0;
            for (int i = 0, w = P - 1, o = G, p = 1; i < 25; i++) {
                int v = i > 22 ? i == 23 ? 7 : 17 : 2;
                for (w /= v; fpow(x, w) != 1; x = 1LL * x * o % P) {
                    (ans += p) >= P - 1 ? ans -= P - 1 : 0;
                }
                p = 1LL * p * v % P;
                o = fpow(o, v);
            }
            x = fpow(G, (P - 1 - ans) >> 1);
            return x < P - x ? x : P - x;
        }(a[0]);
        binv[0] = fpow(b[0]); // assert(a[0] == 1), b[0] = binv[0] = 1;
        auto shift = [](int x) { return (x & 1 ? x + P : x) >> 1; }; // quick div 2
        for (int m = 1, n = 2; n <= len; m <<= 1, n <<= 1) {
            foo.resize(n), bar = binv;
            for (int i = 0; i < m; i++) {
                foo[i] = 0;
                int &x = foo[i + m] = a[i] + a[i + m] - bsqr[i];
                if (x >= P) x -= P;
                if (x < 0) x += P;
            }
            binv.resize(n);
            dft(foo), dft(binv), dotEq(foo, binv), idft(foo);
            for (int i = m; i < n; i++) b[i] = shift(foo[i]);
            // inv
            if (n == len) break;
            for (int i = 0; i < n; i++) foo[i] = b[i];
            bar.resize(n), binv = bar;
            dft(foo), dft(bar), bsqr = dot(foo, foo), idft(bsqr);
            dotEq(foo, bar), idft(foo);
            for (int i = 0; i < m; i++) foo[i] = 0;
            for (int i = m; i < n; i++) foo[i] = P - foo[i];
            dft(foo), dotEq(foo, bar), idft(foo);
            for (int i = m; i < n; i++) binv[i] = foo[i];
        }
        b <<= d / 2;
        b.resize(raw);
        return b;
    }
    Poly deriv(Poly a) { // 求导
        for (int i = 0; i + 1 < a.size(); i++) a[i] = (i + 1LL) * a[i + 1] % P;
        a.pop_back();
        return a;
    }
    std::vector<int> inv = {1, 1};
    void updateInv(int n) { 
        if ((int)inv.size() <= n) {
            int p = inv.size();
            inv.resize(n + 1);
            for (int i = p; i <= n; i++) inv[i] = 1LL * (P - P / i) * inv[P % i] % P;
        }
    }
    Poly integ(Poly a, int c = 0) { 
        int n = a.size();
        updateInv(n);
        Poly b(n + 1);
        b[0] = c;
        for (int i = 0; i < n; i++) b[i + 1] = 1LL * inv[i + 1] * a[i] % P;
        return b;
    }
    Poly ln(Poly a) { 
        int n = a.size();
        assert(a[0] == 1);
        a = inverse(a) * deriv(a);
        a.resize(n - 1);
        return integ(a);
    }
    // $O(n \log n)$, slower than exp2
    Poly expNewton(Poly a) { 
        int n = a.size();
        assert((n & n - 1) == 0);
        assert(a[0] == 0);
        if (n == 1) return {1};
        int m = n >> 1;
        Poly b = expNewton(Poly(a.begin(), a.begin() + m)), c;
        b.resize(n), c = ln(b);
        a.resize(n << 1), b.resize(n << 1), c.resize(n << 1);
        dft(a), dft(b), dft(c);
        for (int i = 0; i < n << 1; i++) a[i] = (1LL + P + a[i] - c[i]) * b[i] % P;
        idft(a);
        a.resize(n);
        return a;
    }
    // semi-relaxed-conv
    // $O(n\log^2n)$
    // $b = e^a, b' = a'b$
    // $(n+1)b_{n+1} = \sum_{i=0}^n a'_ib_{n-i}$
    // $nb_n = \sum_{i=0}^{n-1} a'_ib_{n - 1 - i}$
    Poly exp2(Poly a) {
        if (a.empty()) return {};
        assert(a[0] == 0);
        int n = a.size();
        updateInv(n);
        for (int i = 0; i + 1 < n; i++) {
            a[i] = a[i + 1] * (i + 1LL) % P;
        }
        a.pop_back();
        Poly b(n);
        b[0] = 1;
        for (int m = 1; m < n; m++) {
            int k = m & -m, l = m - k, r = std::min(m + k, n);
            Poly p(a.begin(), a.begin() + (r - l - 1));
            Poly q(b.begin() + l, b.begin() + m);
            p.resize(k * 2), q.resize(k * 2);
            dft(p), dft(q);
            dotEq(p, q);
            idft(p);
            for (int i = m; i < r; i++) inc(b[i], p[i - l - 1]);
            b[m] = 1LL * b[m] * inv[m] % P;
        }
        return b;
    }
    // semi-relaxed-conv
    // $O(\frac{n\log^2n}{\log\log n})$
    Poly exp(Poly a) {
        if (a.empty()) return {};
        assert(a[0] == 0);
        int n = a.size();
        updateInv(n);
        for (int i = 0; i + 1 < n; i++) {
            a[i] = a[i + 1] * (i + 1LL) % P;
        }
        a.pop_back();
        Poly b(n);
        b[0] = 1;
        std::vector<Poly> val_a[6], val_b(n);
        for (int m = 1; m < n; m++) {
            int k = 1, d = 0;
            while (!(m / k & 0xf)) k *= 16, d++;
            int l = m & ~(0xf * k), r = std::min(n, m + k);
            if (k == 1) {
                for (int i = m; i < r; i++) {
                    for (int j = l; j < m; j++) {
                        b[i] = (b[i] + 1LL * b[j] * a[i - j - 1]) % P;
                    }
                }
            } 
            else {
                assert(d < 6);
                if (val_a[d].empty()) val_a[d].resize(n);
                val_b[m] = Poly(b.begin() + (m - k), b.begin() + m);
                val_b[m].resize(k * 2);
                dft(val_b[m]);
                Poly res(k * 2);
                for (; l < m; l += k) {
                    auto &p = val_a[d][m - l - k];
                    if (p.empty()) {
                        p = Poly(a.begin() + (m - l - k), a.begin() + (r - l - 1));
                        p.resize(2 * k);
                        dft(p);
                    }
                    auto &q = val_b[l + k];
                    for (int i = 0; i < k * 2; i++) res[i] = (res[i] + 1LL * p[i] * q[i]) % P;
                }
                idft(res);
                for (int i = m; i < r; i++) inc(b[i], res[i - m + k - 1]);
            }
            b[m] = 1LL * b[m] * inv[m] % P;
        }
        return b;
    }
    Poly power(Poly a, int k) {
        int n = a.size();
        long long d = 0;
        while (d < n && !a[d]) d++;
        if (d == n) return a;
        a >>= d;
        int b = fpow(a[0]);
        norm(a *= b);
        a = exp(ln(a) * k) * fpow(b, P - 1 - k % (P - 1));
        a.resize(n);
        d *= k;
        for (int i = n - 1; i >= d; i--) a[i] = a[i - d];
        d = std::min(d, 1LL * n);
        for (int i = d; i; a[--i] = 0) ;
        return a;
    }
    Poly power(Poly a, int k1, int k2) { // k1 = k % (P - 1), k2 = k % P
        int n = a.size();
        long long d = 0;
        while (d < n && !a[d]) d++;
        if (d == n) return a;
        a >>= d;
        int b = fpow(a[0]);
        norm(a *= b);
        a = exp(ln(a) * k2) * fpow(b, P - 1 - k1 % (P - 1));
        a.resize(n);
        d *= k1;
        for (int i = n - 1; i >= d; i--) a[i] = a[i - d];
        d = std::min(d, 1LL * n);
        for (int i = d; i; a[--i] = 0) ;
        return a;
    }
}
using namespace Polynomial;
```

#### 分治NTT
```cpp
auto calc = [&](auto &&calc, int l, int r) -> Poly {
    if (l == r) return p[l];
    int mid = l + r >> 1;
    return calc(calc, l, mid) * calc(calc, mid + 1, r);
};
```

### 高精度

#### 高精度加
高精度加,两个 vector 中都是倒着存的，且都为正数，输出需要倒序输出
```cpp
vector<int> add(vector<int> &A, vector<int> &B) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size()|| i < B.size(); i++) {
        if (i < A.size()) t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t) C.push_back(t);
    return C;
}
```

#### 高精度减法
A >= B 且都大于等于 0，倒序存储，倒序输出
```cpp
vector<int> sub(vector<int> &A, vector<int> &B) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i++) {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

#### 高精度乘以低精度
倒序
```cpp
vector<int> mul(vector<int> &A, int b) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i++) {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

#### 高精度乘以高精度
倒序 不过最好使用 fft 来解决
```cpp
vector<int> mul(vector<int> &A, vector<int> &B) {
    vector<int> C(A.size() + B.size());
    for (int i = 0; i < A.size(); i++) {
        for (int j = 0; j < B.size(); j++) {
            C[i + j] += A[i] * B[j];
        }
    }
    for (int i = 0, t = 0; i < C.size() || t; i++) {
        t += C[i];
        if (i >= C.size()) C.push_back(t % 10);
        else C[i] = t % 10;
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

#### 高精度除法
A 是正序的 C 最终返回值是倒序的，商 C 余 r
```cpp
vector<int> div(vector<int> &A, int b, int &r) {
    vector<int> C;
    r = 0;
    for (int i = 0; i < A.size(); i++) {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(),C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

#### 大整数类
```cpp
struct bign {  
    int d[maxn], len;  
    void clean() { while(len > 1 && !d[len - 1]) len--; }  
    bign()          { memset(d, 0, sizeof(d)); len = 1; }  
    bign(int num)   { *this = num; }   
    bign(char* num) { *this = num; }  
    bign operator = (const char* num) {  
        memset(d, 0, sizeof(d)); len = strlen(num);  
        for (int i = 0; i < len; i++) d[i] = num[len - 1 - i] - '0';  
        clean();  
        return *this;  
    }  
    bign operator = (int num) {  
        char s[20]; sprintf(s, "%d", num);  
        *this = s;  
        return *this;  
    }  
    bign operator + (const bign& b) {  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++) {  
            c.d[i] += b.d[i];  
            if (c.d[i] > 9) c.d[i] %= 10, c.d[i + 1]++;  
        }  
        while (c.d[i] > 9) c.d[i++] %= 10, c.d[i]++;  
        c.len = max(len, b.len);  
        if (c.d[i] && c.len <= i) c.len = i + 1;  
        return c;  
    }  
    bign operator - (const bign& b) {  
        bign c = *this; int i;  
        for (i = 0; i < b.len; i++) {  
            c.d[i] -= b.d[i];  
            if (c.d[i] < 0) c.d[i] += 10, c.d[i + 1]--;  
        }  
        while (c.d[i] < 0) c.d[i++] += 10, c.d[i]--;  
        c.clean();  
        return c;  
    }  
    bign operator * (const bign& b) const {  
        int i, j; bign c; c.len = len + b.len;   
        for (j = 0; j < b.len; j++) for (i = 0; i < len; i++)   
            c.d[i + j] += d[i] * b.d[j];  
        for (i = 0; i < c.len - 1; i++)  
            c.d[i + 1] += c.d[i] / 10, c.d[i] %= 10;  
        c.clean();  
        return c;  
    }  
    bign operator / (const bign& b) {  
        int i, j;  
        bign c = *this, a = 0;  
        for (i = len - 1; i >= 0; i--) {  
            a = a * 10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b * (j + 1)) break;  
            c.d[i] = j;  
            a = a - b * j;  
        }  
        c.clean();  
        return c;  
    }  
    bign operator % (const bign& b) {  
        int i, j;  
        bign a = 0;  
        for (i = len - 1; i >= 0; i--) {  
            a = a * 10 + d[i];  
            for (j = 0; j < 10; j++) if (a < b * (j + 1)) break;  
            a = a - b * j;  
        }  
        return a;  
    }  
    bign operator += (const bign& b) {  
        *this = *this + b;  
        return *this;  
    }  
    bool operator < (const bign& b) const {  
        if (len != b.len) return len < b.len;  
        for (int i = len - 1; i >= 0; i--)  
            if (d[i] != b.d[i]) return d[i] < b.d[i];  
        return false;  
    }  
    bool operator > (const bign& b) const {return b < *this;}  
    bool operator <= (const bign& b) const {return !(b < *this);}  
    bool operator >= (const bign& b) const {return !(*this < b);}  
    bool operator != (const bign& b) const {return b < *this || *this < b;}  
    bool operator == (const bign& b) const {return !(b < *this) && !(b > *this);}  
    string str() const {  
        char s[maxn] = {};  
        for (int i = 0; i < len; i++) s[len - 1 - i] = d[i] + '0';  
        return s;  
    }  
};  
istream& operator >> (istream& in, bign& x) {  
    string s;  
    in >> s;  
    x = s.c_str();  
    return in;  
}  
ostream& operator << (ostream& out, const bign& x) {  
    out << x.str();  
    return out;  
}
```

### 高斯消元

#### 高斯消元解加法方程组
```cpp
void solve () {
    int n;
    cin >> n;
    vector<vector<long double>> a(n + 1, vector<long double> (n + 1, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    auto gauss = [&]() -> int {
        int c, r;
        for (c = 0, r = 0; c < n; c++) {
            int t = r;
            for (int i = r; i < n; i++) {   // 找到绝对值最大的行
                if (fabs(a[i][c]) > fabs(a[t][c])) {
                    t = i;
                }
            }
            if (fabs(a[t][c]) < 1e-8) continue;
            for (int i = c; i <= n; i++) swap(a[r][i], a[t][i]); // 将绝对值最大的行换到最顶端
            for (int i = n; i >= c; i--) a[r][i] /= a[r][c]; // 将当前行的首位变成 1
            for (int i = r + 1; i < n; i++) {   // 用当前行将下面所有的列消成 0
                if (fabs(a[i][c]) > 1e-8) {
                    for (int j = n; j >= c; j--) {
                        a[i][j] -= a[i][c] * a[r][j];
                    }
                }
            }
            r++;
        }
        if (r < n) {
            for (int i = r; i < n; i++) {
                if (fabs(a[i][n]) > 1e-8) {
                    return 2; // 无解
                }
            }
            return 1;  // 有无穷多组解
        }
        for (int i = n - 1; i >= 0; i--) {   // 消成对角矩阵
            for (int j = i + 1; j <= n; j++) {
                a[i][n] -= a[i][j] * a[j][n];
            }
        }
        return 0; // 有唯一解
    };
    int t = gauss();
    if (t == 0) {
        for (int i = 0; i < n; i++){
            cout << fixed << setprecision(2) << a[i][n] << '\n';
        }
    }
    else if (t == 1) cout << "Infinite group solutions" << '\n';
    else cout << "No solution";
}
```

#### 高斯消元解异或方程组
```cpp
int var;
int gauss() {
    int c, r;
    for (c = 0, r = 0; c < n; c++) {
        int t = r;
        for (int i = r; i < n; i++) {   // 找主元
            if (a[i][c]) {
                t = i;
                break;
            }
        }
        if (!a[t][c]) continue;
        for (int i = c; i <= n; i++) swap(a[r][i], a[t][i]); // 换行
        for (int i = r + 1; i < n; i++) {   // 用当前行将下面所有的列消
            if (a[i][c]) {
                for (int j = c; j <= n; j++) {
                    a[i][j] ^= a[r][j];
                }
            }
        }
        r++;
    }
    var = n - r; // 共有多少个可变元，总的方案为 pow(2,var)
    if (r < n) {
        for (int i = r; i < n; i++) {
            if (a[i][n]) {
                return 2; // 无解
            }
        }
        return 1; // 多组解
    }
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j <= n; j++) {
            a[i][n] ^= a[i][j] & a[j][n];
        }
    }
    return 0; // 唯一解
}
```

#### bitset 优化异或高斯消元
```cpp
vector<bitset<300>> g;
for (int c = 0; c < n - 1; c++) {
    int p = -1;
    for (int r = c; r < n - 1; r++) {
        if (g[r][c]) {
            p = r;
            break;
        }
    }
    if (p > c) swap(g[p], g[c]);
    for (int r = c + 1; r < n - 1; r++) {
        if (g[r][c]) {
            g[r] = g[r] ^ g[c];
            b[r] = b[r] ^ b[c];
        }
    }
}
for (int r = n - 2; r >= 0; r--) {
    for (int j = r - 1; j >= 0; j--) {
        if (g[j][r]) {
            b[j] ^= b[r];
        }
    }
}
```

### 积性函数
f 是积性函数值，cnt[i]表示 i 这个数最小的质因数出现了几次
```cpp
f[1] = 1;
for (int i = 2; i <= n; i++) {
    if (!not_prime[i]) {
        p[++tot] = i;
        f[i] = calc_f(i, 1);
    }
    for (int j = 1; j <= tot && p[j] <= n / i; j++) {
        not_prime[i * p[j]] = 1;
        if (i % p[j] == 0) {
            cnt[i * p[j]] = cnt[i] + 1;
            f[i * p[j]] = f[i] / calc_f(p[j], cnt[i]) * calc_f(p[j], cnt[i] + 1);
            break;
        }
        cnt[i * p[j]] = 1;
        f[i * p[j]] = f[i] * f[p[j]];
    }
}
```

### 极大线性无关组
两个数为 a 和 b（gcd == 1）最大不能表示出来的数为 (a - 1) * (b - 1) - 1,且不能表示数的个数为：(a - 1)(b - 1) / 2 <br>
#### 完全背包方案数求极大线性无关组
```cpp
int cnt;
int a[110], f[25010];
void solve() {
    int n;
    cin >> n;
    cnt = 0;
    memset(f, 0, sizeof(f));
    f[0] = 1;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1);
    int m = a[n];
    for (int i = 1; i <= n; i++) {
        for (int j = a[i]; j <= m; j++) {
            f[j] += f[j - a[i]];
        }
    }
    for (int i = 1; i <= n; i++) {
        if (f[a[i]] == 1) {
            cnt++; // 如果这个数可以被除了自己以外的数表示那么他就不是极大线性无关组的一员
        }
    }
    cout << cnt << '\n';
}
```

### 矩阵求逆
```cpp
#include<bits/stdc++.h>
#define re register
#define il inline
#define ll long long
using namespace std;
const int N = 405, mod = 1e9 + 7;
int n;
ll a[N][N << 1];
il ll qpow(ll x, ll k) {
	ll ans = 1;
	while (k) {
		if (k & 1) ans = ans * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return ans % mod;
}
il void Gauss_j() {	
	for (re int i = 1, r; i <= n; ++i) {
		r = i;
		for (re int j = i + 1; j <= n; ++j)
			if (a[j][i] > a[r][i]) r = j;
		if (r != i) swap(a[i], a[r]);
		if (!a[i][i]) {
			puts("No Solution");
			return;
		}		
		int kk = qpow(a[i][i], mod - 2);	// 求逆元 
		for (re int k = 1; k <= n; ++k) {
			if (k == i) continue;
			int p = a[k][i] * kk % mod;
			for (re int j = i; j <= (n << 1); ++j) 
				a[k][j] = ((a[k][j] - p * a[i][j]) % mod + mod) % mod;
		} 
		for (re int j = 1; j <= (n << 1); ++j) a[i][j] = (a[i][j] * kk % mod);
		// 更新当前行 如果放在最后要再求一次逆元, 不如直接放在这里  
	}	
	for (re int i = 1; i <= n; ++i) {
		for (re int j = n + 1; j < (n << 1); ++j) cout << a[i][j] << ' ';
		cout << a[i][n << 1] << '\n';
	}
}
int main() {
	cin >> n;
	for (re int i = 1; i <= n; ++i)
		for (re int j = 1; j <= n; ++j)
			cin >> a[i][j], a[i][i + n] = 1;
	Gauss_j();
    return 0;
}
```

### 快速幂

#### 快速幂
```cpp
i64 qmi(i64 a, i64 k, int p) {
    i64 res = 1 % p;
    while (k) {
        if (k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}
```

#### 广义矩阵
```cpp
const int INF = INT_MIN / 2;
struct Matrix {
    int a[2][2];
    Matrix() {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                a[i][j] = (i == j ? 0 : INF); // 单位矩阵
            }
        }
    }
    // Max-Plus 乘法：C[i][j] = max_k (A[i][k] + B[k][j])
    Matrix operator*(const Matrix &b) const {
        Matrix c;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c.a[i][j] = INF;
                for (int k = 0; k < 2; k++) {
                    if (a[i][k] != INF && b.a[k][j] != INF) {
                        c.a[i][j] = max(c.a[i][j], a[i][k] + b.a[k][j]);
                    }
                }
            }
        }
        return c;
    }
};
```

#### 矩阵快速幂
```cpp
struct matrix {
    i64 x[2][2];
    matrix() { memset(x, 0, sizeof(x)); }
    matrix (i64 a[2][2]) {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                x[i][j] = a[i][j];
            }
        }
    }
};
matrix add(matrix a, matrix b) {
    matrix res;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            res.x[i][j] = (a.x[i][j] + b.x[i][j]) % mod;
        }
    }
    return res;
}
matrix multiply(matrix a, matrix b) {
    matrix res;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            for (int k = 0; k < 3; k++) {
                res.x[i][j] = (res.x[i][j] + (a.x[i][k] * b.x[k][j]) % mod) % mod;
            }
        }
    }
    return res;
}
matrix mpow(matrix &a, i64 m) { // 矩阵 a 的 m 次方
    matrix res;
    for (int i = 0; i < 3; i++) res.x[i][i] = 1; // 单位矩阵
    while (m > 0) {
        if (m & 1) res = multiply(res, a);
        a = multiply(a, a);
        m >>= 1;
    }
    return res;
}
// 输出时也要输出((res.x[1][1] % mod) + mod) % mod
```

#### 龟速乘
```cpp
i64 qadd(i64 a, i64 b, i64 p) {
    i64 res = 0;
    while (b) {
        if (b & 1) res = (res + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return res;
}
```

### 拉格朗日插值

#### 求多项式系数 O(n^2)
```cpp
#include<bits/stdc++.h>
using namespace std;
using i64 = long long;
constexpr int MOD = 998244353;
i64 inv(i64 k) {
    i64 res = 1;
    for (int e = MOD - 2; e; e /= 2) {
        if (e & 1) res = res * k % MOD;
        k = k * k % MOD;
    }
    return res;
}
// 返回 f 满足 f(x_i) = y_i
// 不考虑乘法逆元的时间，显然为 O(n^2)
vector<i64> lagrange_interpolation(const vector<i64> &x, const vector<i64> &y) {
    const int n = x.size();
    vector<i64> M(n + 1), xx(n), f(n);
    M[0] = 1;
    // 求出 M(x) = prod_(i=0..n-1)(x - x_i)
    for (int i = 0; i < n; i++) {
        for (int j = i; j >= 0; j--) {
            M[j + 1] = (M[j] + M[j + 1]) % MOD;
            M[j] = M[j] * (MOD - x[i]) % MOD;
        }
    }
    // 求出 xx_i = M'(x_i) = (M / (x - x_i)) mod (x - x_i) 一定非零
    for (int i = n - 1; i >= 0; i--) {
        for (int j = 0; j < n; j++) {
            xx[j] = (xx[j] * x[j] + M[i + 1] * (i + 1)) % MOD;
        }
    }
    // 组合出 f(x) = sum_(i=0..n-1)(y_i / M'(x_i))(M / (x - x_i))
    for (int i = 0; i < n; i++) {
        i64 t = y[i] * inv(xx[i]) % MOD, k = M[n];
        for (int j = n - 1; j >= 0; j--) {
            f[j] = (f[j] + k * t) % MOD;
            k = (M[j] + k * x[i]) % MOD;
        }
    }
    return f;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, k;
    cin >> n >> k;
    vector<i64> x(n), y(n);
    for (int i = 0; i < n; i++) cin >> x[i] >> y[i];
    const auto f = lagrange_interpolation(x, y);
    i64 v = 0;
    for (int i = n - 1; i >= 0; --i) v = (v * k + f[i]) % MOD;
    cout << v << '\n';
    return 0;
}
```

#### 横坐标从 0 连续
求值只需 O(n)，但无法求多项式系数
```cpp
const int N = 1e6 + 10, mod = 1e9 + 7;
i64 qmi(i64 a, i64 k) {
    i64 res = 1;
    while (k) {
        if (k & 1) res = res * a % mod;
        a = a * a % mod;
        k >>= 1;
    }
    return res;
}
i64 fact[N], infact[N];
void init() {
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i++) fact[i] = fact[i - 1] * i % mod;
    infact[N - 1] = qmi(fact[N - 1], mod - 2);
    for (int i = N - 2; i >= 1; i--) infact[i] = infact[i + 1] * (i + 1) % mod;
}
// 结点固定为 x_i = i (0..n-1)，只求 f(k)
i64 lagrange_interpolation(const vector<i64> &y, i64 k) {
    int n = (int)y.size();
    if (k < n) return y[k];
    // w_i = (-1)^{n-1-i} * y_i / (i! * (n-1-i)!)
    vector<i64> w(n);
    for (int i = 0; i < n; i++) {
        i64 t = y[i] * infact[i] % mod * infact[n - 1 - i] % mod;
        if ((n - 1 - i) & 1) t = -t % mod;
        w[i] = t;
    }

    vector<i64> dif(n);
    for (int i = 0; i < n; i++) dif[i] = (k - i) % mod;

    // 前缀/后缀积，拿到：
    //   prodAll = ∏(k - i) = M(k)
    //   inv_dif[i] = 1 / (k - i)
    vector<i64> pref(n + 1, 1), suf(n + 1, 1);
    for (int i = 0; i < n; i++) pref[i + 1] = pref[i] * dif[i] % mod;
    for (int i = n - 1; i >= 0; i--) suf[i] = suf[i + 1] * dif[i] % mod;
    i64 prodAll = pref[n];                // M(k)
    i64 invProd = qmi(prodAll, mod - 2);           // 一次求逆
    // inv_dif[i] = pref[i] * suf[i+1] / prodAll
    i64 sum = 0;
    for (int i = 0; i < n; i++) {
        i64 inv_dif_i = pref[i] * suf[i + 1] % mod * invProd % mod;
        sum = (sum + w[i] * inv_dif_i % mod) % mod;
    }
    i64 res = (prodAll * sum % mod + mod) % mod;
    return res;
}
```

### 曼哈顿，切比雪夫
将一个点 (x, y) 的坐标变为 (x + y, x − y) 后, 原坐标系中的曼哈顿距离 = 新坐标系中的切比雪夫距离 <br>
将一个点 (x, y) 的坐标变为 ((x + y) / 2, (x − y) /2) 后, 原坐标系中的切比雪夫距离 = 新坐标系中的曼哈顿距离 <br>

### 莫比乌斯反演
容斥如果大的集合是小集合的子集，那么可以先求大的然后类似埃氏筛从小的集合里筛掉 <br>
已知（因数和）
$$
f(n)=\sum_{d\mid n} g(d).
$$
则
$$
g(n)=\sum_{d\mid n}\mu(d)\,f\!\left(\frac{n}{d}\right)
= \sum_{d\mid n}\mu\!\left(\frac{n}{d}\right)\,f(d).
$$
等价的狄利克雷卷积写法：
$$
f = g * \mathbf{1},\qquad g = f * \mu,
$$
其中 $\mathbf{1}(n)\equiv 1$，$\mu$ 为莫比乌斯函数。

已知（倍数和）：
$$
f(n)=\sum_{\substack{d\ge 1\\ n\mid d}} g(d)
=\sum_{k\ge 1} g(kn).
$$
则（莫比乌斯反演，倍数版）：
$$
g(n)=\sum_{\substack{d\ge 1\\ n\mid d}} \mu\!\left(\frac{d}{n}\right)\,f(d)
=\sum_{k\ge 1}\mu(k)\,f(kn).
$$
其中 $\mu$ 为莫比乌斯函数。

$$
[\gcd(x,y)=1]
=\sum_{d\,\mid\,\gcd(x,y)} \mu(d)
=\sum_{\substack{d\,\mid\,x\\ d\,\mid\,y}} \mu(d).
$$

狄利克雷卷积：
$$
(h=f*g)(x):=\sum_{d\mid x} f(d)\,g\!\left(\frac{x}{d}\right).
$$

単位元：
$$
\varepsilon(n):=[n=1],\qquad \varepsilon(1)=1,\ \varepsilon(n>1)=0.
$$

基本恒等式：
$$
\mu * \mathbf{1} = \varepsilon,
\qquad
\mathrm{id} = \varphi * \mathbf{1},
\qquad
\varphi = \mu * \mathrm{id}.
$$

展开式：
$$
\sum_{d\mid n}\mu(d)=\varepsilon(n)=[n=1],
$$
$$
\sum_{d\mid n}\varphi(d)=n=\mathrm{id}(n),
$$
$$
\varphi(n)=\sum_{d\mid n}\mu(d)\,\mathrm{id}\!\left(\frac{n}{d}\right)
=\sum_{d\mid n}\mu(d)\,\frac{n}{d}.
$$

#### 线性筛求 mobius 函数
```cpp
int primes[N], cnt;
bool st[N];
int mobius[N];
void init(int n) {
    mobius[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (st[i] == 0) {
            primes[cnt++] = i;
            mobius[i] = -1;
        }
        for (int j = 0; primes[j] * i <= n; j++) {
            int t = primes[j] * i;
            st[t] = 1;
            if (i % primes[j] == 0) {
                mobius[t] = 0;
                break;
            }
            mobius[t] = mobius[i] * -1;
        }
    }
}
```

### 整数分块
```cpp
{
    int a, b, d;
    cin >> a >> b >> d;
    a /= d, b /= d;
    LL res = 0;
    int n = min(a, b);
    for (int l = 1, r; l <= n; l = r + 1) {
        r = min(n, min(a / (a / l), b / (b / l)));
        res += (sum[r] - sum[l - 1]) * (LL)(a / l) * (b / l);
    }
    cout << res << '\n';
}
```

### 逆元

#### 线性求 1 到 n 的逆元
```cpp
inv[1] = 1;
for (int i = 2; i <= n; i++) inv[i] = (i64)(p - p / i) * inv[p % i] % p;
```

#### 线性求任意 n 个数的逆元
```cpp
s[0] = 1;
for (int i = 1; i <= n; i++) s[i] = s[i - 1] * a[i] % p; // 前缀积
sv[n] = qmi(s[n], p - 2);
// 当然这里也可以用 exgcd 来求逆元.
for (int i = n; i >= 1; --i) sv[i - 1] = sv[i] * a[i] % p; // 求每个前缀积的逆元
for (int i = 1; i <= n; ++i) inv[i] = sv[i] * s[i - 1] % p; // 求第 i 个数的逆元
```

#### 线性求阶乘逆元
```cpp
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i++) fact[i] = (LL)fact[i - 1] * i % mod;
infact[N - 1] = qmi(fact[N - 1], mod - 2, mod);
for (int i = N - 2; i >= 1; i--) infact[i] = infact[i + 1] * (i + 1) % mod;
```

### 欧拉

#### 求欧拉函数
```cpp
int phi(int x) {
    int res = x;
    for (int i = 2; i <= x / i; i++)
        if (x % i == 0) {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
    return res;
}
```

#### 筛法求欧拉函数
```cpp
int primes[N], cnt;     // primes[] 存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储 x 是否被筛掉
void get_eulers(int n) {
    euler[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] * i <= n; j++) {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0) {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

#### 扩展欧拉定理
```cpp
if (gcd(a, m) == 1) a ^ b % m = a ^ (b % phi(m)) % m;
else {
    if (b < phi(m)) a ^ b % m = a ^ b % m;
    else a ^ b % m = a ^ (b % phi(m) + phi(m)) % m;  
}
```

### 生成函数

几何级数展开：
$$
(1-x)^{-1}=\sum_{k=0}^{\infty} x^{k}=1+x+x^2+\cdots .
$$
收敛条件：$|x|<1$（或视为形式幂级数则恒成立）。

几何级数展开：
$$
(1-ax)^{-1}
=\sum_{k=0}^{\infty}(ax)^k
=\sum_{k=0}^{\infty} a^{k}x^{k}
=1+ax+a^{2}x^{2}+\cdots .
$$
收敛条件：$|ax|<1$（或作形式幂级数则恒成立）。

几何级数展开（$r\in\mathbb{Z}_{>0}$）：
$$
(1-x^{r})^{-1}
=\sum_{k=0}^{\infty}(x^{r})^{k}
=\sum_{k=0}^{\infty} x^{kr}
=1+x^{r}+x^{2r}+\cdots .
$$
收敛条件：$|x^{r}|<1$（例如实数情形下 $|x|<1$；作为形式幂级数则恒成立）。

$$
(1-x)^{-2}
=\sum_{k=0}^{\infty}(k+1)\,x^{k}
=1+2x+3x^{2}+\cdots .
$$
（收敛条件：$|x|<1$；作为形式幂级数恒成立。）

广义二项式（负整数幂）：
$$
(1-x)^{-n}
=\sum_{k=0}^{\infty}\binom{n+k-1}{k}\,x^{k}
=\sum_{k=0}^{\infty}\binom{n+k-1}{\,n-1\,}\,x^{k},
\qquad n\in\mathbb{Z}_{>0}.
$$
（收敛条件：$|x|<1$；作为形式幂级数恒成立。）

广义二项式定理：
$$
(1+x)^a=\sum_{k=0}^{\infty} c[a][k]\;x^k,
\qquad
c[a][k]=\binom{a}{k}
=\frac{a(a-1)\cdots(a-k+1)}{k!},\ \ c[a][0]=1.
$$
收敛条件：若 $a\notin\mathbb{Z}_{\ge 0}$，则级数在 $|x|<1$ 收敛；若 $a\in\mathbb{Z}_{\ge 0}$，则和式在 $k>a$ 处截断为有限多项式。

指数函数的幂级数展开：
$$
\exp(x)=e^{x}=\sum_{n=0}^{\infty}\frac{x^{n}}{n!}
=1+x+\frac{x^{2}}{2!}+\frac{x^{3}}{3!}+\cdots .
$$
（收敛半径为无穷大。）

自然对数的幂级数展开：
$$
\ln(1+x)=\sum_{n=1}^{\infty}\frac{(-1)^{\,n+1}}{n}\,x^{n}
= x-\frac{x^2}{2}+\frac{x^3}{3}-\cdots .
$$

收敛性：$|x|<1$；当 $x=1$ 时收敛到 $\ln 2$，当 $x=-1$ 发散。

**多重集合（用常生成函数 OGF）**  
从 `n` 类物品中取 `k` 个（允许重复）：
$$
G(x)=\prod_{i=1}^{n}\bigl(1+x+x^2+\cdots\bigr)=(1-x)^{-n},\qquad
\#\text{(size }k)= [x^k]\,G(x)=\binom{n+k-1}{k}.
$$

若第 \(i\) 类至多取 \(m_i\) 个：
$$
G(x)=\prod_{i=1}^{n}\bigl(1+x+\cdots+x^{m_i}\bigr),\qquad
\#\text{(size }k)= [x^k]\,G(x).
$$

---

**排成一排（用指数生成函数 EGF）**  
将 \(k\) 个互异（带标签）物品排成一排（长度 \(k\) 的排列）：
$$
P(z)=\sum_{k\ge 0}\frac{k!}{k!}z^k=\frac{1}{1-z},\qquad
\#(k)=k!.
$$

更一般地，若基本类 \(A\) 的 EGF 为 \(A(z)\)，则
$$
\mathrm{SEQ}_k(A):\quad \text{EGF}=A(z)^k,\qquad
\mathrm{SEQ}(A):\quad \text{EGF}=\frac{1}{1-A(z)},
$$
且“大小为 \(n\)、长度为 \(k\)”的计数为
$$
\#_{n,k}=n!\,[z^n]\bigl(A(z)^k\bigr).
$$

### 位运算
a ^ b == a + b - 2 (a & b) <br>
1 - n 中第 k 位为 1 的个数为 ⌊n / (2 ^ (i + 1))⌋ * 2 ^ i + min(max(n mod (2 ^ (i + 1)) - (1ll << i) + 1, 0ll), 1ll << i) <br>
全集 (1 << n) - 1 补集 ((1 << n) - 1) ^ s 差集 a & ∼b 删除最小元素 s & (s - 1) <br>
1 的个数 __builtin_popcount(s) 二进制长度 __lg(s) + 1 集合最大元素 __lg(s) 集合最小元素 __builtin_ctz(s) <br>
s = 0 时__lg(0) 和 __builtin_ctz(0) 是未定义行为  long long，需使用相应的 __builtin_popcountll <br>

#### 区间按位与
```cpp
i64 rangeBitwiseAnd(i64 l, i64 r) {
    while (l < r) r -= r & (-r);
    return r;
}
```
#### 枚举非空子集
单次枚举是是 O(2^|s|), 枚举所有集合的子集是(3^n)
```cpp
for (int sub = s; sub; sub = (sub - 1) & s) {
    // 处理 sub 的逻辑
}
```

#### 枚举子集（包含空集）
```cpp
int sub = s;
do {
    // 处理 sub 的逻辑
    sub = (sub - 1) & s;
} while (sub != s);
```

#### 枚举全集 $U$ 的所有大小恰好为 $k$ 的子集 
$O(C[n][k])$ $k$ 不为 0
```cpp
void GospersHack(int n, int k) {
    int cur = (1 << k) - 1;
    int limit = (1 << n);
    while (cur < limit) {
        // do something
        int lb = cur & -cur;
        int r = cur + lb;
        cur = ((r ^ cur) >> __builtin_ctz(lb) + 2) | r;
    }
}
```

#### 枚举超集
```cpp
for (int s = t; s < (1 << n); s = (s + 1) | t) {
    // 处理 s 的逻辑
}
```

### 线性基
如果 $r < n$ 线性相关  $r == n$ 线性无关 <br>
所有非 $0$ 异或值共有 $(1 << r) - 1$ 个 <br>
```cpp
void solve() {
    int n;
    cin >> n;
    vector<i64> a(n), id(64, -1);
    for (int i = 0; i < n; i++) cin >> a[i];
    int r = 0;
    for (int i = 62; i >= 0; i--) {
        for (int j = r; j < n; j++) {
            if (a[j] >> i & 1) {
                swap(a[j], a[r]);
                break;
            }
        }
        if ((a[r] >> i & 1) == 0) continue;
        id[i] = r; // 记录每一位的主人
        for (int j = 0; j < n; j++) {
            if ((a[j] >> i & 1) && j != r) {
                a[j] ^= a[r];
            }
        }
        r++;
        if (r == n) break;
    }
    i64 res = 0;
    for (int i = 0; i < r; i++) res ^= a[i]; // 最大值

    reverse(a.begin(), a.begin() + r);  // 查询第 k 小的结果(至少选一个进行异或)
    int m;
    cin >> m;
    while (m--) {
        i64 k;
        cin >> k;
        if (r < n) k--;
        if (k >= (1ll << r)) cout << -1 << '\n';
        else {
            i64 res = 0;
            for (int i = 0; i < r; i++) {
                if (k >> i & 1) {
                    res ^= a[i];
                }
            }
            cout << res << '\n';
        } 
    }
}
```
```cpp
class XorBasis {
    static const int MAX_BIT = 61; 
    i64 b[MAX_BIT];       
    int sz = 0, outn = 0;              
    vector<i64> basis;     // 缓存规约后的基向量
    bool rebuilt = false;  // 标记是否已规约
    // 内部规约函数
    void rebuild() {
        basis.clear();
        for (int i = 0; i < MAX_BIT; i++) {
            if (b[i]) {
                basis.push_back(b[i]);
            }
        }
        int n = basis.size();
        vector<int> pos(n); // 记录每个基向量的最高 1 位
        for (int i = 0; i < n; i++) {
            for (int j = MAX_BIT - 1; j >= 0; j--) {
                if (basis[i] >> j & 1) {
                    pos[i] = j;
                    break;
                }
            }
        }
        // 高斯消元，消除低位
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && (basis[i] >> pos[j] & 1)) {
                    basis[i] ^= basis[j];
                }
            }
        }
        // 按最高位排序
        vector<pair<int, i64>> tmp;
        for (int i = 0; i < n; i++) {
            for (int j = MAX_BIT - 1; j >= 0; j--) {
                if (basis[i] >> j & 1) {
                    tmp.emplace_back(j, basis[i]);
                    break;
                }
            }
        }
        sort(tmp.begin(), tmp.end());
        basis.clear();
        for (auto [_, val] : tmp) basis.push_back(val);
        rebuilt = true;
    }
public:
    XorBasis() { fill(b, b + MAX_BIT, 0); }
    void setoutn(int n) {
        outn = n;
    }
    // 插入一个数进线性基
    void insert(i64 x) {
        for (int i = MAX_BIT - 1; i >= 0; i--) {
            if ((x >> i) & 1) {
                if (!b[i]) {
                    b[i] = x;
                    sz++;
                    rebuilt = false; // 标记需要重新规约
                    return;
                }
                x ^= b[i];
            }
        }
    }
    // 判断某个数能否由当前基表示
    bool canRepresent(i64 x) const {
        for (int i = MAX_BIT - 1; i >= 0; i--) {
            if ((x >> i) & 1) {
                if (!b[i]) return false;
                x ^= b[i];
            }
        }
        return true;
    }
    // 返回最大异或和
    i64 maxXor() const {
        i64 res = 0;
        for (int i = MAX_BIT - 1; i >= 0; i--) {
            if ((res ^ b[i]) > res) {
                res ^= b[i];
            }
        }
        return res;
    }
    // 返回最小异或和
    i64 minXor() const {
        if (!rebuilt) const_cast<XorBasis*>(this)->rebuild();
        return basis.empty() ? 0 : basis[0];
    }
    // 返回第 k 小异或值（0-based）记得 setoutn
    i64 kthXor(u64 k) const {
        if (!rebuilt) const_cast<XorBasis*>(this)->rebuild(); // 惰性规约
        int n = basis.size();
        if (n == outn) k++;
        if (k >= (1ULL << n)) return -1; // 超出范围
        i64 res = 0;
        for (int i = 0; i < n; i++) {
            if (k >> i & 1) {
                res ^= basis[i];
            }
        }
        return res;
    }
    // 获取线性基的大小（秩）
    int size() const {
        return sz;
    }
    // 获取规约后的线性基向量集合
    vector<i64> getBasis() const {
        if (!rebuilt) const_cast<XorBasis*>(this)->rebuild(); // 惰性规约
        return basis;
    }
};
```

### 行列式求值
O(n^3) 利用辗转相除法
```cpp
int n, p;
int a[N][N];
int cal(int a[][N], int n, const int p) {
	int i, j, k, r = 1, fh = 0, l;
	for (i = 1; i <= n; i++) {
		k = i;
		for (j = i; j <= n; j++) {
            if (a[j][i]) {
                k = j;
                break;
            }
        }
		if (a[k][i] == 0) return 0;
		for (++j; j <= n; j++) if (a[j][i] && a[j][i] < a[k][i]) k = j;
		if (i != k) {
            swap(a[k], a[i]);
            fh ^= 1;
        }
		for (j = i + 1; j <= n; j++) {
			if (a[j][i] > a[i][i]) {
                swap(a[j], a[i]);
                fh ^= 1;
            }
			while (a[j][i]) {
				l = a[i][i] / a[j][i];
				for (k = i; k <= n; k++) a[i][k] = (a[i][k] + (LL)(p - l) * a[j][k]) % p;
				swap(a[j], a[i]);
                fh ^= 1;
			}
		}
		r = (LL)r * a[i][i] % p;
	}
	if (fh) return (p - r) % p;
	return r;
}
void solve() {
    cin >> n >> p;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j];
            a[i][j] %= p;
        }
    }
    cout << cal(a, n, p);
}
```

### 原根
只有模 1, 2, 4, p ^ a, 2 * p ^ a 才存在原根 其中 p 是奇素数 <br>
m >= 3 (g, m) = 1, g 是 m 的原根当且仅当对于任意 phi(m) 的质因子 q, g ^ (phi(m) / q) 不同余 1 <br>
找到了最小原根 g 那么对于 (x, phi(m)) = 1的 x，有 g^x % m 也是 m 的原根 <br>
最小原根从1开始暴力枚举即可，枚举大小最坏不超过 m^0.25 <br>

#### 找出所有原根
```cpp
const int N = 1e6 + 10;
bool have_yg[N], vis[N];
int primes[N], cnt, phi[N];
void init() {
    phi[1] = 1;
    for (int i = 2; i < N; i++) {
        if (!vis[i]) {
            primes[cnt++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; i * primes[j] < N; j++) {
            vis[i * primes[j]] = 1;
            if (i % primes[j] == 0) {
                phi[i * primes[j]] = phi[i] * primes[j];
                break;
            }
            phi[i * primes[j]] = phi[i] * (primes[j] - 1);
        }
    }
    have_yg[2] = have_yg[4] = 1;
    for (int i = 1; i < cnt; i++) {
        i64 now = 1;
        while (now * primes[i] < N) {
            now *= primes[i];
            have_yg[now] = 1;
            if (now * 2 < N) have_yg[now * 2] = 1;
        }
    }
}
i64 qmi(i64 a, i64 k, i64 p) {
    i64 res = 1;
    while (k) {
        if (k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}
void solve() {
    int n, d;
    cin >> n >> d;
    if (!have_yg[n]) {
        cout << 0 << '\n';
        cout << '\n';
        return;
    }
    if (n == 2) {
        cout << 1 << '\n';
        if (d == 1) cout << 1 << '\n';
        else cout << '\n';
        return;
    }
    vector<int> fact;
    int tmp = phi[n];
    for (int i = 2; i * i <= tmp; i++) {
        if (tmp % i == 0) {
            fact.push_back(i);
            while (tmp % i == 0) tmp /= i;
        }
    }
    if (tmp > 1) fact.push_back(tmp);
    auto check = [&](int x) -> bool {
        for (auto u : fact) {
            if (qmi(x, phi[n] / u, n) == 1) 
                return 0;
        }  
        return 1;
    };
    i64 aim;
    for (int i = 1; i <= n - 1; i++) {
        if (__gcd(i, n) != 1) continue;
        if (check(i)) {
            aim = i;
            break;
        } 
    }
    vector<int> ans;
    for (int i = 1; i <= phi[n]; i++) {
        if (__gcd(i, phi[n]) == 1) {
            ans.push_back(qmi(aim, i, n));
        }
    }
    sort(ans.begin(), ans.end());
    cout << ans.size() << '\n';
    for (int i = d; i <= (int)ans.size(); i += d) cout << ans[i - 1] << ' ';
    cout << '\n';
}
```

### 质数和约数
已知
$$
N=\prod_{i=1}^k p_i^{\,c_i}\qquad (p_i\ \text{为互异素数},\ c_i\in\mathbb{Z}_{\ge 0}).
$$
约数个数（$\tau(N)$）：
$$
\tau(N)=\prod_{i=1}^k (c_i+1).
$$
约数之和（$\sigma(N)$）：
$$
\sigma(N)=\prod_{i=1}^k \bigl(p_i^0+p_i^1+\cdots+p_i^{c_i}\bigr)
=\prod_{i=1}^k \frac{p_i^{\,c_i+1}-1}{p_i-1}.
$$

#### 分治求约数之和，a^b
```cpp
i64 qmi(i64 a, i64 k, int p) {
    i64 res = 1;
    while (k) {
        if (k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}
i64 sum(i64 val, i64 num) {
    i64 res = 1;
    if (num == 1) return res;
    if (num & 1) {
        res = (1 + val * sum(val, num - 1)) % mod;
        return res;
    }
    else {
        res = (1 + qmi(val, num / 2, mod)) * sum(val, num / 2) % mod;
        return res; 
    }
}
void solve() {
    i64 a, b;
    cin >> a >> b;
    i64 res = 1;
    vector<pair<i64, i64>> tmp;
    i64 op = a;
    for (int i = 2; i <= op / i; i++) {
        if (op % i == 0) {
            int cnt = 0;
            while (op % i == 0) {
                cnt++;
                op /= i;
            }
            tmp.push_back({(i64)i, cnt});
        }
    }
    if (op > 1) tmp.push_back({op, 1});
    if (a == 0) {
        cout << 0 << '\n';
        return;
    }
    for (auto &[val, num] : tmp) res = (res * sum(val, num * b + 1)) % mod;
    cout << res << '\n';
}
```

#### gcd
```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
int gcd(int m, int n) { // stein 算法求最大公约数
	if (m == n) return m;
	if (m < n) return gcd(n, m);
	if (m % 2 == 0) {
		if (n % 2 == 0) return 2 * gcd(m / 2, n / 2);
		else return gcd(m / 2, n);
	}
	else {
		if (n % 2 == 0) return gcd(m, n / 2);
		else return gcd(n, m - n);
	}
}
```

#### exgcd
求 x, y，使得 ax + by = gcd(a, b) <br>
ax + by = c的 x 的通解为 x = x * (c / gcd) + k * (b / gcd), y = y * (c / gcd) - k * (a / gcd) <br>
```cpp
i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    i64 d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```

#### 线性筛
```cpp
int primes[N], cnt;     // primes[] 存储所有素数
bool vis[N];            // vis[x] 存储 x 是否被筛掉
void get_primes(int n) {
    vis[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] * i <= n; j++) {
            vis[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

#### 快速分解质因数 O(n^0.25)
```cpp
i64 mul(i64 a, i64 b, i64 m) {
    return static_cast<__int128>(a) * b % m;
}
i64 power(i64 a, i64 b, i64 m) {
    i64 res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m)) {
        if (b & 1) {
            res = mul(res, a, m);
        }
    }
    return res;
}
bool isprime(i64 n) { // O(12 logn)
    if (n < 2) return false;
    static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};
    int s = __builtin_ctzll(n - 1);
    i64 d = (n - 1) >> s;
    for (auto a : A) {
        if (a == n) return true;
        i64 x = power(a, d, n);
        if (x == 1 || x == n - 1) continue;
        bool ok = false;
        for (int i = 0; i < s - 1; i++) {
            x = mul(x, x, n);
            if (x == n - 1) {
                ok = true;
                break;
            }
        }
        if (!ok) return false;
    }
    return true;
}
vector<i64> factorize(i64 n) {
    vector<i64> p;
    function<void(i64)> f = [&](i64 n) {
        if (n <= 10000) {
            for (int i = 2; i * i <= n; i++) {
                for (; n % i == 0; n /= i) {
                    p.push_back(i);
                }
            }
            if (n > 1) p.push_back(n);
            return;
        }
        if (isprime(n)) {
            p.push_back(n);
            return;
        }
        auto g = [&](i64 x) {
            return (mul(x, x, n) + 1) % n;
        };
        i64 x0 = 2;
        while (true) {
            i64 x = x0;
            i64 y = x0;
            i64 d = 1;
            i64 power = 1, lam = 0;
            i64 v = 1;
            while (d == 1) {
                y = g(y);
                ++lam;
                v = mul(v, abs(x - y), n);
                if (lam % 127 == 0) {
                    d = __gcd(v, n);
                    v = 1;
                }
                if (power == lam) {
                    x = y;
                    power *= 2;
                    lam = 0;
                    d = __gcd(v, n);
                    v = 1;
                }
            }
            if (d != n) {
                f(d);
                f(n / d);
                return;
            }
            ++x0;
        }
    };
    f(n);
    sort(p.begin(), p.end());
    return p;
}
```

### 中国剩余定理

#### CRT
需保证模数互质
```cpp
int n;
i64 m[11], a[11];
i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    i64 d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
void solve() {
    cin >> n;
    i64 M = 1;
    for (int i = 1; i <= n; i++) {
        cin >> m[i] >> a[i];
        M *= m[i];
    }
    i64 res = 0;
    for (int i = 1; i <= n; i++) {
        i64 Mi = M / m[i];
        i64 inv, y;
        exgcd(Mi, m[i], inv, y);
        res = (res + (i128)a[i] * Mi * inv) % M;
    }
    cout << (res % M + M) % M;
}
```

#### EXCRT
模数可以不互质
```cpp
i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    i64 d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}
void solve() {
    int n;
    cin >> n;
    i64 a1, m1;
    cin >> m1 >> a1;
    for (int i = 1; i <= n - 1; i++) {
        i64 a2, m2;
        cin >> m2 >> a2;
        i64 k1, k2;
        i64 d = exgcd(m1, m2, k1, k2);
        if ((a2 - a1) % d){
            a1 = -1; // 无解
            break;
        }
        k1 *= (a2 - a1) / d;
        i64 t = m2 / d;
        k1 = (k1 % t + t) % t;
        a1 = k1 * m1 + a1;
        m1 = m1 * t;
    }
    cout << a1;
}
```

### 组合数
经典组合恒等式（上指标求和）：
$$
\binom{a}{a} + \binom{a+1}{a} + \cdots + \binom{n}{a}
= \binom{n+1}{a+1}.
$$

组合恒等式：
$$
\sum_{i=0}^{k} i \cdot \binom{\,n-i-1\,}{\,n-k-1\,}
= \binom{n}{k-1}.
$$

利用第二类斯特林数展开幂次：
$$
i^{k}=\sum_{j=1}^{k} S(k,j)\,\binom{i}{j}\,j!,
$$
其中 $S(k,j)$ 表示第二类斯特林数，$\binom{i}{j}$ 为组合数。

组合数恒等式：
$$
\binom{n}{m}\binom{m}{r}
= \binom{n}{r}\binom{\,n-r\,}{\,m-r\,}.
$$

范德蒙德卷积公式：
$$
\sum_{k=0}^{r} \binom{m}{k}\binom{n}{\,r-k\,}
= \binom{m+n}{r},\qquad r=\min(n,m).
$$

二项式定理：
$$
\sum_{i=0}^{n} \binom{n}{i} X^{i} \;=\; (1+X)^{n}.
$$

组合恒等式：
$$
m \cdot \binom{n}{m} \;=\; n \cdot \binom{n-1}{m-1}.
$$

组合恒等式：
$$
\sum_{i=0}^{n} i \cdot \binom{n}{i}
= n \cdot 2^{\,n-1}.
$$

组合恒等式：
$$
\sum_{i=0}^{n} i^{2}\binom{n}{i}
= n(n+1)\,2^{\,n-2}.
$$

组合恒等式：
$$
\sum_{i=0}^{n} \binom{n}{i}^{2}
= \binom{2n}{n}.
$$

选定 $n$ 个单调不增的数，且第一个数固定为 $x$，其方案数为：
$$
\binom{n-1+x}{x}.
$$

**第二类斯特林数** $S(n,m)$ 的递推式：  
$$
S(n,m)=S(n-1,m-1)+m\cdot S(n-1,m).
$$
n 个不一样的球放入 m 个一样的盒子中（非空）<br>
其显式公式：  
$$
S(n,m)=\frac{1}{m!}\sum_{i=0}^{m}(-1)^i \binom{m}{i}(m-i)^{n}.
$$
若盒子视为有标号，则方案数为：
$$
m!\,S(n,m).
$$

**第一类斯特林数** $c(n,m)$ 的递推式：  
$$
c(n,m)=c(n-1,m-1)+(n-1)\,c(n-1,m).
$$
其中 $c(n,m)$ 表示将 $n$ 个互异元素划分为 $m$ 个 **不区分的非空轮换** 的方案数。  

**卡特兰数** $h_n$ 的递推式：  
$$
h_0 = 1,\qquad
h_n = \sum_{i=0}^{n-1} h_i \, h_{n-1-i}, \quad n \ge 2.
$$
其显式公式：  
$$
h_n = \binom{2n}{n} - \binom{2n}{n-1}
= \frac{1}{n+1}\binom{2n}{n}.
$$

卡特兰数 $h_n$ 的前几项为：
$$
h_0 = 1, \quad
h_1 = 1, \quad
h_2 = 2, \quad
h_3 = 5, \quad
h_4 = 14, \quad
h_5 = 42, \quad
h_6 = 132, \quad
h_7 = 429, \quad
h_8 = 1430, \quad
h_9 = 4862, \quad
h_{10} = 16796.
$$

**错排数（Derangements）** $D_n$ 的递推公式：
$$
D_n = (n-1)\bigl(D_{n-1}+D_{n-2}\bigr), \qquad n \ge 2,
$$
其中
$$
D_0 = 1,\quad D_1 = 0.
$$
错排数 $D_n$ 的前几项为：
$$
D_0 = 1, \quad
D_1 = 0, \quad
D_2 = 1, \quad
D_3 = 2, \quad
D_4 = 9, \quad
D_5 = 44, \quad
D_6 = 265, \quad
D_7 = 1854, \quad
D_8 = 14833, \quad
D_9 = 133496, \quad
D_{10} = 1334961.
$$

#### 递推求组合数
```cpp
for (int i = 0; i < N; i++) {
    for (int j = 0; j <= i; j++) {
        if (!j || j == i) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
    }
}
```

#### 预处理逆元求组合数
首先预处理出所有阶乘取模的余数 fact[N]，以及所有阶乘取模的逆元 infact[N], 如果取模的数是质数，可以用费马小定理求逆元
```cpp
i64 qmi(i64 a, i64 k, i64 p) {
    i64 res = 1 % p;
    while (k) {
        if (k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}
// 线性预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i++) fact[i] = (i64)fact[i - 1] * i % mod;
infact[N - 1] = qmi(fact[N - 1], mod - 2, mod);
for (int i = N - 2; i >= 1; i--) infact[i] = infact[i + 1] * (i + 1) % mod;
```

#### $Lucas$ 定理
若 $p$ 是质数，则对任意整数 $0 \le m \le n$，有  
$$
\binom{n}{m} \equiv 
\binom{n \bmod p}{m \bmod p} \cdot 
\binom{\lfloor n/p \rfloor}{\lfloor m/p \rfloor}
\pmod{p}.
$$
```cpp
i64 qmi(i64 a, i64 k, i64 p) {
    i64 res = 1 % p;
    while (k) {
        if (k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}
i64 C(i64 a, i64 b, i64 p) { // 通过定理求组合数 C(a, b)
    if (a < b) return 0;
    i64 x = 1, y = 1;  // x 是分子，y 是分母
    for (i64 i = a, j = 1; j <= b; i--, j++) {
        x = x * i % p;
        y = y * j % p;
    }
    return x * qmi(y, p - 2, p) % p;
}
i64 lucas(i64 a, i64 b, i64 p) {
    if (a < p && b < p) return C(a, b, p);
    return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```

#### 分解质因数法求组合数
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用： <br>
1. 筛法求出范围内的所有质数 <br>
2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中 p 的次数是 n / p + n / p^2 + n / p^3 + ... <br>
3. 用高精度乘法将所有质因子相乘
```cpp
int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
int get(int n, int p) {  // 求n！中p出现的次数
    int res = 0;
    while (n) {
        res += n / p;
        n /= p;
    }
    return res;
}
vector<int> mul(vector<int> &a, int b) {
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i++) {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while (t) {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}
void solve() {
    get_primes(a);  // 预处理范围内的所有质数
    for (int i = 0; i < cnt; i++) { // 求每个质因数的次数
        int p = primes[i];
        sum[i] = get(a, p) - get(b, p) - get(a - b, p);
    }
    vector<int> res;
    res.push_back(1);
    for (int i = 0; i < cnt; i++) {   
        for (int j = 0; j < sum[i]; j++) {
            res = mul(res, primes[i]);
        }
    }
}
```

### 二项式反演
$g(n) = \sum_{i=0}^{n} (-1)^i \binom{n}{i} f(i) \iff f(n) = \sum_{i=0}^{n} (-1)^i \binom{n}{i} g(i)$

$g(n) = \sum_{i=0}^{n} \binom{n}{i} f(i) \iff f(n) = \sum_{i=0}^{n} (-1)^{n-i} \binom{n}{i} g(i)$

$g(n) = \sum_{i=n}^{N} (-1)^i \binom{n}{i} f(i) \iff f(n) = \sum_{i=n}^{N} (-1)^{n-i} \binom{n}{i} g(i)$

$g(n) = \sum_{i=n}^{N} \binom{n}{i} f(i) \iff f(n) = \sum_{i=n}^{N} (-1)^{i-n} \binom{n}{i} g(i)$


### BSGS

#### 普通BSGS
求 a 的 x 次方在模 p 意义下与 b 同余的最小的 x <br>
普通 bsgs 中 a 与 p 互质，所以答案一定小于等于 phi(p) <br>
```cpp
int bsgs(int a, int b, int p) {
    if (1 % p == b % p) return 0;
    int k = sqrt(p) + 1;
    unordered_map<int, int> hh;
    for (int i = 0, j = b % p; i < k; i++) {
        hh[j] = i;
        j = (LL)j * a % p;
    }
    int ak = 1;
    for (int i = 1; i <= k; i++) ak = (LL)ak * a % p;   // 求 a^k
    for (int i = 1, j = 1 % p; i <= k; i++) {
        j = (LL)j * ak % p; 
        if (hh.count(j)) return (LL)i * k - hh[j];
    }
    return -_MAX; // 无解
}
```

#### EXBSGS
扩展 bsgs 中不要求 a 与 p 互质 <br>
如果返回值小于 0 说明无解，可以通过将 -_MAX 设计的更低来确保正确，不过由于递归是 log 级别的，值只要小于 -log 就可以
```cpp
int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
int exbsgs(int a, int b, int p) {
    b = (b % p + p) % p;
    if (1 % p == b % p) return 0;
    int x, y;
    int d = exgcd(a, p, x, y);
    if (d > 1) {
        if (b % d) return -1;
        exgcd(a / d, p / d, x, y);
        return exbsgs(a, (LL)b / d * x % (p / d), p / d) + 1;
    }
    return bsgs(a, b, p);
}
```

### FFT
```cpp
int n, m;
const long double PI = acosl(-1);
struct Complex {
    long double x, y;
    Complex operator+ (const Complex& t) const {
        return {x + t.x, y + t.y};
    }
    Complex operator- (const Complex& t) const {
        return {x - t.x, y - t.y};
    }
    Complex operator* (const Complex& t) const {
        return {x * t.x - y * t.y, x * t.y + y * t.x};
    }
} a[N], b[N];
int rev[N], bit, tot;
void fft(Complex a[], int inv) {
    for (int i = 0; i < tot; i++) {
        if (i < rev[i]) {
            swap(a[i], a[rev[i]]);
        }
    }
    for (int mid = 1; mid < tot; mid <<= 1) {
        auto w1 = Complex({cos(PI / mid), inv * sin(PI / mid)});
        for (int i = 0; i < tot; i += mid * 2) {
            auto wk = Complex({1, 0});
            for (int j = 0; j < mid; j++, wk = wk * w1) {
                auto x = a[i + j], y = wk * a[i + j + mid];
                a[i + j] = x + y, a[i + j + mid] = x - y;
            }
        }
    }
}
void solve() {
    cin >> n >> m;
    for (int i = 0; i <= n; i++) {
        cin >> a[i].x;
    }
    for (int i = 0; i <= m; i++) {
        cin >> b[i].x;
    }
    while ((1 << bit) < n + m + 1) bit++;
    tot = 1 << bit;
    for (int i = 0; i < tot; i++) {
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));
    }
    fft(a, 1), fft(b, 1); // 先正向 求点表示法
    for (int i = 0; i < tot; i++) a[i] = a[i] * b[i];
    fft(a, -1); // 逆向
    for (int i = 0; i <= n + m; i++) {
        cout << (int)(a[i].x / tot + 0.5) << ' ';
    }
}
```

### FWT
```cpp
auto Or = [&](vector<i64> &a, i64 type) -> void {
    int n = a.size();
    for (i64 x = 2; x <= n; x <<= 1) {
        i64 k = x >> 1;
        for (i64 i = 0; i < n; i += x) {
            for (i64 j = 0; j < k; j++) {
                (a[i + j + k] += a[i + j] * type) %= mod;
            }
        }
    }
};
auto And = [&](vector<i64> &a, i64 type) -> void {
    int n = a.size();
    for (i64 x = 2; x <= n; x <<= 1) {
        i64 k = x >> 1;
        for (i64 i = 0; i < n; i += x) {
            for (i64 j = 0; j < k; j++) {
                (a[i + j] += a[i + j + k] * type) %= mod;
            }
        }
    }
};
const int inv2 = qmi(2, mod - 2);
// 正向 type = 1 逆向 type = inv2
auto Xor = [&](vector<i64> &a, i64 type) -> void {
    int n = a.size();
    for (i64 x = 2; x <= n; x <<= 1) {
        i64 k = x >> 1;
        for (i64 i = 0; i < n; i += x) {
            for (i64 j = 0; j < k; j++) {
                (a[i + j] += a[i + j + k]) %= mod;
                (a[i + j + k] = a[i + j] - a[i + j + k] * 2) %= mod;
                (a[i + j] *= type) %= mod;
                (a[i + j + k] *= type) %= mod;
            }
        }
    }
};
// a[i] *= b[i]
```

### Min-25筛

#### 素数 0-2 次求和
```cpp
struct Min25Pack {
    using i128 = __int128_t;
    long long MOD; // <0 => no mod
    long long n, sq;
    vector<int> primes;            // primes <= sqrt(n)
    vector<bool> isp;
    vector<long long> w;           // distinct floor(n/i)
    vector<int> id1, id2;          // index maps
    vector<long long> G0, G1, G2;  // block values after processing primes < current p
    Min25Pack(long long _n, long long _MOD = -1): MOD(_MOD), n(_n) {
        if (n < 2) { sq = 1; return; }
        sq = sqrtl(n);
        sieve_small();
        build_w();
        build_index();
        init_G();
        apply();
    }
    // ---------- math helpers ----------
    inline long long norm(long long x) const {
        if (MOD < 0) return x;
        x %= MOD; if (x < 0) x += MOD; return x;
    }
    inline long long add(long long a, long long b) const {
        if (MOD < 0) return a + b; a += b; if (a >= MOD) a -= MOD; return a;
    }
    inline long long sub(long long a, long long b) const {
        if (MOD < 0) return a - b; a -= b; if (a < 0) a += MOD; return a;
    }
    inline long long mul(long long a, long long b) const {
        if (MOD < 0) { return (long long)((i128)a * (i128)b); }
        return (long long)(((i128)a * (i128)b) % MOD);
    }
    // sum_{i=1}^x i^k helpers (safe, supports x up to ~1e12+)
    inline long long S0(long long x) const { return norm(x); }
    inline long long S1(long long x) const {
        if (MOD < 0) return (long long)((i128)x * (x + 1) / 2);
        return (long long)(((i128)x * (x + 1) / 2) % MOD);
    }
    inline long long S2(long long x) const {
        if (MOD < 0) return (long long)(((i128)x * (x + 1) * (2 * x + 1)) / 6);
        return (long long)((((i128)x * (x + 1) * (2 * x + 1)) / 6) % MOD);
    }
    // build small sieve <= sqrt(n)
    void sieve_small() {
        isp.assign((size_t)sq + 1, true);
        if (sq >= 0) isp[0] = false; if (sq >= 1) isp[1] = false;
        for (int i = 2; i <= sq; ++i) if (isp[i]) {
            primes.push_back(i);
            if ((long long)i * i <= sq)
                for (long long j = 1LL * i * i; j <= sq; j += i) isp[(size_t)j] = false;
        }
    }
    void build_w() {
        w.reserve((size_t)2 * sq + 5);
        for (long long l = 1, r; l <= n; l = r + 1) {
            r = n / (n / l);
            w.push_back(n / l);
        }
        // w 自然降序 (因 n/l 随 l 增减小)
    }
    void build_index() {
        id1.assign((size_t)sq + 1, -1);
        id2.assign((size_t)sq + 1, -1);
        for (int i = 0; i < (int)w.size(); ++i) {
            long long x = w[i];
            if (x <= sq) id1[x] = i; else id2[n / x] = i; // n/x<=sq
        }
    }
    inline int get_id(long long x) const {
        return (x <= sq) ? id1[x] : id2[n / x];
    }
    void init_G() {
        size_t m = w.size();
        G0.resize(m); G1.resize(m); G2.resize(m);
        for (size_t i = 0; i < m; ++i) {
            long long x = w[i];
            G0[i] = sub(S0(x), 1);   // Σ_{2..x} 1
            G1[i] = sub(S1(x), 1);   // Σ_{2..x} i
            G2[i] = sub(S2(x), 1);   // Σ_{2..x} i^2
        }
    }
    void apply() {
        if (n < 2) return;
        long long pre0 = 0; // count of processed primes
        long long pre1 = 0; // sum p
        long long pre2 = 0; // sum p^2
        for (size_t k = 0;k < primes.size(); ++k) {
            long long p = primes[k];
            long long p2 = p * (long long)p;
            if (p2 > n) break; // 无需再更新，因为条件 w[i]>=p2 才处理
            for (size_t i = 0; i < w.size() && w[i] >= p2; ++i) {
                int j = get_id(w[i] / p);
                // G0: count-like
                G0[i] = sub(G0[i], sub(G0[j], pre0));
                // G1: sum p    -> 减去 (G1[j]-pre1)*p
                G1[i] = sub(G1[i], mul(sub(G1[j], pre1), p));
                // G2: sum p^2  -> 减去 (G2[j]-pre2)*p^2
                G2[i] = sub(G2[i], mul(sub(G2[j], pre2), mul(p, p)));
            }
            // 更新已处理素数前缀
            pre0 = add(pre0, 1);
            pre1 = add(pre1, p);
            pre2 = add(pre2, mul(p, p));
        }
    }
    // 提取结果: Pk(n)
    long long prime_count() const { if (n < 2) return 0; return G0[get_id(n)]; }
    long long prime_sum()   const { if (n < 2) return 0; return G1[get_id(n)]; }
    long long prime2_sum()  const { if (n < 2) return 0; return G2[get_id(n)]; }
};
long long min25_pi(long long n) { 
    Min25Pack M(n, -1); 
    return M.prime_count(); 
}
long long min25_prime_sum(long long n) { 
    Min25Pack M(n, -1); 
    return M.prime_sum(); 
}
long long min25_prime2_sum(long long n) { 
    Min25Pack M(n, -1); 
    return M.prime2_sum(); 
}
long long min25_interval_count(long long L, long long R) { 
    if (R < L) return 0; 
    if (R < 2) return 0; 
    if (L < 2) L = 2; 
    return min25_pi(R) - min25_pi(L - 1); 
}
long long min25_interval_sum(long long L, long long R) { 
    if (R < L) return 0; 
    if (R < 2) return 0; 
    if (L < 2) L = 2; 
    return min25_prime_sum(R) - min25_prime_sum(L - 1); 
}
```

#### 素数 0-8 次求和
```cpp
template<int K_MAX>
struct Min25Multi {
    static_assert(K_MAX <= 8, "Faulhaber hardcoded to k<=8 in this header.");
    using i128 = __int128_t;
    long long n;         // query bound
    long long sq;        // floor(sqrt(n))
    long long MOD;       // <0 => no-mod
    // small sieve (primes up to sqrt(n))
    vector<int> primes;
    vector<bool> isp;
    // distinct floor(n / i) values
    vector<long long> w;
    vector<int> id1, id2;
    // block data: G[idx][k] holds current processed value over [2..w[idx]] for k-th power
    vector< array<long long, K_MAX + 1> > G;
    // ---- ctor ----
    Min25Multi(long long _n, long long _MOD = -1): n(_n), MOD(_MOD) {
        if (n < 2) {
            sq = 1;
            return; // trivial; all Pk=0
        }
        sq = (long long)floor(sqrtl((long double)n));
        sieve_small();
        build_w();
        build_index();
        init_G();
        apply();
    }
    /* ===================== arithmetic helpers ===================== */
    inline long long norm(long long x) const {
        if (MOD < 0) return x;
        x %= MOD;
        if (x < 0) x += MOD;
        return x;
    }
    inline long long add(long long a, long long b) const {
        if (MOD < 0) return a + b;
        a += b;
        if (a >= MOD) a -= MOD;
        if (a < 0) a += MOD; // in case of negative b
        return a;
    }
    inline long long sub(long long a, long long b) const {
        if (MOD < 0) return a - b;
        a -= b;
        if (a < 0) a += MOD;
        return a;
    }
    inline long long mul(long long a, long long b) const {
        if (MOD < 0) {
            return (long long)((i128)a * (i128)b);
        }
        return (long long)(((i128)a * (i128)b) % MOD);
    }
    /* ---- extended gcd mod inverse (works if gcd=1) ---- */
    static long long exgcd(long long a, long long b, long long &x, long long &y) {
        if (!b) { x = 1; y = 0; return a; }
        long long x1, y1;
        long long g = exgcd(b, a % b, x1, y1);
        x = y1;
        y = x1 - (a / b) * y1;
        return g;
    }
    long long mod_inv(long long a) const {
        a %= MOD; if (a < 0) a += MOD;
        long long x, y;
        long long g = exgcd(a, MOD, x, y);
        if (g != 1) {
            // not invertible; fallback (should not happen with prime MOD & known denominators)
            // return 0 to avoid crash; caller should ensure gcd=1.
            return 0;
        }
        x %= MOD;
        if (x < 0) x += MOD;
        return x;
    }
    /* ===================== Faulhaber sums S_k(x) (k<=8) =====================
     * Return sum_{i=1}^x i^k  (mod MOD if MOD>=0, else exact in 128 -> long long)
     * Formulas are integer; we do factorization to reduce overflow in no-mod branch.
     */
    inline long long S0(long long x) const { return norm(x); }
    inline long long S1(long long x) const {
        if (MOD < 0) return (long long)((i128)x * (x + 1) / 2);
        return (long long)(((i128)x * (x + 1) / 2) % MOD);
    }
    inline long long S2(long long x) const {
        if (MOD < 0) return (long long)(((i128)x * (x + 1) * (2 * x + 1)) / 6);
        i128 t = (i128)x * (x + 1) % MOD;
        t = t * ((2 * x + 1) % MOD) % MOD;
        return (long long)(t * mod_inv(6) % MOD);
    }
    inline long long S3(long long x) const {
        // (x^2 (x+1)^2)/4
        if (MOD < 0) {
            i128 t = (i128)x * x;
            t = t * (x + 1) * (x + 1);
            return (long long)(t / 4);
        }
        i128 t = (i128)x % MOD; t = t * t % MOD;
        i128 u = (i128)(x + 1) % MOD; u = u * u % MOD;
        t = t * u % MOD;
        return (long long)(t * mod_inv(4) % MOD);
    }
    inline long long S4(long long x) const {
        // x(x+1)(2x+1)(3x^2+3x-1)/30
        if (MOD < 0) {
            i128 a = x, b = x + 1, c = 2 * x + 1;
            i128 d = 3 * (i128)x * x + 3 * (i128)x - 1;
            i128 t = a * b; t %= (i128)9e18; // harmless hint; division safe below
            t = a * b * c; t = a * b * c; // re-eval clean
            t = a * b; t = t * c;
            t = t * d;
            return (long long)(t / 30);
        }
        long long a = x % MOD;
        long long b = (x + 1) % MOD;
        long long c = (2 * x + 1) % MOD;
        long long d = (((3 % MOD) * ((i128)x % MOD) * ((i128)x % MOD)) % MOD + ((3 % MOD) * a) % MOD + MOD - 1) % MOD;
        i128 t = a; t = t * b % MOD; t = t * c % MOD; t = t * d % MOD;
        return (long long)(t * mod_inv(30) % MOD);
    }
    inline long long S5(long long x) const {
        // x^2 (x+1)^2 (2x^2+2x-1)/12
        if (MOD < 0) {
            i128 a = x; a *= x;
            i128 b = x + 1; b *= b;
            i128 c = 2 * (i128)x * x + 2 * (i128)x - 1;
            i128 t = a * b; t *= c;
            return (long long)(t / 12);
        }
        long long a = (i128)x % MOD; a = (i128)a * a % MOD;
        long long b = (i128)(x + 1) % MOD; b = (i128)b * b % MOD;
        long long c = ((2 % MOD) * ((i128)x % MOD) * ((i128)x % MOD) % MOD + (2 % MOD) * ((i128)x % MOD) + MOD - 1) % MOD;
        i128 t = a; t = t * b % MOD; t = t * c % MOD;
        return (long long)(t * mod_inv(12) % MOD);
    }
    inline long long S6(long long x) const {
        // x(x+1)(2x+1)(3x^4 +6x^3 -3x +1)/42
        if (MOD < 0) {
            i128 a = x, b = x + 1, c = 2 * x + 1;
            i128 x2 = (i128)x * x;
            i128 x3 = x2 * x;
            i128 x4 = x3 * x;
            i128 d = 3 * x4 + 6 * x3 - 3 * x + 1;
            i128 t = a * b; t *= c; t *= d;
            return (long long)(t / 42);
        }
        long long xm = x % MOD;
        long long a = xm;
        long long b = (x + 1) % MOD;
        long long c = (2 * x + 1) % MOD;
        i128 x2 = (i128)xm * xm % MOD;
        i128 x3 = x2 * xm % MOD;
        i128 x4 = x3 * xm % MOD;
        long long d = ((3 * x4) % MOD + (6 * x3) % MOD + MOD - (3 * xm) % MOD + 1) % MOD;
        i128 t = a; t = t * b % MOD; t = t * c % MOD; t = t * d % MOD;
        return (long long)(t * mod_inv(42) % MOD);
    }
    inline long long S7(long long x) const {
        // x^2 (x+1)^2 (3x^4 +6x^3 -x^2 -4x +2)/24
        if (MOD < 0) {
            i128 xx = x;
            i128 a = xx * xx;
            i128 b = (xx + 1) * (xx + 1);
            i128 x2 = xx * xx;
            i128 x3 = x2 * xx;
            i128 x4 = x3 * xx;
            i128 d = 3 * x4 + 6 * x3 - x2 - 4 * xx + 2;
            i128 t = a * b; t *= d;
            return (long long)(t / 24);
        }
        long long xm = x % MOD;
        long long a = (i128)xm * xm % MOD;
        long long b = (i128)(x + 1) % MOD; b = (i128)b * b % MOD;
        i128 x2 = (i128)xm * xm % MOD;
        i128 x3 = x2 * xm % MOD;
        i128 x4 = x3 * xm % MOD;
        long long d = ((3 * x4) % MOD + (6 * x3) % MOD + MOD - x2 + MOD - (4 * xm) % MOD + 2) % MOD;
        i128 t = a; t = t * b % MOD; t = t * d % MOD;
        return (long long)(t * mod_inv(24) % MOD);
    }
    inline long long S8(long long x) const {
        // x(x+1)(2x+1)(5x^6 +15x^5 -5x^4 -15x^3 +4x^2 +6x -1)/90
        if (MOD < 0) {
            i128 xx = x;
            i128 a = xx, b = xx + 1, c = 2 * xx + 1;
            i128 x2 = xx * xx;
            i128 x3 = x2 * xx;
            i128 x4 = x3 * xx;
            i128 x5 = x4 * xx;
            i128 x6 = x5 * xx;
            i128 d = 5 * x6 + 15 * x5 - 5 * x4 - 15 * x3 + 4 * x2 + 6 * xx - 1;
            i128 t = a * b; t *= c; t *= d;
            return (long long)(t / 90);
        }
        long long xm = x % MOD;
        long long a = xm;
        long long b = (x + 1) % MOD;
        long long c = (2 * x + 1) % MOD;
        i128 x2 = (i128)xm * xm % MOD;
        i128 x3 = x2 * xm % MOD;
        i128 x4 = x3 * xm % MOD;
        i128 x5 = x4 * xm % MOD;
        i128 x6 = x5 * xm % MOD;
        long long d = ((5 * x6) % MOD + (15 * x5) % MOD + MOD - (5 * x4) % MOD + MOD - (15 * x3) % MOD + (4 * x2) % MOD + (6 * xm) % MOD + MOD - 1) % MOD;
        i128 t = a; t = t * b % MOD; t = t * c % MOD; t = t * d % MOD;
        return (long long)(t * mod_inv(90) % MOD);
    }
    // dispatch
    inline long long sum_pow(int k, long long x) const {
        switch(k) {
            case 0: return S0(x);
            case 1: return S1(x);
            case 2: return S2(x);
            case 3: return S3(x);
            case 4: return S4(x);
            case 5: return S5(x);
            case 6: return S6(x);
            case 7: return S7(x);
            default: return S8(x);
        }
    }
    /* ===================== sieve <= sqrt(n) ===================== */
    void sieve_small() {
        isp.assign((size_t)sq + 1, true);
        if (sq >= 0) isp[0] = false;
        if (sq >= 1) isp[1] = false;
        for (int i = 2; i <= sq; ++i) if (isp[i]) {
            primes.push_back(i);
            if ((long long)i * i <= sq)
                for (long long j = 1LL * i * i; j <= sq; j += i) isp[(size_t)j] = false;
        }
    }
    /* ===================== build w: distinct floor(n/i) ===================== */
    void build_w() {
        w.reserve((size_t)2 * sq + 5);
        for (long long l = 1, r; l <= n; l = r + 1) {
            r = n / (n / l);
            w.push_back(n / l); // descending
        }
    }
    /* ===================== index maps ===================== */
    void build_index() {
        id1.assign((size_t)sq + 1, -1);
        id2.assign((size_t)sq + 1, -1);
        for (int i = 0; i < (int)w.size(); ++i) {
            long long x = w[i];
            if (x <= sq) id1[x] = i;
            else id2[n / x] = i; // n/x <= sq
        }
    }
    inline int get_id(long long x) const {
        return (x <= sq) ? id1[x] : id2[n / x];
    }
    /* ===================== init G ===================== */
    void init_G() {
        size_t m = w.size();
        G.resize(m);
        for (size_t i = 0; i < m; ++i) {
            long long x = w[i];
            for (int k = 0; k <= K_MAX; ++k) {
                long long S = sum_pow(k, x);  // Σ_{i=1}^x i^k
                G[i][k] = sub(S, 1);           // remove i=1
            }
        }
    }
    /* ===================== apply Min_25 ===================== */
    void apply() {
        if (n < 2) return;
        array<long long, K_MAX + 1> pre{};
        for (auto &v : pre) v = 0; // Σ processed primes^k
        for (size_t pi = 0; pi < primes.size(); ++pi) {
            long long p = primes[pi];
            long long p2 = p * (long long)p;
            if (p2 > n) break;
            // precompute p^k
            array<long long, K_MAX + 1> pk;
            pk[0] = 1;
            for (int k = 1; k <= K_MAX; ++k) pk[k] = mul(pk[k - 1], p);
            for (size_t i = 0; i < w.size() && w[i] >= p2; ++i) {
                int j = get_id(w[i] / p);
                for (int k = 0; k <= K_MAX; ++k) {
                    long long delta = sub(G[j][k], pre[k]);
                    G[i][k] = sub(G[i][k], mul(delta, pk[k]));
                }
            }
            // update prefix
            for (int k = 0;k <= K_MAX; ++k) pre[k] = add(pre[k], pk[k]);
        }
    }
    /* ===================== results ===================== */
    long long P(int k) const {
        if (n < 2) return 0;
        return G[get_id(n)][k];
    }
    // 128-bit version (no-mod only). If MOD>=0, call P(k).
    __int128 P128(int k) const {
        if (MOD >= 0) return (__int128)P(k);
        if (n < 2) return 0;
        // reinterpret long long as full; since we never modulo, G already stores full
        return (__int128)G[get_id(n)][k];
    }
    /* ===================== polynomial helper ===================== */
    long long poly_sum(const vector<long long>& coef) const {
        // coef[c] = coefficient of p^c
        long long ans = 0;
        int d = (int)coef.size() - 1;
        if (d > K_MAX) d = K_MAX; // ignore higher terms (or assert)
        for (int k = 0; k <= d; ++k) {
            if (coef[k] == 0) continue;
            ans = add(ans, mul(norm(coef[k]), P(k)));
        }
        return ans;
    }
};
using Multi = Min25Multi<0>;
long long min25_P_interval(long long L, long long R, int k, long long MOD = -1) {
    if (R < L || R < 2) return 0;
    if (L < 2) L = 2;
    Multi MR(R, MOD);
    Multi ML(L - 1, MOD);
    long long r = MR.P(k);
    long long l = ML.P(k);
    if (MOD < 0) return r - l;
    long long ans = r - l;
    if (ans < 0) ans += MOD;
    return ans;
}
```

### 博弈

#### 巴什博弈
有一堆总数为 $n$ 的物品，$2$ 名玩家轮流从中拿取物品。每次至少拿 $1$ 件，至多拿 $m$ 件，不能不拿，最终将物品拿完者获胜。<br>
如果 $(m + 1) | n$ 那么后手胜，否则先手胜

#### 尼姆博弈
两名玩家轮流从数堆物品中拿取一定数量的物品，每次只能选择一堆拿取，至少拿 $1$ 个，至多将这一堆物品全部拿走，不能不拿，拿到最后一个物品的玩家获胜。<br>
尼姆和为 $0$ 后手必胜，否则先手必胜<br>
如果尼姆博弈规则改为拿到最后一个物品者败<br>
1. 若尼姆和为 $0$ 且所有堆中仅有 $1$ 个物品，则先手方有必胜策略；
2. 若尼姆和不为 $0$ 且至少有一堆物品数量大于 $1$，则先手方有必胜策略；
3. 否则后手方有必胜策略。

#### 斐波那契博弈
有一堆个数为 $n$ 的石子，游戏双方轮流取石子，规则如下：
1) 先手至少取 $1$ 颗，且不能取完；
2) 之后每次可以取的石子数至少为 $1$，至多为对手刚取的石子数的 $2$ 倍。
3) 约定取走最后一个石子的人为赢家，求必败态

当 $n$ 为 $Fibonacci$ 数的时候，必败 <br>
齐肯多夫定理：任何正整数都可以表示成若干个不连续的斐波那契数之和，这种和式称为齐肯多夫表述法
```cpp
i64 fib[100]; // fib[87] = 1.1e18
void init() {
    fib[0] = fib[1] = 1;
    for (int i = 2; ; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];
        if (fib[i] >= 1e18) break;
    }
}
vector<i64> get_Zeckendorf(i64 n) {
    vector<i64> res;
    for (int i = 87; i >= 0; i--) {
        if (fib[i] <= n) {
            res.push_back(fib[i]);
            n -= fib[i];
            if (!n) break;
        }
    }
    return res;
}
```

#### 威佐夫博弈
有两堆若干个物品，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取完石子者胜利 <br>
小 = （大 - 小）* 黄金分割比 先手必败，否则先手必胜
```cpp
void solve() {
    i64 a, b;
    cin >> a >> b;
    if (a > b) swap(a, b);
    b = (b - a) * (sqrtl(5) + 1) / 2;
    if (a == b) cout << 0 << '\n';
    else cout << 1 << '\n';
}
```

#### SG函数
```cpp
int sg[N], vis[N];   // 每个点的 sg 函数值
int din[N], dout[N]; // 入度，出度
vector<vector<int>> adj(N);
int getsg(int u) {
    if (sg[u] >= 0) return sg[u];
    for (auto v : adj[u]) vis[getsg(v)] = u;
    for (int i = 0; ; i++) {
        if (vis[i] != u) {
            sg[u] = i;
            break;
        }
    }
    return sg[u];
}
void solve() {
    cin >> n >> m >> k;
    memset(sg, -1, sizeof(sg));
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        adj[x].push_back(y);
        din[y]++;
        dout[x]++;
    }
    vector<int> root, end; // 有向无环图可能有多个起点和终点
    for (int i = 1; i <= n; i++) {
        if (din[i] == 0) {
            root.push_back(i);
        }
        if (dout[i] == 0) {
            end.push_back(i);
        }
    }
    for (int i = 0; i < end.size(); i++) sg[end[i]] = 0;
    for (int i = 0; i < root.size(); i++) getsg(root[i]);
    int ans = 0;
    for (int i = 1; i <= k; i++) {
        int x;
        cin >> x;
        ans ^= sg[x];
    }
    if (ans == 0) cout << "lose" << '\n';
    else cout << "win" << '\n'; 
}

```

### 万能欧几里德算法
$\sum_{i=1}^{n} \frac{p i + r}{q}$

$\sum_{i=1}^{n} \left(\frac{p i + r}{q}\right)^2$

$\sum_{i=1}^{n} i \cdot \frac{p i + r}{q}$
```cpp
const int mod = 998244353;
struct Node {
    // cntu 是 u 的数量  cntr 是 r 的数量
    // sumi 是 i 的总和  sums 是 (p * i + r) / q 的总和
    // sqrs 是 ((p * i + r) / q) ^ 2 的总和
    // prod 是 i * ((p * i + r) / q) 的总和
	i64 cntu, cntr, sumi, sums, sqrs, prod;
    Node () { cntu = cntr = sumi = sums = sqrs = prod = 0; }
	Node operator + (Node b) {
		Node c;
		c.cntu = (cntu + b.cntu) % mod, c.cntr = (cntr + b.cntr) % mod;
		c.sumi = (sumi + b.sumi + cntr * b.cntr) % mod;
		c.sums = (sums + b.sums + cntu * b.cntr) % mod;
		c.sqrs = (sqrs + b.sqrs + ((cntu * cntu) % mod) * b.cntr + (2 * cntu * b.sums) % mod) % mod;
		c.prod = ((prod + b.prod + ((cntu * cntr) % mod) * b.cntr) % mod + cntu * b.sumi + cntr * b.sums) % mod;
		return c;
	}
} nu, nr, ans;
Node qpow (Node a, i64 k) {
	Node res;
	while (k) {
		if (k & 1) res = res + a;
		a = a + a;
        k >>= 1;
	}
	return res;
}
i64 div (i64 a, i64 b, i64 c, i64 d) {
    return ((long double)1.0 * a * b + c) / d;
}
Node solve (i64 p, i64 q, i64 r, i64 l, Node a, Node b) {
	if (!l) return Node();
	if (p >= q) return solve(p % q, q, r, l, a, qpow(a, p / q) + b);
	i64 m = div(l, p, r, q);
	if (!m) return qpow(b, l);
	i64 cnt = l - div(q, m, -r - 1, p);
	return qpow(b, (q - r - 1) / p) + a + solve(q, p, (q - r - 1) % p, m - 1, b, a) + qpow(b, cnt);
}
void solv() {
    i64 n, p, r, q;
    cin >> n >> p >> r >> q;
    nu.cntu = 1, nu.cntr = 0, nu.sumi = 0, nu.sums = 0, nu.sqrs = 0, nu.prod = 0;
    nr.cntu = 0, nr.cntr = 1, nr.sumi = 1, nr.sums = 0, nr.sqrs = 0, nr.prod = 0;
    ans = qpow(nu, r / q) + solve(p, q, r % q, n, nu, nr);
    cout << ans.sums << ' ' << ans.sqrs << ' ' << ans.prod << '\n';
}
```